#coding=utf8

# 내문서/maya/{버전}/scripts/mayawms.py로 저장한 후,
# 아래 세줄을 스크립트 에디터에서 실행하거나 셸프에 등록하세요.
'''
import mayawms
reload(mayawms)
mayawms.UI()
'''
#   2017-08-08
#   수정사항
#1. IP 전체 통일 시너지 / 외주 모두 사용가능
#2. Upload / download 오류 수정
#3. Scene 완료 시 Playblast 화면 오류로 인한 문제 수정

# 작업관리스크립트를 배포할때는 pub이라는 스크립트를 사용한다.
# pub을 통해 퍼블리시 스크립트로 만들때 아래 변수를 자동으로 고쳐준다.
# VERSION는 버전명, DEV는 False가 된다.

#PingoW pingo에서 외주 업체 현재 원더볼즈2만 프로젝트 참여 
#권한은 pingo LDAP에서 권한 부여 해야 함


VERSION = "Synergy Media 1.0.17"
#VERSION = "Bam 1.0.16"
#VERSION = "Pingo 1.0.16"
DEV = False

import json, os, sys, shutil, subprocess, re, glob, uuid, time, datetime, filecmp, urllib, urllib2, ftplib, inspect, zipfile, errno, socket, httplib, json, collections
import xml.etree.ElementTree as ET
from functools import partial
from collections import defaultdict
from maya import cmds, mel

# 레퍼런스 로딩이 느려지는 현상을 제거하기 위한 환경설정 적용
# preferences/UI Elements
# Turning off "Save panel layouts with file", "Restore saved layouts", "Keep current layout", "Reset viewport panel settings"
mel.eval('$gUseSaveScenePanelConfig = false; file -uc false;')
mel.eval('$gUseScenePanelConfig = false; file -uc false;')
#mel.eval('$gUseNewScenePanelConfig = true;')
#mel.eval('$gNewScenePanelConfig = "Four View";')
mel.eval('optionVar -intValue ResetModelViewsOnNewScene 0;')

# 퍼블리시를 하면 아래 # onepy 코멘트가 붙은 줄의 경우
# 해당 파일의 내용을 복사해서 여기에 붙여넣게 된다.
# 한 파일로 무리 없이 돌아가게 하기 위해서 코드가 고쳐진다.

def smgweb_post(host, url, option):
    u'''
    지정된 서버의 url에 POST로 값을 전달하고 응답을 듣는다. 응답은 바이트스트림이므로 프린트를 할때는 utf8로 디코딩 해준다.

    response = smgweb_post('192.168.0.138', '.../some.php', {'value':'hello'})
    print(response.decode('utf8'))
    rootEl = ET.XML(response)
    '''
    return _smgweb_req('POST', host, url, option)

def _smgweb_req(typ, host, url, option):
    _smgweb_utf8Encode(option)
    conn = httplib.HTTPConnection(host)
    conn.request(
                    typ,
                    url,
                    urllib.urlencode(option),
                    {'Content-Type':'application/x-www-form-urlencoded', 'Accept':'text/plain'}
    )
    return conn.getresponse().read()

def _smgweb_utf8Encode(option):
    for k, v in option.iteritems():
        try:
            uv = v.encode('utf8')
        except:
            raise RuntimeError("cannot encode {0} to utf8".format(v))
        option[k] = uv

# generated by onepy : smgffmpeg
#coding=utf8

def uploadInstalledList():
    if sys.platform == 'win32':
        installedList = ''
        myIP = socket.gethostbyname(socket.gethostname())

        proc = subprocess.Popen('reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall /s /f DisplayName', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = proc.communicate()
        installedList += '32bit\n\n'
        for rl in out.split('\n'):
            if rl.count('DisplayName'):
                installedList += rl.split('REG_SZ')[-1]

        installedList += '\n\n\n\n'

        proc = subprocess.Popen('reg query HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall /s /f DisplayName', shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = proc.communicate()
        installedList += '64bit\n\n'
        for rl in out.split('\n'):
            if rl.count('DisplayName'):
                installedList += rl.split('REG_SZ')[-1]

        fn = LOCAL_ROOT+'/installed-'+myIP+'.log'
        installedList = installedList.decode('cp949').encode('utf-8')
        with open(fn, 'w') as f:
            f.write(installedList)

        uploadFileToStorage = [
            CURL, '-X', 'POST',
            '--fail', '--silent', '--show-error', # 진짜 에러만 stderr로 출력
            '-F', 'upload_dir={0}'.format('app/pipeline/log/installed/'),
            '-F', 'file=@{0}'.format(fn),
            'http://{0}/wms/script/upload.php'.format(WMS_HOST),
        ]
        subprocess.Popen(uploadFileToStorage, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

def smgffmpeg_New(exepath):
    return smgffmpeg_FFMpeg(exepath)

class smgffmpeg_FFMpeg:
    def __init__(self, exepath):
        self.exe = exepath

    def SeqToMp4(self, inpath, outpath, width, height, startf, endf, fps, soundfile=''):
        '''시퀀스를 받아 mp4로 변환하는 함수. 실행중 문제가 생기면 에러 문자열을 반환한다.'''
        cmd = [
                self.exe,
                '-start_number', str(startf),
                '-r', str(fps), # 인풋 프레임 레이트
                '-i', inpath
        ]

        if soundfile:
            cmd += ['-i', soundfile,]

        cmd += [
                '-t', str(float(endf-startf+1)/fps),
                '-r', str(fps), # 아웃풋 프레임 레이트
                '-aspect', str(width/float(height)),
                '-vcodec', 'libx264',
                # 퀄리티 옵션들
                # '-q:v', '1',
                # '-b:v', '1300k',
                # '-qp', '0',
                # '-crf', '3',
                '-preset', 'slower',
                '-qp', '15',
                '-tune', 'animation',
                '-y',
                outpath
        ]

        print('\nffmpeg command : '+' '.join(cmd)+'\n')

        # ffmpeg 실행
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE , stderr=subprocess.PIPE, bufsize=1)
        for l in iter(p.stderr.readline, b''): # ffmpeg는 stderr채널로 정보를 전송한다.
            print("ffmpeg - " + l),

        p.wait()
        if p.returncode:
            return u'영상을 만드는데 실패했습니다. 종료코드 {code}'.format(code=p.returncode)

    def ResizeImage(self, inpath, outpath, width, height, overwrite=False):
        '''ffmpeg를 이용한 이미지 리사이즈. 실패시 에러문자열을 반환한다.'''
        if not overwrite and os.path.exist(outpath):
            raise RuntimeError('file exists - {0}'.format(outpath))

        cmd = [
            self.exe,
            '-i', inpath,
            '-qmax', '1', '-qmin', '1',
            '-vf', 'scale={0}:{1}'.format(width, height),
            '-y',
            outpath
        ]

        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        _, stderr = p.communicate()
        for l in stderr.splitlines():
            print("ffmpeg - " + l + "\n")

        p.wait()
        if p.returncode:
            return u'영상을 만드는데 실패했습니다. 종료코드 {code}'.format(code=p.returncode)


# generated by onepy : smgenv
#coding=utf8

import os

def smgenv_djv():
    env = os.environ.copy()
    env['LIBQUICKTIME_PLUGIN_DIR']=''
    return env

# generated by onepy : smgstr
def smgstr_mustReplace(string, a, b, maxreplace=-1):
    if maxreplace == 0:
        raise ValueError("maxreplace arg should not 0")
    elif maxreplace > 0:
        if string.count(a) < maxreplace:
            raise RuntimeError("need {n} of {a}, only {m} exists in : {string}".format(n=maxreplace, m=string.count(a), a=a, string=string))
    else:
        if a not in string:
            raise RuntimeError(a + " not in : " + string)
    return string.replace(a, b, maxreplace)
# generated by onepy : smgpath
#coding=utf8

import os
import sys

def smgpath_make(dir):
    try:
        os.makedirs(dir)
    except:
        pass
    if os.path.exists(dir):
        return True
    else:
        return False

def smgpath_makeOne(dir):
    try:
        os.mkdir(dir)
    except:
        pass
    if os.path.exists(dir):
        return True
    else:
        return False

def smgpath_openUp(path):
        if sys.platform == 'win32':
            os.startfile(path)
        elif sys.platform == 'linux2':
            os.system('xdg-open '+path)
        else:
            raise RuntimeError('not support the os yet - '+sys.platform)

def smgpath_split(filepath):
    r'''
        전체경로를 받아서 디렉토리, 파일이름, (. 제외한)확장자를 돌려준다.
    '''
    dir, rootExt = os.path.split(filepath)
    if '.' not in rootExt:
        return dir, rootExt
    root, ext = rootExt.rsplit('.', 1)
    return dir, root, ext

cmds.optionVar(intValue=('exportIncludeInputs', 1))
cmds.optionVar(intValue=('exportIncludeHistory', 1))
cmds.optionVar(intValue=('exportIncludeChannels', 1))
cmds.optionVar(intValue=('exportIncludeExpressions', 1))
cmds.optionVar(intValue=('exportIncludeConstraints', 1))
cmds.optionVar(intValue=('exportIncludeShaders', 1))
cmds.optionVar(intValue=('exportEditsIncludeInputs', 1))

def mayascene_new(name=None):
    '''현재 마야창으로 새 씬을 연다.'''
    cmds.file(new=True, f=True)
    if name:
        cmds.file(rename=name)
def mayascene_load(name):
    '''현재 마야창으로 해당 경로의 씬을 연다. 작업을 저장할지 물어보지 않으므로 주의.'''
    cmds.file(name, o=True, f=True)
def mayascene_save(type='mayaBinary'):
    '''현재 마야씬을 저장하고 저장된 경로를 반환한다.'''
    return cmds.file(save=True, type=type)
def mayascene_saveAs(name):
    '''현재 마야씬을 name이라는 이름으로 저장한다. 여기서 name은 항상 전체경로여야 한다.'''
    cmds.file(rename=name)
    if not mayascene_path():
        raise RuntimeError('rename scene does not properly done.')
    return mayascene_save()
def mayascene_embed(name, useNamespace=True, namespace=''):
    '''해당 경로에 있는 마야씬을 임포트한다.'''
    if useNamespace:
        if not namespace:
            namespace = os.path.basename(os.path.splitext(name)[0])
        cmds.file(name, i=True, ignoreVersion=True, ra=True, mergeNamespacesOnClash=False, namespace=namespace, options='v=0;p=17;f=0', pr=True, loadReferenceDepth='all')
    else:
        cmds.file(name, i=True, ignoreVersion=True, mergeNamespacesOnClash=False, options='v=0;p=17;f=0', pr=True, loadReferenceDepth='all')
def mayascene_reference(name, namespace=''):
    '''해당 경로에 있는 마야씬을 현재 마야씬에 레퍼런스 시킨다.'''
    if not namespace:
        namespace = os.path.basename(os.path.splitext(name)[0])
    cmds.file(name, r=True, ignoreVersion=True, gl=True, mergeNamespacesOnClash=False, namespace=namespace, options='v=0;p=17;f=0')
def mayascene_exportAll(name):
    '''현재 마야씬의 모든 오브젝트를 다른 이름으로 저장한다.'''
    cmds.file(name, force=True, options='v=0;', type='mayaBinary', preserveReferences=True, exportAll=True)
def mayascene_exportSelection(name):
    '''현재 마야씬에서 선택된 오브젝트를 다른 이름으로 저장한다.'''
    cmds.file(name, force=True, options='v=0;', type='mayaBinary', preserveReferences=True, exportSelected=True)
def mayascene_path():
    '''현재 마야씬의 위치를 반환한다.'''
    return cmds.file(q=True, sceneName=True)
def mayascene_directory():
    '''현재 마야씬이 들어있는 디렉토리를 반환한다.'''
    return os.path.dirname(mayascene_path())
def mayascene_name():
    '''현재 마야씬의 (디렉토리를 제외한) 이름을 반환한다.'''
    return os.path.basename(mayascene_path())
def mayascene_root():
    '''현재 마야씬의 (디렉토리와 확장자를 제외한) 이름을 반환한다.'''
    return os.path.splitext(mayascene_name())[0]
def mayascene_ext():
    '''현재 마야씬의 확장자를 반환한다.'''
    return os.path.splitext(mayascene_name())[1]
def mayascene_jobName():
    '''쓰면 안됨.'''
    return '_'.join(mayascene_name().split('_')[3:-1])
def mayascene_modified():
    '''현재 마야씬이 마지막 저장후 수정되었는지를 논리값으로 반환한다.'''
    return cmds.file(q=True, modified=True)
def mayascene_currentFrame():
    '''현재 마야씬에서 가리키고 있는 프레임 번호를 반환한다.'''
    return cmds.currentTime(query=True)
def mayascene_setCurrentFrame(f):
    '''현재 마야씬이 해당 프레임을 가리키도록 한다.'''
    return cmds.currentTime(f)

def mayascene_selectedRange():
    '''현재 마야씬에서 사용자가 시프트+드래그로 선택한 (빨갛게 바뀐) 프레임 구간를 반환한다.'''
    result = mel.eval('$range = `timeControl -q -range $gPlayBackSlider`;')
    # 결과는 'start:end'로 나온다. end값은 실제 선택된 프레임보다 1 크다.
    startstr, endstr = result.strip('"').split(':')
    start, end = int(startstr), int(endstr)-1
    if end == start:
        return
    return start, end

def mayascene_playbackStart():
    '''현재 씬의 플레이백 슬라이더 시작 프레임을 반환한다.'''
    return int(cmds.playbackOptions(q=True, minTime=True))
def mayascene_playbackEnd():
    '''현재 씬의 플레이백 슬라이더 끝 프레임을 반환한다.'''
    return int(cmds.playbackOptions(q=True, maxTime=True))
def mayascene_playbackRange():
    '''현재 씬에 설정된 플레이백 슬라이더 구간을 리스트 형태로 반환한다.'''
    return mayascene_playbackStart(), mayascene_playbackEnd()
def mayascene_playbackRangeString():
    '''현재 씬에 설정된 플레이백 슬라이더 구간을 '시작-끝' 문자열 형태로 반환한다.'''
    return '{0}-{1}'.format(mayascene_playbackStart(), mayascene_playbackEnd())
def mayascene_playbackDuration():
    '''현재 씬에 설정된 플레이백 슬라이더 구간의 길이를 정수형으로 반환한다.'''
    return mayascene_playbackEnd()-mayascene_playbackStart() + 1
def mayascene_setPlaybackRange(minf, maxf):
    '''현재 씬의 플레이백 슬라이더 구간을 다시 설정한다.'''
    cmds.playbackOptions(minTime=minf)
    cmds.playbackOptions(maxTime=maxf)

def mayascene_animationStart():
    '''현재 씬의 시작 프레임을 반환한다.'''
    return int(cmds.playbackOptions(q=True, animationStartTime=True))
def mayascene_animationEnd():
    '''현재 씬의 끝 프레임을 반환한다.'''
    return int(cmds.playbackOptions(q=True, animationEndTime=True))
def mayascene_animationRange():
    '''현재 씬의 프레임 구간을 [시작, 끝] 리스트 형태로 반환한다.'''
    return mayascene_animationStart(), mayascene_animationEnd()
def mayascene_animationRangeString():
    '''현재 씬의 프레임 구간을 '시작-끝' 문자열 형태로 반환한다.'''
    return '{0}-{1}'.format(mayascene_animationStart(), mayascene_animationEnd())
def mayascene_animationDuration():
    '''현재 씬의 프레임 구간 길이를 정수형으로 반환한다.'''
    return mayascene_animationEnd() - mayascene_animationStart() + 1
def mayascene_setAnimationRange(minf, maxf):
    '''현재 씬의 프레임 구간을 재설정한다.'''
    cmds.playbackOptions(animationStartTime=minf)
    cmds.playbackOptions(animationEndTime=maxf)

def mayascene_frameRate():
    '''현재 씬의 초당 프레임수를 반환한다.'''
    fps = {'game':15, 'film':24, 'pal':25, 'ntsc':30, 'show':48, 'palf':50, 'ntscf':60}
    unit = cmds.currentUnit(fullName=True, q=True, time=True)
    if unit.endswith('fps'):
        return int(unit[:-3])
    return fps[unit]
def mayascene_setFrameRate(fps):
    '''현재 씬의 초당 프레임수를 재설정한다.'''
    unit = {15:'game', 24:'film', 25:'pal', 30:'ntsc', 48:'show', 50:'palf', 60:'ntscf'}
    if fps in unit.keys():
        cmds.currentUnit(time=unit[fps])
    else:
        cmds.currentUnit(time=str(fps)+'fps')

def mayascene_references(recursive=False):
    '''사용하지 말것.'''
    def refQuery(r):
        cmds.referenceQuery(r, f=True, child=True)

    refs = cmds.file(q=True, r=True)
    if not recursive:
        return refs
def mayascene_cameras():
    '''현재 씬에 있는 카메라 리스트를 반환한다.'''
    return cmds.ls(type='camera')
def mayascene_nodes():
    '''현재 씬의 모든 노드 리스트 반환한다.'''
    return cmds.ls(dag=True)
def mayascene_shapeNodes():
    '''현재 씬의 셰잎 노드 리스트를 반롼한다.'''
    return cmds.ls(geometry=True)
def mayascene_defaultRenderLayer():
    '''
        현재 씬의 디폴트 렌더 레이어를 반환한다.
        이 이름은 보통 defaultRenderLayer이고 바뀌지도 않지만
        레퍼런스 도중 충돌이 일어나면 이름이 바뀐상태로 변경이 불가능하다.
    '''
    # 레퍼런스 되지 않은 레이어 중 이름이 변경되지 않는 레이어를 디폴트 렌더 레이어로 추정.
    for l in cmds.ls(type='renderLayer'):
        if ':' in l:
            continue
        try:
            cmds.rename(l, l+'QAZXSWEDCVFR')
        except:
            return l
        else:
            cmds.rename(l+'QAZXSWEDCVFR', l)
def mayascene_renderer():
    '''현재 씬의 렌더러를 반환한다.'''
    return mel.eval('currentRenderer()')
def mayascene_defaultRenderer():
    if mayascene_currentRenderLayer() == mayascene_defaultRenderLayer():
        return mel.eval('currentRenderer()')
    adjs = cmds.listConnections( mayascene_defaultRenderLayer()+'.adjustments', p=True, c=True)
    if not adjs:
        adjs = []
    if 'defaultRenderGlobals.currentRenderer' in adjs:
        # 커넥션 인덱스는 이름보다 하나 앞이다.
        connPlug = adjs[adjs.index('defaultRenderGlobals.currentRenderer')-1]
        return cmds.getAttr(connPlug.replace('plug', 'value'))
    return mel.eval('currentRenderer()')
def mayascene_renderLayers(excludeBadLayers=True):
    '''현재 씬의 렌더레이어 리스트를 반환한다. 레퍼런스 된 레이어는 반환되지 않는다. 주의할점은 레퍼런스에서 넘어온 레이어중 디폴트 렌더 레이어 (예 : SomeCharater_defaultRenderLayer)이 기본적으로 반환되지 않는다는 점이다. 이를 반환 리스트에 추가하려면 excludeBadLayers=False 인수를 전달하여야 한다.'''
    rl = []
    for l in cmds.ls(type='renderLayer'):
        # 레퍼런스된 레이어를 제외한다.
        if cmds.referenceQuery(l, isNodeReferenced=True):
            continue
        # excludeBadLayers가 켜져 있으면 레퍼런스에서 넘어온 디폴트 렌더 레이어를 추가하지 않는다.
        # (예: Character_defaultRenderLayer)
        if excludeBadLayers:
            if 'defaultRenderLayer' in l:
                if l != mayascene_defaultRenderLayer():
                    continue
        rl.append(l)
    return rl
def mayascene_enabledRenderLayers(excludeBadLayers=True):
    '''현재 씬의 켜진 렌더레이어 리스트를 반환한다. 레퍼런스 된 레이어는 반환되지 않는다. 주의할점은 레퍼런스에서 넘어온 레이어중 디폴트 렌더 레이어 (예 : SomeCharater_defaultRenderLayer)이 기본적으로 반환되지 않는다는 점이다. 이를 반환 리스트에 추가하려면 excludeBadLayers=False 인수를 전달하여야 한다.'''
    e = []
    for l in mayascene_renderLayers(excludeBadLayers=excludeBadLayers):
        layeron = cmds.getAttr(l+'.renderable')
        if layeron:
            e.append(l)
    return e
def mayascene_disabledRenderLayers(excludeBadLayers=True):
    '''현재 씬의 꺼진 렌더레이어 리스트를 반환한다. 레퍼런스 된 레이어는 반환되지 않는다. 주의할점은 레퍼런스에서 넘어온 레이어중 디폴트 렌더 레이어 (예 : SomeCharater_defaultRenderLayer)이 기본적으로 반환되지 않는다는 점이다. 이를 반환 리스트에 추가하려면 excludeBadLayers=False 인수를 전달하여야 한다.'''
    d = []
    for l in mayascene_renderLayers(excludeBadLayers=excludeBadLayers):
        layeron = cmds.getAttr(l+'.renderable')
        if not layeron:
            d.append(l)
    return d
def mayascene_currentRenderLayer():
    '''현재 씬의 렌더 탭에서 선택된 렌더레이어를 반환한다.'''
    return cmds.editRenderLayerGlobals(query=True, currentRenderLayer=True)
def mayascene_setCurrentRenderLayer(rlayer):
    '''현재 씬의 렌더 탭에서 선택된 렌더레이어를 반환한다.'''
    return cmds.editRenderLayerGlobals(currentRenderLayer=rlayer)
# 텍스쳐 관련 함수에서 문제는 같은 텍스쳐를 부르는 노드가 여러개일수 있다는 점이다.
# *NodeAndPaths()의 경우는 노드위주이고 중복을 허용한다.
# *TexturesDict()는 텍스쳐 위주의 사전 형식으로 반환되는데 {텍스쳐:관련노드} 형식이다.
def mayascene_textureNodesAndRawPaths():
    '''glob용 문자열이 아니라 원래 노드 패스에 적혀있던 문자열을 반환한다.'''
    nodes = cmds.ls(type='file')
    paths = []
    for n in nodes:
        f = cmds.getAttr(n+'.fileTextureName')
        paths.append(f)
    paths = [f.replace('\\', '/') for f in paths] # 언제나 유닉스형식의 패스로 반환한다.
    return zip(nodes, paths)
def mayascene_textureNodesAndPaths():
    '''
    현재 씬의 텍스쳐 노드와 그 경로를 반환한다.
    경로의 경우 텍스쳐 노드에 시퀀스 체크가 되어있으면 glob.glob에서 쓸 문자열로 바꾼다. (.../test.0001.exr -> .../test*.exr)
    시퀀스 체크가 되어있지 않다면 원래 경로를 반환한다.
    '''
    nodes = cmds.ls(type='file')
    paths = []
    for n in nodes:
        f = cmds.getAttr(n+'.fileTextureName').replace('\\', '/')
        seq = cmds.getAttr(n+'.useFrameExtension')
        if seq: # 시퀀스일 경우 glob.glob에서 쓸 문자열로 바꿈 test.0001.exr -> test*.exr
            root, ext = os.path.splitext(f)
            paths.append(root.rstrip('._1234567890')+'*'+ext)
        elif f.count('<UDIM>'):
            paths.append(f.replace('<UDIM>', '*'))
        else:
            paths.append(f)
    #paths = [f.replace('\\', '/') for f in paths] # 언제나 유닉스형식의 패스로 반환한다.
    return zip(nodes, paths)
def mayascene_textureNodesAndPathsInside(path):
    '''
    * 쓰지 마세요 : 너무 세세한 사항이라 없어집니다. *
    해당 경로 아래에 있는 텍스쳐노드와 그 경로만 반환한다.
    '''
    return [(n, p) for n, p in mayascene_textureNodesAndPaths() if p.upper().startswith(path.upper())]
def mayascene_textureNodesAndPathsNotInside(path):
    '''
    * 쓰지 마세요 : 너무 세세한 사항이라 없어집니다. *
    해당 경로 밖에 있는 텍스쳐노드와 그 경로만 반환한다.
    '''
    return [(n, p) for n, p in mayascene_textureNodesAndPaths() if not p.upper().startswith(path.upper())]
def mayascene_existTextureNodesAndPaths():
    '''텍스쳐 경로에 파일이 있는 텍스쳐 노드와 패스만 반환한다.'''
    return [(n, p) for n, p in mayascene_textureNodesAndPaths() if glob.glob(p)] #  os.path.isfile 대신 glob.glob을 쓴다. 시퀀스에 대해서도 잘 캐치하기 위해서이다.
def mayascene_missingTextureNodesAndPaths():
    '''텍스쳐 경로에 파일이 없는 텍스쳐 노드와 패스만 반환한다.'''
    return [(n, p) for n, p in mayascene_textureNodesAndPaths() if not glob.glob(p)] #  os.path.isfile 대신 glob.glob을 쓴다. 시퀀스에 대해서도 잘 캐치하기 위해서이다.
def mayascene_textures():
    '''텍스쳐 패스와 그 텍스쳐를 가리키고 있는 노드들을 사전식으로 반환한다.'''
    return mayascene_texDict(mayascene_textureNodesAndPaths())
def mayascene_texturesInside(path):
    '''
    * 쓰지 마세요 : 너무 세세한 사항이라 없어집니다. *
    해당 경로 안에 있는 텍스쳐만 반환한다.
    '''
    return mayascene_texDict(mayascene_textureNodesAndPathsInside(path))
def mayascene_texturesNotInside(path):
    '''
    * 쓰지 마세요 : 너무 세세한 사항이라 없어집니다. *
    해당 경로 밖에 있는 텍스쳐만 반환한다.
    '''
    return mayascene_texDict(mayascene_textureNodesAndPathsNotInside(path))
def mayascene_existTextures():
    '''
    파일 노드에 지정된 텍스쳐중 해당 위치에 파일이 있는 텍스쳐와 그 텍스쳐를 가리키고 있는 노드들을 사전식으로 반환한다.
    예 : {'tex1_path':[node1, node3], 'tex2_path':[node2, node7], ...}
    '''
    return mayascene_texDict(mayascene_existTextureNodesAndPaths())
def mayascene_missingTextures():
    '''
    파일 노드에 지정된 텍스쳐중 해당 위치에 파일이 없는 텍스쳐와 그 텍스쳐를 가리키고 있는 노드들을 사전식으로 반환한다.
    예 : {'tex1_path':[node1, node3], 'tex2_path':[node2, node7], ...}
    '''
    return mayascene_texDict(mayascene_missingTextureNodesAndPaths())
def mayascene_texDict(nodeAndPath):
    '''내부적으로 쓰는 함수. 텍스쳐 노드와 패스를 받고, 패스에 관련된 노드들을 달아주는 사전형태로 바꾼다. 키가 패스이고 값이 노드라는 점에 유의하자.'''
    d = defaultdict(list)
    for n, p in nodeAndPath:
        d[p].append(n)
    return d
def mayascene_shaders():
    '''현재 씬의 셰이더 리스트를 반환한다.'''
    return cmds.ls(materials=True)
def mayascene_mayaShaders():
    '''현재 씬의 마야 셰이더 리스트를 반환한다.'''
    mtypes = [
                'anisotropic', 'blinn', 'hairTubeShader', 'lambert', 'layeredShader', 'oceanShader', 'phong', 'phongE', 'rampShader', 'shadingMap', 'surfaceShader', 'useBackground',
                'envFog', 'fluidShape', 'lightFog', 'particleCloud', 'volumeFog', 'volumeShader',
                'cMuscleShader', 'displacementShader'
    ]
    return cmds.ls(type=mtypes)
def mayascene_vrayShaders():
    '''현재 씬의 브이레이 셰이더 리스트를 반환한다.'''
    vtypes = list(set(cmds.listNodeTypes('shader')) & set([i for i in cmds.ls(nodeTypes=True) if i.startswith('VRay')]))
    return cmds.ls(type=vtypes)
def mayascene_viewports():
    '''현재 씬의 뷰포트 리스트를 반환한다.'''
    return [p for p in cmds.lsUI(panels=True) if p.startswith('modelPanel')]

# 씬 정리
def mayascene_unknownNodes():
    '''현재 씬의 타입을 알수 없는 노드 리스트를 반환한다.'''
    return cmds.ls(type='unknown') + cmds.ls(type='unknownDag') + cmds.ls(type='unknownTransform')
def mayascene_emptyGroups():
    '''현재 씬의 비어있는 그룹 리스트를 반환한다.'''
    empty = []
    associateNodes = list(set(cmds.referenceQuery(topReference=True, editNodes=True, editCommand='parent')))
    for obj in cmds.ls(transforms=True, leaf=True):
        anychild = [i for i in associateNodes if cmds.ls(obj, long=True)[0] in i]
        if not anychild:
            if not cmds.listRelatives(obj, children=True):
                if cmds.objectType(obj) == 'transform':
                    conn = cmds.listConnections(obj)
                    if not conn:
                        empty.append(obj)
                    elif len(conn) == 1 and cmds.objectType(conn[0]) == 'displayLayer':
                        empty.append(obj)
                    elif len(conn) == 1 and cmds.objectType(conn[0]) == 'renderLayer':
                        empty.append(ebj)
    return empty
def mayascene_unusedExpressions():
    '''현재 씬의 쓰이지 않는 익스프레션 리스트를 반환한다.'''
    expressions = cmds.ls(type='expression')
    unused = []
    for e in expressions:
        if not cmds.listConnections(e+'.output', source=False, destination=True, skipConversionNodes=True):
            unused.append(e)
    return unused
def mayascene_unusedConstraints():
    '''현재 씬의 쓰이지 않는 컨스트레인을 반환한다.'''
    unused = []
    types = [
            "pointConstraint",
            "pointOnPolyConstraint",
            "aimConstraint",
            "orientConstraint",
            "parentConstraint",
            "scaleConstraint",
            "normalConstraint",
            "tangentConstraint",
            "geometryConstraint"
    ]
    for t in types:
        for c in cmds.ls(type=t):
            dests = cmds.listConnections(c, source=False, destination=True)
            if dests:
                # 목적지가 자기 자신인 경우는 사용하지 않는것으로 판단.
                outgoing=False
                for d in dests:
                    if d != c:
                        outgoing=True
                if not outgoing:
                    unused.append(c)
            else:
                unused.append(c)
    return unused

def mayarender_layerOverride(layer, attr):
    cmds.editRenderLayerAdjustment(attr, layer=layer)

def mayarender_removeLayerOverride(layer, attr):
    cmds.editRenderLayerAdjustment(attr, layer=layer, remove=True)


class mayarender_OutAsJpeg():
    def __init__(self):
        self.imgfmt='defaultRenderGlobals.imageFormat'
        self.outctrl='defaultRenderGlobals.outFormatControl'
    def __enter__(self):
        '''플레이블래스트 결과물이 jpeg로 나오도록 바꾼다.'''
        self.oldval = [cmds.getAttr(self.imgfmt), cmds.getAttr(self.outctrl)]
        cmds.setAttr(self.imgfmt, lock=False)
        cmds.setAttr(self.imgfmt, 8) # jpeg
        cmds.setAttr(self.outctrl, lock=False)
        cmds.setAttr(self.outctrl, 0) # as output format => jpeg
    def __exit__(self, type, value, traceback):
        '''플레이블래스트 결과물이 이전처럼 나오도록 다시 바꾼다.'''
        cmds.setAttr(self.imgfmt, self.oldval[0])
        cmds.setAttr(self.outctrl, self.oldval[1])

def mayaoption_save(name, val, arrayType=''):
    '''arrayType은 val로 리스트나 셑이 들어왔을때만 사용한다. string, int, float 중 하나를 선택한다.'''
    if not arrayType:
        if isinstance(val, basestring):
            cmds.optionVar(stringValue=(name, val))
        elif isinstance(val, int):
            cmds.optionVar(intValue=(name, val))
        elif isinstance(val, float):
            cmds.optionVar(floatValue=(name, val))
        else:
            if hasattr(val, '__iter__'):
                raise TypeError('''Please set type of the array.
ex) mayaoption_save('name', strList, arrayType='string')''')
            raise TypeError('do not support type {0} - {1}'.format(type(val), name))
    else:
        # 이미 정의된 어레이 옵션은 타입이 지정되어 있어 다른 타입으로 대입이 불가능 하다.
        # 그러므로 해당 옵션이 있다면 일단 지운다.
        mayaoption_delete(name)
        if arrayType == 'string':
            cmds.optionVar(stringValueAppend=[(name, v) for v in val])
        elif arrayType == 'int':
            cmds.optionVar(intValueAppend=[(name, v) for v in val])
        elif arrayType == 'float':
            cmds.optionVar(floatValueAppend=[(name, v) for v in val])
        else:
            raise TypeError('{0} is not a proper array type'.format(arrayType))

def mayaoption_load(name, failValue=None):
    if not cmds.optionVar(exists=name):
        return failValue
    val = cmds.optionVar(q=name)
    return val

def mayaoption_delete(name):
    try:
        cmds.optionVar(remove=name)
    except:
        pass
# generated by onepy : mayaviewport
# encoding=utf8


from maya import cmds

def mayaviewport_activeView():
    for pn in cmds.lsUI(editors=True):
        try:
            cmds.modelEditor(pn, q=True)
        except:
            continue
        if cmds.modelEditor(pn, q=1, av=1):
            return pn
    raise RuntimeError('not found active view')

def mayaviewport_appearance(view):
    '''Gets the display appearance of the model editor.
    Possible values are "wireframe", "points", "boundingBox", "smoothShaded", "flatShaded".'''
    return cmds.modelEditor(view, query=True, displayAppearance=True)

def mayaviewport_setAppearance(view, appearance):
    '''Sets the display appearance of the model editor.
    Possible values are "wireframe", "points", "boundingBox", "smoothShaded", "flatShaded".'''
    cmds.modelEditor(view, edit=True, displayAppearance=appearance)

class mayaviewport_TempAppearance:
    def __init__(self, viewports, appearance):
        self.viewports = viewports
        self.appearance = appearance
        self.old = {}
    def __enter__(self):
        for v in self.viewports:
            self.old[v] = mayaviewport_appearance(v)
            mayaviewport_setAppearance(v, self.appearance)
    def __exit__(self, type, value, traceback):
        for v in self.viewports:
            mayaviewport_setAppearance(v, self.old[v])

class mayaviewport_NewWindow:
    '''새 뷰포트 창을 띄우고 ui를 반환한다.
camera를 지정하지 않으면 현재 선택된 뷰포트의 카메라가 선택된다.
viewerOnly를 지정하면 버튼, 메뉴창을 제외한 순수한 뷰포트가 열린다.
with mayaviewport_NewWindow()를 사용하면 해당 블럭을 빠져나오면서 새 뷰포트 창이 꺼진다. 이는 플레이블래스트를 걸때 유용하다.
'''
    def __init__(self, name, width, height, camera=None, viewerOnly=False):
        if camera is None:
            camera = cmds.modelEditor(mayaviewport_activeView(), q=True, camera=True)

        with mayaui_New(cmds.window, name) as self.Window:
            with mayaui_New(cmds.paneLayout, 'MainLayout') as MainLayout:
                # 패널 생성. 이미 패널이 있다면 현재 윈도우로 가져온다.
                panelName = name+'Panel'
                if panelName not in cmds.getPanel(type='modelPanel'):
                    self.Panel = mayaui_New(cmds.modelPanel, panelName, camera=camera)
                else:
                    self.Panel = mayaui_Exist(cmds.modelPanel, panelName)
                    self.Panel.edit(parent=MainLayout.name, camera=camera)
                # 패널에는 항상 모델에디터가 함께있다. 이를 ui로 만든다.
                self.Viewer = mayaui_Exist(cmds.modelEditor, self.Panel.query(modelEditor=True))

        # 플레이플래스트를 걸기위해서 뷰포트를 띄울때는 정확한 사이즈를 위해 모델 에디터만 띄워야 한다.
        if viewerOnly:
            self.Panel.edit(unParent=True)
            self.Viewer.edit(parent=MainLayout.name)

        # 바로 해당 뷰어로 플레이블래스트를 거는 경우를 대비해 activeView를 설정한다.
        # 전에는 cmds.setFocus로 했었으나 잘 적용되지 않았다.
        self.Viewer.edit(activeView=True)

        self.Window.edit(width=width, height=height)
        cmds.showWindow(self.Window.name)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        cmds.deleteUI(self.Window.name, window=True)


class mayaviewport_NewPreviewWindow():
    def __init__(self, name, width, height, cam):
        self.name = name
        self.width = width
        self.height = height
        print cam
        if cam is None:
            self.cam = cmds.modelEditor(mayaviewport_activeView(), q=True, camera=True)
        else:
            self.cam = cam
        self.window = mayaui_New(cmds.window, self.name, width=self.width, height=self.height)
        form = cmds.formLayout()
        self.Editor = mayaui_New(cmds.modelEditor, name+'Editor', camera = self.cam, activeView=True)
        print self.Editor
        cmds.modelEditor(self.Editor.name, edit=True, allObjects=False, grid=False, polymeshes=True, nurbsSurfaces=True, subdivSurfaces=True, fluids=True, displayAppearance='smoothShaded', displayTextures=True)
        cmds.formLayout(
                        form, edit=True,
                        attachForm=[
                                    (self.Editor.name, 'top', 0),
                                    (self.Editor.name, 'bottom', 0),
                                    (self.Editor.name, 'left', 0),
                                    (self.Editor.name, 'right', 0),
                        ]
        )
        cmds.modelEditor(self.Editor.name, edit=True, activeView=True)
        cmds.showWindow(self.window.name)
    def __enter__(self):
        '''프리뷰 윈도우 생성'''
        return self
    def __exit__(self, type, value, traceback):
        '''프리뷰 윈도우 삭제'''
        cmds.deleteUI(self.window.name, window=True)

def mayaplayblast_oneshot(path, f, width, height):
    '''뷰포트로 한 프레임을 캡쳐한다.'''
    if not isinstance(f, int):
        cmds.error('f should a int.')
    root, ext = path.rsplit('.', 1)
    cmds.playblast(completeFilename=path, compression=ext, frame=f, w=width, h=height, format='image', percent=100, quality=100, clearCache=True, viewer=False)

# indexFromZero=True 가 옵션에 따라 설정을 해도 잘 되지 않는 경우가 있어 아직은 지원하지 않는다.
# 이와 같은 효과를 내려면 mayaplayblast_oneshot 으로 한장씩 걸면된다. (대신 번거롭고 속도가 조금 느려진다.)
def mayaplayblast_sequence(path, startf, endf, width, height):
    '''
        뷰포트 캡쳐 시퀀스를 생성한다.
        경로는 `root.%04d.ext` 또는 `root.####.ext` 형태여야 한다.
        여기서 04라는 숫자와 ####은 이 부분이 네자리 숫자로 대체 되어야 한다는 의미다.
    '''
    seq = False
    m = re.search('[.]%([\d][\d])d[.]', path)
    if m:
        digit = int(m.group(1))
        path = re.sub('[.]%[\d][\d]d[.]', '.', path)
        seq = True
    m = re.search('[.](#+)[.]', path)
    if m:
        digit = len(m.group(1))
        path = re.sub('[.]#+[.]', '.', path)
        seq = True
    if not seq:
        raise ValueError('invalid path form. ex)`root.%04d.ext` or `root.####.ext`')
    root, ext = path.rsplit('.', 1)
    cmds.playblast(
        filename=root, compression=ext,
        startTime=startf, endTime=endf, framePadding=digit,
        width=864, height=486,
        forceOverwrite=True, indexFromZero=False,
        format='image', percent=100, quality=100, clearCache=True, viewer=False
    )
    print root
    print ext
    print startf
    print endf
    print digit
    print width
    print height

# generated by onepy : mayadeadline
#coding=utf8

def mayadeadline_groups():
    '''데드라인에 설정된 그룹 리스트를 질의하여 반환한다.'''
    try:
        p = subprocess.Popen(['deadlinecommand', '-groups'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except:
        raise RuntimeError(u'Deadline is not installed.')

    stdout, stderr = p.communicate()
    if stderr:
        raise RuntimeError(stderr)

    grps = [s.rstrip('\r\n') for s in stdout.splitlines()]
    return grps


def mayadeadline_jobSubmit(opts):
    '''현재 씬을 렌더팜에 던진다.
    씬 정보를 이용해 설정파일들을 만든 후 커맨드라인을 이용해 실행시킨다.
    '''
    smgpath_make(opts['outpath'])

    # 스크립트 옵션 추가
    opts['suspendedscripts'] = ""
    opts['usinglayerscripts'] = ''
    opts['layerscripts'] = ''

    # 스크립트 옵션 채워넣기
    if opts['suspended']:
        opts['suspendedscripts'] = "InitialStatus=Suspended"

    if opts['usinglayer']:
        if not mayascene_enabledRenderLayers():
            cmds.confirmDialog(title=u'알림', message=u'켜져 있는 레이어가 없습니다.', button=[u'확인'])
            return

        oldLayer = mayascene_currentRenderLayer()
        for l in mayascene_enabledRenderLayers():
            mayascene_setCurrentRenderLayer(l)
            l_opts = opts.copy()
            l_opts['renderer']=mayascene_renderer()

            oa = mayadeadline_overriddenAttributes(l)

            # 프레임 유효성 체크 및 오버라이드 준비.
            frames = opts['frames']
            framestep = '1'
            for x in ['x', 'step', 'by', 'every']:
                if x in opts['frames']:
                    frames, framestep = frames.split(x)
                    break
            if '-' in frames:
                startframe, endframe = frames.split('-')
            else:
                startframe = frames
                endframe = frames
            if (startframe == endframe) and framestep != '1':
                raise ValueError('{optFrames} is not valid'.format(opts['frames']))

            if 'defaultRenderGlobals.startFrame' in oa:
                startframe=str(int(cmds.getAttr('defaultRenderGlobals.startFrame')))
            if 'defaultRenderGlobals.endFrame' in oa:
                endframe=str(int(cmds.getAttr('defaultRenderGlobals.endFrame')))
            if 'defaultRenderGlobals.byFrameStep' in oa:
                framestep=str(int(cmds.getAttr('defaultRenderGlobals.byFrameStep')))

            l_opts['frames']='{startframe}-{endframe}x{framestep}'.format(startframe=startframe, endframe=endframe, framestep=framestep)
            l_opts['jobname']=opts['jobname']+'_'+l
            l_opts['usinglayerscripts'] = 'UsingRenderLayers=1'
            l_opts['layerscripts'] = 'RenderLayer='+l
            if l in opts['layergroup']:
                l_opts['group'] = opts['layergroup'][l]
            mayadeadline_runJob(l_opts)
        mayascene_setCurrentRenderLayer(oldLayer)
    else:
        mayadeadline_runJob(opts)

def mayadeadline_runJob(opts):
    '''받아들인 옵션 값을 가지고 deadlinecommand를 실행한다.'''
    # 스크립트 템플릿
    # (필요한 인수에 대해서는 ref/SubmitMayaToDeadline.mel을 참조)
    job_script = u'''
            Plugin=MayaCmd
            Name={name}
            Comment={comment}
            Frames={frames}
            ChunkSize={chunksize}
            Priority={priority}
            OutputDirectory0={outpath}
            Department={department}
            MachineLimit={machinelimit}
            Group={group}
            {suspended}
    '''
    plugin_script = u'''
            Renderer={renderer}
            SceneFile={scene}
            Camera={camera}
            ProjectPath={prjpath}
            {usinglayer}
            {layer}
            OutputFilePath={outpath}
            Version={version}
    '''

    job_script = job_script.format(name=opts['jobname'], comment=opts['comment'], frames=opts['frames'], chunksize=opts['chunksize'], priority=opts['priority'], outpath=opts['outpath'], department=opts['department'], machinelimit=opts['machinelimit'], group=opts['group'], suspended=opts['suspendedscripts'])
    plugin_script = plugin_script.format(renderer=opts['renderer'], scene=opts['scene'], camera=opts['camera'], prjpath=opts['prjpath'], outpath=opts['outpath'], usinglayer=opts['usinglayerscripts'], layer=opts['layerscripts'], version=opts['version'])

    # 잡 서브밋에 쓸 임시 설정 파일 생성
    userDir = os.path.expanduser("~")
    jobfile = userDir + "/" + opts['jobname']+'_job.ini'
    pluginfile = userDir + "/" + opts['jobname']+'_plugin.ini'

    with open(jobfile, 'w') as f:
        f.write(job_script)
    with open(pluginfile, 'w') as f:
        f.write(plugin_script)

    # 서브밋
    commands = ['deadlinecommand', jobfile, pluginfile]
    try:
        process = subprocess.Popen(commands, stdout=subprocess.PIPE , stderr=subprocess.PIPE)
    except:
        print(u'deadline이 깔려있지 않습니다.')
    else:
        stdout, stderr = process.communicate()
        print(stdout)
        print(stderr)

    os.remove(jobfile)
    os.remove(pluginfile)


def mayadeadline_overriddenAttributes(rLayer):
    '''현재 레이어에서 오버라이드 된 어트리뷰트와 그 값이 넘어가지만 값은 몇가지 문제가 있기 때문에 잘 이해하고 써야 한다.
    예) 프레임레인지가 제대로 들어오지 않고(초로 들어옴). 옵션 변경후 레이어를 옮겨야 변경된 값을 제대로 체크 한다.'''
    layerOverriddens = cmds.listConnections(rLayer + '.adjustments', p=True, c=True)
    if not layerOverriddens:
        return {}
    oa = {}
    for i in range(0, len(layerOverriddens), 2):
        conn = layerOverriddens[i]  # returns '{rLayer}.adjustments[#].plug'
        attr = layerOverriddens[i+1]
        idx = conn.split(']')[0]
        idx = idx.split('[')[-1]
        value = cmds.getAttr(rLayer + '.adjustments[{idx}].value'.format(idx=idx))
        # 레이어를 옮겼다 다시 돌아오지 않으면 값이 제대로 체크되지 않는 문제 수정해야 함.
        oa[attr] = value
    return oa

def mayaui_New(func, *args, **kwargs):
    '''새로운 위젯을 생성하고 해당 mayaui_UI를 반환한다.'''
    if func is cmds.window:
        if args and cmds.window(args[0], ex=1):
            cmds.deleteUI(args[0], wnd=1)
    name = func(*args, **kwargs)
    return mayaui_UI(func, name)

def mayaui_Exist(func, name):
    '''현재 존재하는 위젯으로부터 mayaui_UI를 생성해 반환한다.'''
    return mayaui_UI(func, name)

class mayaui_UI:
    '''마야의 ui 래퍼 클래스.
with 문법을 이용해 해당 ui를 부모로 만들수 있다. ui가 레이아웃이 아닌 경우는 에러가 발생한다.
'''
    def __init__(self, func, name):
        self.func = func
        self.name = name

    def command(self, *args, **kwargs):
        self.func(self.name, *args, **kwargs)

    def edit(self, *args, **kwargs):
        self.func(self.name, edit=True, *args, **kwargs)

    def query(self, *args, **kwargs):
        return self.func(self.name, query=True, *args, **kwargs)

    def __enter__(self):
        cmds.setParent(self.name)
        return self

    def __exit__(self, type, value, traceback):
        if '|' in self.name:
            cmds.setParent(self.name.rsplit('|', 1)[0])
            return
        cmds.setParent(self.name)

# 환경변수
# 1.0.1 -->
START_FRAME = 101
extraFrames = 50
mayaBinPath = mel.eval('getenv MAYA_LOCATION')+'/bin/'
# 1.0.1 <--
# WMS_HOST의 값은 postit 스크립트에 의해서 자동 변경되므로, 들여쓰면 안된다.

# 내부 접속 외부 접속 구별 해서 WMS_HOST 설정
import socket, urllib, re
lan = socket.gethostbyname(socket.gethostname())
wan = re.search(re.compile(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'),urllib.urlopen('http://checkip.dyndns.org').read()).group()
'''
if wan == '1.220.37.251':
    WMS_HOST = '192.168.0.185'
else:
    WMS_HOST = '112.217.174.10'
#WMS_HOST = "192.168.0.185" # Synergy NEW
#WMS_HOST = "192.168.0.130" # Synergy
#WMS_HOST = "175.197.68.192:7806"# 밤하늘
#WMS_HOST = "121.167.145.193:7806"# Pingo
'''
WMS_HOST = "112.217.174.10"# 통합
print WMS_HOST

if DEV:
    print(u'---  개발서버입니다.  ---')
    WMS_HOST = '192.168.56.138'

RENDER_DRIVE = ''
if sys.platform == 'win32':
    WMS_DRIVE = cmds.optionVar(q='WMS_DRIVE_WINDOWS')
    if not WMS_DRIVE:
        if os.path.isdir('D:'):
            WMS_DRIVE = 'D:'
        else:
            WMS_DRIVE = 'C:'
    RENDER_DRIVE = 'R:'
    cmds.optionVar(sv=('WMS_DRIVE_WINDOWS', WMS_DRIVE))
else:
    WMS_DRIVE = cmds.optionVar(q='WMS_DRIVE_LINUX')
    if not WMS_DRIVE:
        WMS_DRIVE = '/mnt/D'
    RENDER_DRIVE = '/mnt/R'
    cmds.optionVar(sv=('WMS_DRIVE_LINUX', WMS_DRIVE))

# 루트
LOCAL_ROOT = WMS_DRIVE + '/wms/pipeline'

print(u'작업관리기의 로컬 경로가 "' + LOCAL_ROOT + u'"로 설정되었습니다.')

UTIL_DIR = LOCAL_ROOT + '/utilities'
HTTP_ROOT = 'http://' + WMS_HOST + '/'
HTTP_FILE_ROOT = 'http://' + WMS_HOST + '/files/'
WMS_PIPELINE_ROOT = '/var/www/files/wms/app/pipeline'
WMS_FILE_ROOT = '/var/www/files/wms'

CONVERT = "convert"
CURL = "curl"
FFMPEG = "ffmpeg"
if sys.platform == "win32":
    CONVERT = UTIL_DIR + "/convert.exe"
    CURL = UTIL_DIR + "/curl.exe"
    FFMPEG = UTIL_DIR + "/ffmpeg.exe"
    WGET = UTIL_DIR + "/wget.exe"

# 리눅스, 윈도우 경로 호환
cmds.dirmap(en=True)
if sys.platform == 'win32':
    if os.path.isdir('D:'):
        cmds.dirmap(m=('/mnt/D', 'D:'))
        cmds.dirmap(m=('c:', 'D:'))
        cmds.dirmap(m=('C:', 'D:'))
    elif os.path.isdir('C:'):
        cmds.dirmap(m=('/mnt/D', 'C:'))
        cmds.dirmap(m=('d:', 'C:'))
        cmds.dirmap(m=('D:', 'C:'))
    for x in 'EFGHIJKLMNOPQRSTUVWXYZ':
        cmds.dirmap(m=('/mnt/'+x, x+':'))
elif sys.platform == 'linux2':
    cmds.dirmap(m=('c:', '/mnt/D'))
    cmds.dirmap(m=('C:', '/mnt/D'))
    cmds.dirmap(m=('d:', '/mnt/D'))
    cmds.dirmap(m=('D:', '/mnt/D'))
    for x in 'EFGHIJKLMNOPQRSTUVWXYZ':
        cmds.dirmap(m=(x+':', '/mnt/'+x))

# 중요 클래스 선언
class Work:
    '''
    작업관리기에서 관리하는 작업 정보
    주로 서버에 대한 질의(queryWorks)를 통해 생성되나,
    필요에 따라 임의로 만들기도 한다.
    '''
    # 할일: 너무 많은 정보가 담긴다. 정리할수 없을까?
    def __init__(self, hostip, prjid, name, process, progress='', worker='', workerID='', started='', updated='', duedate='', assetType='', thumbnail='', requestProcess='', locked=False, lockerAccount='', lockerName='', classLevel='', option=None):
        if not hostip:
            hostip = WMS_HOST
        self.hostip = hostip

        if option is None:
            option = {}
        self.name = name
        self.wid= process+'__'+name
        self.prjid = prjid
        _, self.prj, self.prjtype = prjid.split('__')
        if self.prjtype == 'shot':
            si = name.rfind('S')
            ci = name.rfind('C')
            self.episode = name[:si]
            self.scene = name[si:ci]
            self.shot = name[ci:]
        elif self.prjtype == 'asset':
            self.episode = ''
            self.scene = ''
            self.shot = ''
        else:
            raise KeyError('unknown project type.')
        self.process = process
        self.progress = progress
        self.worker = worker
        self.workerID = workerID
        self.path = '{localroot}/work/{prj}/{prjtype}/{process}/{workname}/{workname}'.format\
                (localroot=LOCAL_ROOT, prj=self.prj, prjtype=self.prjtype, process=process, workname=name)
        self.dir = os.path.dirname(self.path)
        self.attachdir = self.dir + '/attach'
        self.mb = self.path+'.mb'
        self.xml = self.path+'.xml'
        self.started = started
        self.updated = updated
        self.duedate = duedate
        self.assetType = assetType
        self.thumbnail = thumbnail
        self.requestProcess = requestProcess
        self.locked = locked
        self.lockerAccount = lockerAccount
        self.lockerName = lockerName
        self.classLevel = classLevel
        self.option = option
    def __repr__(self):
        return self.wid

class NamePair:
    '''NamePair는 영문 아이디와 한글명을 짝지어준다.'''
    def __init__(self, pairs):
        self.ids = []
        self.labels = []
        for k, v in pairs:
            self.ids.append(k)
            self.labels.append(v)
    def __iter__(self):
        for k, v in zip(self.ids, self.labels):
            yield k, v
    def append(self, pair):
        '''한 쌍을 추가한다.'''
        k, v = pair
        self.ids.append(k)
        self.labels.append(v)
    def id(self, v):
        '''Pair의 label을 받아 id를 돌려준다.'''
        return self.ids[self.labels.index(v)]
    def label(self, k):
        '''Pair의 id를 받아 label을 돌려준다.'''
        return self.labels[self.ids.index(k)]


# 글로벌 변수 선언

# 현재 서버에 존재하는 각 프로젝트에 대한 프로세스 정보.
# 프로젝트 별로 다르기 때문에 queryProjectInfo()에 의해 채워진다.
#
# 예) ProjectInfo["192.168.0.130"]["pipeline__t_burster__asset"] => ("wms-synergy-1", "티버스터", "에셋")
ProjectInfo = {}

# 각 프로젝트의 공정 리스트.
# 프로젝트 별로 다르기 때문에 queryProjectInfo()에 의해 채워진다.
#
# 예) ProcessOf["192.168.0.130"]["pipeline__t_burster__asset"] => NamePair([("design", "디자인"), ...])
ProcessOf = {}

# 작업 상태는 프로젝트와 상관없이 공통이다.
Progress = NamePair([
    ('', u'없음'),
    ('assigned', u'대기'),
    ('progressing', u'진행'),
    ('finished', u'완료'),
    ('approved', u'승인'),
    ('modifying', u'수정'),
    ('request', u'요청'),
    ('fixed', u'고쳐짐'),
    ('replaced', u'대체'),
    ('inactivated', u'비활성'),
])

# 에셋 타입은 프로젝트와 상관없이 공통이다.
AssetType = NamePair([
    ('CH', u'캐릭터'),
    ('BG', u'배경'),
    ('PR', u'프랍'),
    ('Mecha', u'메카닉'),
    ('2D', u'2D이펙트'),
])

WMS_ACCOUNT = ''

# 메인 윈도우
class UI:
    '''UI는 메인 WMS 윈도우다. 이 파일을 실행시켰을때 처음에 실행되는 코드이다.'''
    def __init__(self):
        self.loginAccount = ""
        self.loginName = ''
        self.loginTeam = ""
        self.loginPosition = ""

        # ui 이름별로 각각의 옵션을 저장하기 위한 변수
        # 마야가 각 ui 항목에 담을수 있는 데이터가 너무 제한적이라 돌아가는 방법으로 이용
        self.uiData = {}

        self.myWorks = {}
        self.teamWorks = {}
        self.searchWorks = {}

        self.newWindow()

    ######## UI 생성 ########
    def newWindow(self):
        '''작업관리창을 띄운다.'''
        self.Window = mayaui_New(
            cmds.window, 'wmsMainWindow', title=u' WMS for Maya ' + VERSION ,
            width=462, height=600,
            menuBar=True,
        )
        cmds.window('wmsMainWindow', e=True, width=520, height=600)
        cmds.showWindow()

        with self.Window:
            self.addMenu()
            self.addMainLayout()
            self.addLoginLayout()

        # 자동 로그인
        rootEl = self.loadSession()
        if rootEl.find('success'):
            self.login(rootEl)

    def addMenu(self):
        '''메인메뉴. 로그인을 하기전까진 숨겨져 있다.'''
        self.MainMenu = mayaui_New(cmds.menu, 'MyMenu', l='', enable=False)
        cmds.menuItem(l=u'설정', command=self.setEnvWindowEv)
        cmds.menuItem(l=u'LOD 적용', command=self.applyLodEv)
        cmds.menuItem(l=u'리깅 제거', command=self.cleanRigEv)
        cmds.menuItem(l=u'레퍼런스 업데이트', command=self.referenceUpdateEv)
        cmds.menuItem(l=u'쉐이더 업데이트', command=self.updateShadersEv)
        cmds.menuItem(l=u'헤어 업데이트', command=self.updateHairsEv)
        cmds.menuItem(l=u'스테레오스코픽 툴', command=self.stereoscopicToolEv)
        cmds.menuItem(l=u'레퍼런스 병합', command=self.mergeReferencesEv)
        cmds.menuItem(l=u'텍스쳐 퀄리티 전환', command=self.changeTextureQualityEv)
        cmds.menuItem(l=u'에셋 퀄리티 전환', command=self.changeSelectedAssetQualityEv)
        cmds.menuItem(l=u'ABC 생성', command=self.bakeAbcEv)
        #cmds.menuItem(l=u'렌더 프록시 생성', command=self.createRenderProxyEv)
        cmds.menuItem(l=u'플래이블래스트', command=self.previewSceneEv)
        cmds.menuItem(optionBox=True, command=self.previewPrefWindowEv)
        cmds.menuItem(l=u'현재 씬 렌더', command=self.renderSceneEv)
        cmds.menuItem(divider=True)
        cmds.menuItem(l=u'로그아웃', ann=u'로그아웃을 합니다.', c=self.logoutEv)

    def addLoginLayout(self):
        '''로그인레이아웃. 로그인을 하고나면 숨겨지고, 로그아웃을 하면 다시 보이게 된다.'''
        self.LoginLayout = mayaui_New(cmds.columnLayout, 'LoginLayout', adj=1, cal='center', rs=200)
        with self.LoginLayout:
            cmds.text(font='fixedWidthFont', l=u'\n[ WMS 로그인 ]')
            with mayaui_New(cmds.columnLayout, adj=1,columnAlign='center'):
                with mayaui_New(cmds.rowLayout, nc=2, cw2=[140, 150], ct2=['right', 'both']):
                    cmds.text(font='fixedWidthFont', l=u'아이디 ')
                    cmds.textField('LoginAccount', font='fixedWidthFont', text=mayaoption_load('WMS_PreviousAccount', ''))
                with mayaui_New(cmds.rowLayout, nc=3, cw3=[140, 9, 141], ct3=['right', 'left', 'both']):
                    cmds.text(font='fixedWidthFont', l=u'암호 ')
                    cmds.textField(
                        'LoginPassword', font='fixedWidthFont', text=u'',
                        enterCommand=self.manualLoginEv, alwaysInvokeEnterCommandOnReturn=True
                    )
                    cmds.text('')
                with mayaui_New(cmds.rowLayout, nc=2, cw2=[140, 150], ct2=['right', 'both']):
                    cmds.text(l=u'')
                    cmds.button(l=u'Login', c=self.manualLoginEv)
                cmds.text(l=u'')
                cmds.text('LoginMessage', font='fixedWidthFont', l=u'[ 아이디와 암호를 입력하세요 ]')

    def addMainLayout(self):
        '''메인레이아웃. 로그인을 하면 보여지게 된다. 로그아웃을 하면 다시 숨겨진다.'''
        self.MainLayout = mayaui_New(cmds.formLayout, 'MainLayout', visible=False)
        with self.MainLayout:
            self.addProjectLayout()
            self.addTabLayout()
        self.MainLayout.edit(
                attachPosition = [
                    (self.ProjectLayout.name, 'top', 0, 0),
                    (self.ProjectLayout.name, 'left', 0, 0), (self.ProjectLayout.name, 'right', 0, 100),
                    (self.ProjectLayout.name, 'bottom', -33, 0),
                    (self.TabLayout.name, 'top', 33, 0),
                    (self.TabLayout.name, 'left', 0, 0), (self.TabLayout.name, 'right', 0, 100),
                    (self.TabLayout.name, 'bottom', 0, 100),
                ]
        )

    def addProjectLayout(self):
        self.ProjectLayout = mayaui_New(cmds.rowLayout, 'ProjectLayout', height=30, nc=5, adj=3)
        with self.ProjectLayout:
            cmds.text(l=u'        프로젝트명 ')
            self.ProjectMenu = mayaui_New(cmds.optionMenu, 'ProjectMenu')
            self.ProjectMenu.edit(changeCommand=self.projectChanged)
            cmds.text(l='')

            # 할일: 네임스페이스 옵션은 이제 레퍼런스 옵션 창으로 옮겨야 한다.
            cmds.text(l=u'네임스페이스')
            nsmenu = mayaui_New(cmds.optionMenu, 'WMS_ImportNamespaceMenu', enable=False)
            cmds.menuItem('AsIs', l=u'파일이름')
            '''
            cmds.menuItem('R', l='R#')
            cmds.menuItem('B', l='B#')# 1.0.1
            try:
                val = mayaoption_load('WMS_ImportNamespaceType', 'R')
                idx = nsmenu.query(itemListShort=True).index(val)+1
            except ValueError:
                pass
            else:
                nsmenu.edit(select=idx)
            def ImportNamespaceChangedEv(*_):
                val = nsmenu.query(itemListShort=True)[nsmenu.query(select=True)-1]
                mayaoption_save('WMS_ImportNamespaceType', val)
            nsmenu.edit(changeCommand=ImportNamespaceChangedEv)
            '''

    def addTabLayout(self):
        # 각 탭마다 메뉴바의 옵션 메뉴를 생성할 때 사용
        def newMenus(menus):
            menudict = {}
            for name, label, width, items in menus:
                M = mayaui_New(cmds.optionMenu, name, label=' '+label, width=width)
                M.edit(changeCommand=partial(menuChanged, M))
                for i in items:
                    cmds.menuItem(i)
                try:
                    M.edit(value=mayaoption_load(M.name, ''))
                except RuntimeError:
                    pass
                menudict[name] = M
            return menudict

        # 각 옵션 메뉴가 변경되었을때 다시 서버에 쿼리후 테이블 다시 그리기
        def menuChanged(ui, _):
            mayaoption_save(ui.name, ui.query(value=True))
            if self.Table != self.SearchTable:
                workdic = self.query()
                self.refreshTable(workdic.values())

        # 각 탭에 테이블 생성
        def newTable(name, columns):
            '''탭에 테이블을 생성한다.'''
            labels = []
            widths = []
            for l, w in columns:
                labels.append(l)
                widths.append(w)

            table = mayaui_New(
                cmds.scriptTable, name,
                rows=0, editable=False, selectionBehavior=1,
                columns=len(columns),
                label=list(enumerate(labels, 1)),
                columnWidth=list(enumerate(widths, 1)),
                cellChangedCmd=self.editCell, cellBackgroundColorCommand=self.cellColor
            )
            table.popup = cmds.popupMenu(name + 'Popup', pmc=self.openPopupEv)
            return table

        # 탭은 메뉴바와 테이블로 이루어진 탭레이아웃을 만든다.
        self.TabLayout = mayaui_New(cmds.tabLayout, 'TabLayout', childResizable=True, changeCommand=self.tabChanged, width=445)
        with self.TabLayout:
            # 각 메뉴바에 들어갈 메뉴 이름들
            sortLabels = [u'작업이름', u'공정', u'상태', u'작업자', u'시작', u'업데이트', u'일정', u'중요', u'잠김']
            progressLabels = [u'모두'] + Progress.labels
            assetTypeLabels = [u'모두'] + AssetType.labels

            # 테이블 컬럼 이름 및 너비
            columns = [
                (u'중요', 30),
                (u'작업이름', 90),
                (u'공정', 84),
                (u'상태(다음)', 70),
                (u'작업자', 60),
                (u'업데이트', 60),
                (u'일정', 60),
                (u'잠김', 30)
            ]

            # 내작업 탭 생성
            self.MyWorkTab = mayaui_New(cmds.formLayout, 'MyWorkTab')
            with self.MyWorkTab:
                # 내작업 메뉴 생성
                self.MyWorkBar = mayaui_New(cmds.rowLayout, 'MyWorkBar', nc=5)
                with self.MyWorkBar:
                    self.MyWorkMenus = newMenus([
                        ('Progress', u'상태', 120, progressLabels),
                        ('AssetType', u'타입', 120, assetTypeLabels),
                        ('Episode', u'에피소드', 120, [u'모두']), # self.refreshBar()
                        ('Sort', u'정렬', 120, sortLabels),
                    ])
                    self.MyWorkBar.RefreshButton = mayaui_New(cmds.button, l=u'새로고침', command=self.tabChanged)
                # 내작업 테이블 생성
                self.MyWorkTable = newTable('MyWorkTable', columns)
            # 내작업 탭 정렬
            self.MyWorkTab.edit(attachPosition=[
                (self.MyWorkBar.name, 'top', 0, 0),
                (self.MyWorkBar.name, 'left', 0, 0), (self.MyWorkBar.name, 'right', 0, 100),
                (self.MyWorkBar.name, 'bottom', -30, 0),
                (self.MyWorkTable.name, 'top', 30, 0),
                (self.MyWorkTable.name, 'left', 0, 0), (self.MyWorkTable.name, 'right', 0, 100),
                (self.MyWorkTable.name, 'bottom', 0, 100),
            ])

            # 팀 작업탭 생성
            self.TeamWorkTab = mayaui_New(cmds.formLayout, 'TeamWorkTab')
            with self.TeamWorkTab:
                # 팀 작업 메뉴 생성
                self.TeamWorkBar = mayaui_New(cmds.rowLayout, 'TeamWorkBar', nc=5)
                with self.TeamWorkBar:
                    self.TeamWorkMenus = newMenus([
                        ('Progress', u'상태', 120, progressLabels),
                        ('AssetType', u'타입', 120, assetTypeLabels),
                        ('Episode', u'에피소드', 120, [u'모두']), # self.refreshBar()
                        ('Sort', u'정렬', 120, sortLabels),
                    ])
                    self.TeamWorkBar.RefreshButton = mayaui_New(cmds.button, l=u'새로고침', command=self.tabChanged)
                # 팀작업 테이블 생성
                self.TeamWorkTable = newTable('TeamWorkTable', columns)
            # 팀작업탭 정렬
            self.TeamWorkTab.edit(
                    attachPosition=[
                        (self.TeamWorkBar.name, 'top', 0, 0),
                        (self.TeamWorkBar.name, 'left', 0, 0), (self.TeamWorkBar.name, 'right', 0, 100),
                        (self.TeamWorkBar.name, 'bottom', -30, 0),
                        (self.TeamWorkTable.name, 'top', 30, 0),
                        (self.TeamWorkTable.name, 'left', 0, 0), (self.TeamWorkTable.name, 'right', 0, 100),
                        (self.TeamWorkTable.name, 'bottom', 0, 100),
                    ]
            )

            # 검색탭 생성
            self.SearchTab = mayaui_New(cmds.formLayout, 'SearchTab')
            with self.SearchTab:
                # 검색 메뉴 생성
                # 검색탭은 메뉴가 많아 메뉴바가 두줄로 나뉘었다.
                self.SearchBar = mayaui_New(cmds.rowLayout, 'SearchBar', nc=4)
                with self.SearchBar:
                    self.SearchMenus = newMenus([
                        ('Progress', u'상태', 110, progressLabels),
                        ('Process', u'공정', 110, [u'모두']), # self.refreshBar()
                        ('AssetType', u'타입', 110, assetTypeLabels),
                        ('Sort', u'정렬', 100, sortLabels),
                    ])
                SearchBar2 = mayaui_New(cmds.rowLayout, nc=3)
                with SearchBar2:
                    self.SearchTargetOM = mayaui_New(cmds.optionMenu, 'SearchTarget', l=u' 검색')
                    self.SearchTargetOM.edit(changeCommand=partial(menuChanged, self.SearchTargetOM))
                    self.searchTarget = NamePair([
                        ('work', u'작업이름'),
                        ('name', u'작업자'),
                    ])
                    for id, l in self.searchTarget:
                        cmds.menuItem(id, l=l)
                    self.SearchTF = mayaui_New(cmds.textField,'SearchText', w=150, enterCommand=self.searchEv, aie=True)
                    cmds.button(l=u'검색', c=self.searchEv, width=50)
                # 검색 테이블 생성
                self.SearchTable = newTable('SearchTable', columns)
            # 검색 탭 정렬
            self.SearchTab.edit(
                attachPosition=[
                    (self.SearchBar.name, 'top', 0, 0),
                    (self.SearchBar.name, 'left', 0, 0), (self.SearchBar.name, 'right', 0, 100),
                    (self.SearchBar.name, 'bottom', -30, 0),
                    (SearchBar2.name, 'top', 28, 0),
                    (SearchBar2.name, 'left', 0, 0), (SearchBar2.name, 'right', 0, 100),
                    (SearchBar2.name, 'bottom', -48, 0),
                    (self.SearchTable.name, 'top', 58, 0),
                    (self.SearchTable.name, 'left', 0, 0), (self.SearchTable.name, 'right', 0, 100),
                    (self.SearchTable.name, 'bottom', 0, 100),
                ]
            )

        # 탭 레이아웃 정렬
        self.TabLayout.edit(
            tabLabel=(
                (self.MyWorkTab.name, u'내 작업'),
                (self.TeamWorkTab.name, u'팀 작업'),
                (self.SearchTab.name, u'검색')
            )
        )


    ######## UI 다시 그리기 ########
    def tabChanged(self, *_):
        '''탭이 변경되면 해당 탭의 마지막 프로젝트를 부른 후 하위 ui를 다시 그린다.'''
        idx = self.TabLayout.query(selectTabIndex=True) - 1
        mayaoption_save('WMS_TABINDEX', idx)
        self.Tab = [self.MyWorkTab, self.TeamWorkTab, self.SearchTab][idx]
        self.Table = [self.MyWorkTable, self.TeamWorkTable, self.SearchTable][idx]
        self.Bar = [self.MyWorkBar, self.TeamWorkBar, self.SearchBar][idx]
        self.Menus = [self.MyWorkMenus, self.TeamWorkMenus, self.SearchMenus][idx]
        try:
            self.ProjectMenu.edit(value=mayaoption_load(self.Tab.name, ''))
        except RuntimeError:
            pass
        self.projectChanged(None)

    def projectChanged(self, _):
        '''
        프로젝트가 변경되면 현재 탭의 하위 ui를 다시 그린다.
        프로젝트 메뉴는 ui 위치로는 그렇지 않지만
        논리적으로는 탭의 하위 메뉴이다.
        '''
        # 프로젝트 메뉴에서 선택된 ui의 이름을 찾아
        # uiData에 저장되어있는 해당 메뉴의 정보를 가지고 온다.
        idx = self.ProjectMenu.query(select=True) - 1
        uiName = self.ProjectMenu.query(itemListLong=True)[idx]

        # 프로젝트 정보 기억.
        self.hostip, self.prjid = self.uiData[uiName]
        _, self.prj, self.prjtype = self.prjid.split('__')

        # 혹시 탭이 변경되었다가 다시 이 탭으로 왔을때
        # 현재 프로젝트로 변경키기 위해 프로젝트 이름 저장.
        uniqProjectID = self.ProjectMenu.query(value=True)
        mayaoption_save(self.Tab.name, uniqProjectID)

        # 마야의 셑프로젝트 실행
        prjdir = LOCAL_ROOT+'/work/'+self.prj
        smgpath_make(prjdir)

        rWs = "http://"+self.hostip+'/files/wms/etc/workspace.mel'
        try:
            resp = urllib2.urlopen(rWs)
            with open(prjdir+'/workspace.mel', 'wb') as fd:
                buf = resp.read(8192)
                while buf:
                    fd.write(buf)
                    buf = resp.read(8192)
            fd.close()
        except: pass

        mel.eval('setProject "{0}"'.format(prjdir))

        # 작업 검색 및 하위 항목 다시 그리기
        if self.Tab is not self.SearchTab:
            workdic = self.query()
            self.refreshBar(workdic.values())
            self.refreshTable(workdic.values())
        else:
            # 검색탭의 경우, 탭으로 넘어가고 바로 검색을 하는것이 아니라,
            # 작업자가 검색어나 검색 옵션을 고른후 검색 버튼을 눌렀을때만 검색이 된다.
            self.refreshBar(self.works())

    def refreshBar(self, works):
        '''
        테이블 위에 있는 메뉴바를 재정렬한다.
        마야의 UI가 그리 유연하지는 않아서 약간의 트윅이 포함되어있다.
        '''
        def reorderMenus(*names):
            '''
            모든 메뉴의 페어런트를 해제하고 숨긴 후 names로 들어온 메뉴들만 다시 등록한다.
            만약 현재 메뉴바에 새로고침 버튼이 있다면 마지막에 등록 한다.
            '''
            # Maya2017 Patch -->
            for m in self.Menus.values():
                m.edit(parent='MainLayout', visible=False)
            for n in names:
                m = self.Menus[n]
                m.edit(parent=self.Bar.name, visible=True)
            try:
                self.Bar.RefreshButton.edit(parent='MainLayout')
                self.Bar.RefreshButton.edit(parent=self.Bar.name)
            except AttributeError:
                pass
            # Maya2017 Patch <--
        def refreshMenuItems(menu, items):
            '''메뉴의 이전 아이템들을 받아들인 아이템들로 교체한다.'''
            olditems = menu.query(itemListLong=True)
            if olditems:
                for i in olditems:
                    cmds.deleteUI(i)
            for i in items:
                cmds.menuItem(i, parent=menu.name)
            try:
                menu.edit(value=mayaoption_load(menu.name, u'모두'))
            except RuntimeError:
                pass

        if self.Tab in [self.MyWorkTab, self.TeamWorkTab]:
            if self.prjtype == 'asset':
                reorderMenus('Progress', 'AssetType', 'Sort')
            else:
                reorderMenus('Progress', 'Episode', 'Sort')
                episodes = sorted(set(w.episode for w in works))
                refreshMenuItems(self.Menus['Episode'], [u'모두'] + episodes)
        if self.Tab == self.SearchTab:
            if self.prjtype == 'asset':
                reorderMenus('Progress', 'Process', 'AssetType', 'Sort')
            else:
                reorderMenus('Progress', 'Process', 'Sort')
            refreshMenuItems(self.Menus['Process'], [u'모두'] + ProcessOf[self.hostip][self.prjid].labels)

    def refreshTable(self, works):
        '''테이블을 다시 그린다.'''
        works = self.filterWorks(works)
        works = self.sortWorks(works)
        self.Table.edit(rows=0)
        for w in works:
            r = self.Table.query(rows=True)
            self.Table.edit(insertRow=r)
            self.setRow(r, w)

    def setRow(self, r, w):
        '''테이블의 r번째 열의 값을, 받아들인 작업의 정보로 수정한다.'''
        pgLabel = Progress.label(w.progress)
        if 'next_process_progress' in w.option:
            pgLabel += u'({0})'.format(Progress.label(w.option['next_process_progress']))
        lockstr = ('', '*')[w.locked]
        self.Table.edit(cellIndex=(r, 1), cellValue=w.classLevel)
        self.Table.edit(cellIndex=(r, 2), cellValue=w.name)
        self.Table.edit(cellIndex=(r, 3), cellValue=ProcessOf[self.hostip][self.prjid].label(w.process))
        self.Table.edit(cellIndex=(r, 4), cellValue=pgLabel)
        self.Table.edit(cellIndex=(r, 5), cellValue=w.worker)
        self.Table.edit(cellIndex=(r, 6), cellValue=w.updated[:-3])
        self.Table.edit(cellIndex=(r, 7), cellValue=w.duedate[:10])
        self.Table.edit(cellIndex=(r, 8), cellValue=lockstr)

    def filterWorks(self, works):
        '''작업리스트를 받아 현재 메뉴바에서 선택된 옵션에 해당하는 작업만 돌려준다.'''
        def filterByMenu(m, v):
            if m not in self.Menus:
                return True
            if not self.Menus[m].query(visible=True):
                return True
            mv = self.Menus[m].query(value=True)
            if mv == u'모두':
                return True
            if mv == v:
                return True
            return False

        filtered = []
        for w in works:
            try:
                ok = filterByMenu('Progress', Progress.label(w.progress))
                ok &= filterByMenu('Process', ProcessOf[self.hostip][self.prjid].label(w.process))
                ok &= filterByMenu('Episode', w.episode)
                ok &= filterByMenu('AssetType', w.assetType)

                if ok:
                    filtered.append(w)

            except:
                pass

        return filtered

    # TODO : a < b 방식의 정렬함수를 쓰면 sort함수를 따로 만들지 않아도 되고 더 깔끔해질것 같다.
    def sortWorks(self, works):
        '''작업리스트를 정렬한다.'''
        # 키워드별 정렬함수
        def byName(w):
            return w.name.lower()
        def byProcess(w):
            # 할일: 프로젝트에 매핑이라는 공정이 존재하지만 DB상에는 쓰여져있지 않은것 같다. 살펴볼것.
            return ProcessOf[self.hostip][self.prjid].ids.index(w.process) # 프로세스 작업순서는 프로젝트마다 다르다.
        def byProgress(w):
            ProgressOrder = [u'수정', u'요청', u'고쳐짐', u'진행', u'완료', u'승인', u'대기', u'대체', u'비활성']
            return ProgressOrder.index(Progress.label(w.progress))
        def byWorker(w):
            return w.worker
        def byStarted(w):
            return w.started
        def byUpdated(w):
            return w.updated
        def byDuedate(w):
            '''현재 진행중인 작업중 일정이 가장 촉박한 순서대로 보여준다.'''
            if w.progress == "approved":
                return datetime.timedelta(days=88888888)
            if w.progress == "finished":
                return datetime.timedelta(days=77777777)
            if w.duedate == "0000-00-00 00:00:00":
                return datetime.timedelta(days=99999999)
            due = datetime.datetime.strptime(w.duedate, "%Y-%m-%d %H:%M:%S")
            now = datetime.datetime.now()
            return due - now
        def byClass(w):
            if not w.classLevel.strip():
                return 'Z'
            return w.classLevel
        def byLock(w):
            return w.locked

        def sort(works, by):
            func = {u'작업이름':byName, u'공정':byProcess, u'상태':byProgress, u'시작':byStarted, u'작업자':byWorker, u'업데이트':byUpdated, u'일정':byDuedate, u'중요':byClass, u'잠김':byLock}
            rev = {u'작업이름':False, u'공정':False, u'상태':False, u'시작':False, u'작업자':False, u'업데이트':True, u'일정':False, u'중요':False, u'잠김':True}
            return sorted(works, key=lambda w: func[by](w), reverse=rev[by])

        works = sort(works, u'작업이름')
        if 'Sort' in self.Menus:
            sortby = self.Menus['Sort'].query(value=True)
            works = sort(works, sortby)
        else:
            works = sort(works, u'공정')
        return works

    def setEnvWindowEv(self, _):
        '''환경설정창을 연다.'''
        SetEnvWindow()

    def changeTextureQualityEv(self, _):
        changeTextureQuality()

    def applyLodEv(self, _):
        applyLod()

    def referenceUpdateEv(self, _):
        '''
        현재씬의 레퍼런스를 업데이트 한다.
        보통은 업데이트가 씬을 열때마다 실행되지만 가끔씩 작업 중간에 업데이트 사항을 확인하고 싶을때 쓴다.
        '''
        if mayascene_path():
            downloadRefWorks(workFromPath(mayascene_path(), self.hostip))
        else:
            messageprint(u'씬 경로가 올바르지 않습니다. 씬을 먼저 작업에 저장하십시오.')

    def updateShadersEv(self, _):
        if mayascene_path():
            #downloadRefWorks(workFromPath(mayascene_path().replace('/rendering/', '/animation/').replace('/lighting/', '/animation/'), self.hostip), 'shading')
            updateShaders()
        else:
            messageprint(u'씬 경로가 올바르지 않습니다. 씬을 먼저 작업에 저장하십시오.')

    def updateHairsEv(self, _):
        if mayascene_path():
            #downloadRefWorks(workFromPath(mayascene_path().replace('/simulation/', '/animation/'), self.hostip), 'hair')
            updateHairs()
        else:
            messageprint(u'씬 경로가 올바르지 않습니다. 씬을 먼저 작업에 저장하십시오.')

    def stereoscopicToolEv(self, _):
        stereoscopicTool()

    def mergeReferencesEv(self, _):
        mergeReferences()

    def changeSelectedAssetQualityEv(self, _):
        changeSelectedAssetQuality()

    def cleanRigEv(self, _):
        cleanRig()

    def bakeAbcEv(self, _):
        bakeAbcUI()# 1.0.0

    def createRenderProxyEv(self, _):
        createRenderProxy()

    def previewSceneEv(self, _):
        '''
        현재 씬의 프리뷰(플레이블래스트)를 걸고 보여준다.
        걸린 프리뷰는 LOCAL_ROOT 안의 clip디렉토리에 버전별로 저장되어 비교해볼수 있다.
        '''
        name = mayascene_root()
        if not name:
            name = 'untitled'
        prj = ''
        if isWorkPath(mayascene_path()):
            w = workFromPath(mayascene_path(), self.hostip)
            prj = '/' + w.prj
        seqpath = '{r}/clip{p}/{n}/{n}.%04d.jpg'.format(r=LOCAL_ROOT, p=prj, n=name)
        mp4path = '{r}/clip{p}/{n}_{d}.mp4'.format(r=LOCAL_ROOT, p=prj, n=name, d='{0:04d}')
        for i in xrange(1, 100000):
            if not os.path.exists(mp4path.format(i)):
                mp4path = mp4path.format(i)
                break
        else:
            raise RuntimeError('is it valid mp4 path? - ' + mp4path)
        if mayascene_selectedRange():
            if askWindow(u'선택된 영역이 있습니다. 선택된 영역만 거시겠습니까?'):
                startf, endf = mayascene_selectedRange()
        else:
            startf, endf = mayascene_playbackRange()
        soundfile = ''
        sn = cmds.timeControl(mel.eval('$tmpVar=$gPlayBackSlider'), query=True, sound=True)
        if sn:
            soundfile = cmds.getAttr(sn+'.filename')
            if not os.path.isfile(soundfile):
                messageprint('사운드가 적용되어있지만 해당 파일을 찾을수 없습니다. - ' + soundfile)
                soundfile = ''
        makePreview(
            seqpath, mp4path,
            startf, endf,
            mayaoption_load('WMS_Preview_Width', 864), mayaoption_load('WMS_Preview_Height', 486),
            None,
            soundfile
        )
        # mp4파일을 연다.
        if sys.platform == 'win32':
            subprocess.Popen(['cmd', '/c', 'start', mp4path])
        if sys.platform == 'linux2':
            subprocess.Popen(['/usr/local/djv/bin/djv_view.sh', mp4path], env=smgenv_djv())

    def previewPrefWindowEv(self, _):
        PreviewPrefWindow()

    def renderSceneEv(self, _):
        renderScene()

    ######## 팝업메뉴 - 등록 ########
    def openPopupEv(self, *_):
        '''테이블에 오른쪽 마우스 버튼을 눌렀을때 나오는 팝업메뉴를 생성한다.'''
        cmds.popupMenu(self.Table.popup, e=True, deleteAllItems=True) # popup이 지금은 문자열인데 오브젝트로 추후변경

        def menu(label, command, multisel=None, prjtype=None, workprocess=None, team=None, needperm=False, others=None, mine=None, leader=False, checkLock=False, optionFunc=None):
            return dict(label=label, command=command, multisel=multisel, prjtype=prjtype, workprocess=workprocess, team=team, needperm=needperm, others=others, mine=mine, leader=leader, checkLock=checkLock, optionFunc=optionFunc)

        popupMenus = [
            menu(u'정보', self.webInfoEv),
            menu(u'폴더', self.openWorkDirEv),
            menu(u'열기', self.openWorkEv, checkLock=True),
            menu(u'저장', self.saveWorkEv, needperm=True, checkLock=True),
            menu(u'노트', self.noteWorkWindowEv, mine=True),
            menu(u'ABC', self.openAbcEv, prjtype='shot'),
            menu(u'연관 작업', self.searchRelatedWorkEv),
            menu(u'덮어쓰기', self.exportToWorkEv, prjtype='asset', needperm=True),
            menu(u'가져오기', self.importWorkEv, multisel=True, prjtype='asset', optionFunc=self.importWorkPrefWindowEv),
            menu(u'지오메트리', self.importGeometryEv, workprocess='hair'),
            menu(u'레퍼런스', self.referenceWorkEv, multisel=True, prjtype='asset'),
            menu(u'렌더', self.renderWorkEv, workprocess='rendering', needperm=True),
            menu(u'프리뷰 받기', self.downloadPreviewEv, multisel=True, workprocess='animation'),
            menu(u'렌더뷰 업로드', self.uploadRenderviewEv, workprocess='rendering', needperm=True),
            menu(u'다운로드', self.downloadWorkEv, multisel=True),
            menu(u'[ 완료 ]', self.completeWorkEv, needperm=True, checkLock=True),
            menu(u'[ 수정 ]', self.modifyWorkWindowEv),
            menu(u'[ 요청 ]', self.requestWorkWindowEv),
            menu(u'[ 승인 ]', self.approveWorkEv, multisel=True, leader=True),
            menu(u'[ 고쳐짐 ]', self.workToFixedEv, checkLock=True)
        ]

        # 상태 체크
        selworks = self.selectedWorks()
        if not selworks:
            return

        multisel = False
        if len(selworks) > 1:
            multisel = True

        haveperm = True
        for w in selworks:
            if not havePermission(self.loginAccount, w) and (w.progress not in ['request', 'fixed', 'modifying']):
                haveperm = False
                break

        mine, others = True, True
        for w in selworks:
            if w.workerID != self.loginAccount:
                mine = False
            else:
                others = False
            if not mine and not others:
                break

        def surviveOnFilter(menu):
            '''해당 메뉴 아이템이 등록될지를 체크한다. 등록될 항목에 대해서는 True가 반환된다.'''
            if multisel and not menu['multisel']:
                return False
            if menu['prjtype'] and (menu['prjtype'] != self.prjtype):
                return False
            if menu['team'] and (menu['team'] != self.loginTeam):
                return False
            if menu['needperm'] and not haveperm:
                return False
            if menu['others'] and not others:
                return False
            if menu['mine'] and not mine:
                return False
            if menu['leader'] and self.loginPosition != 'team_leader':
                return False
            if menu['workprocess']:
                for w in selworks:
                    if w.process != menu['workprocess']:
                        return False
            if menu['checkLock']:
                for w in selworks:
                    if w.locked:
                        if w.lockerAccount != self.loginAccount:
                            return False
            return True

        if len(selworks) == 1:
            w = selworks[0]
            if w.locked:
                # TODO: 프로세스 검색으로는 잠금 정보가 제대로 넘어오지 않기 때문에 한번 더 검색함.
                # 서버측 프로세스 검색 수정 요망
                _, lockerAccount, lockerName = lockInfo(w)
                cmds.menuItem(label=u'- {0} ({1})에 의해 잠김 -'.format(lockerName, lockerAccount), parent=self.Table.popup)
                if havePermission(self.loginAccount, w) or lockerAccount == self.loginAccount:
                    cmds.menuItem(label=u'[- 해제 -]', parent=self.Table.popup, c=partial(self.unlockWorkEv, w))

        for m in popupMenus:
            if surviveOnFilter(m):
                cmds.menuItem(label=m['label'], parent=self.Table.popup, c=m['command'])
                if m['optionFunc']:
                    cmds.menuItem(optionBox=True, parent=self.Table.popup, command=m['optionFunc'])

                        ######## 팝업메뉴 - 실행 ########
        
    ######## 팝업메뉴 - 실행 ########
    def webInfoEv(self, _):
        '''웹 작업 정보 이벤트'''
        webInfo(self.selectedWorks()[0])

    def openWorkDirEv(self, _):
        '''작업 폴더 열기 이벤트'''
        openWorkDir(self.selectedWorks()[0])

    def downloadWorkEv(self, _):
        for w in self.selectedWorks():
            downloadRelatedWorks(w)

    def openWorkEv(self, _):
        '''선택된 작업을 연다.'''
        w = self.selectedWorks()[0]
        if w.workerID != self.loginAccount and w.progress in [u'대기', u'진행']:
            noticeWindow(u'완료되지 않은 작업을 열 수 없습니다.', title=u'오류')
            return
        # 요청된 작업 열기
        if (w.progress == 'request') and w.requestProcess:
            rw = queryOne(w.hostip, w.prjid, w.requestProcess+"__"+w.name, self.loginAccount)
            if (not rw) or (rw.progress == 'assigned'): # TODO: 요청 작업이 진행중 상태일때는 어떻게 해야 하는가?
                noticeWindow(w.requestProcess+u'에서 작업 요청이 들어왔지만 해당 작업이 없습니다.\n현재 작업을 엽니다.')
                openWork(w)
                return

            answer = selectionWindow(
                w.requestProcess+u'에서 작업 요청이 들어왔습니다.',
                [u'요청된 작업 열기', u'내 작업 열기'], title=u'작업 선택',
            )
            if not answer:
                return
            if answer == u'요청된 작업 열기':
                # 요청 작업자가 수정이 끝나기 전에 작업을 다시 여는 것을 방지하기 위해
                # 작업을 잠근다.
                locked, locker, lockerName = lockInfo(rw)
                if locked:
                    if locker != self.loginAccount:
                        noticeWindow(u'{0}의 {1}작업이 {2}에 의해 잠겨있습니다.'.format(w.name, w.process, lockerName))
                        return
                else:
                    err = lockWork(rw, self.loginAccount, self.loginName)
                    if err:
                        noticeWindow(err)
                        return
                    self.updateTable(rw)
                openWork(rw)
                return
            else:
                # 이미 작업자가 한번 요청작업을 열었다면 해당 작업은 잠긴 상태일 것이다.
                # 그런데 이때 다시 자신의 작업을 연다면 요청작업은 풀어 놓아야 한다.
                locked, _, _ = lockInfo(rw)
                if locked:
                    err = unlockWork(rw, self.loginAccount)
                    if err:
                        noticeWindow(err)
                        return
                self.updateTable(rw)
                openWork(w)
                return

        openWork(w)

    def openAbcEv(self, _):
        w = self.selectedWorks()[0]
        openAbc(w)

    def searchRelatedWorkEv(self, _):
        '''검색탭으로 이동해 선택된 작업의 연관 작업을 검색한다.'''
        w = self.selectedWorks()[0]
        prjidx = self.ProjectMenu.query(select=True)
        self.TabLayout.edit(selectTab=self.SearchTab.name)
        self.ProjectMenu.edit(select=prjidx)
        # 프로젝트를 현재 작업 프로젝트로 변경 해당 바를 띄운다.
        # TODO : 아래 코드가 필요한가?
        self.projectChanged(None)
        # 검색어를 변경한후 검색
        self.Menus['Progress'].edit(value=u'모두')
        mayaoption_save(self.Menus['Progress'].name, u'모두')
        self.Menus['Process'].edit(value=u'모두')
        mayaoption_save(self.Menus['Process'].name, u'모두')
        if self.prjtype == 'asset':
            self.Menus['AssetType'].edit(value=u'모두')
            mayaoption_save(self.Menus['AssetType'].name, u'모두')
        self.SearchTargetOM.edit(value=u'작업이름')
        mayaoption_save(self.SearchTargetOM.name, u'작업이름')
        self.SearchTF.edit(text=w.name)

        self.searchEv(None)

    def importWorkEv(self, _):
        '''선택된 작업들을 현재 씬에 불러온다.'''
        fails = importWorks(self.selectedWorks())
        if fails:
            msg = u'다음 작업이 진행되지 않아 불러오지 못했습니다.\n'
            msg += '\n'.join(fails)
            noticeWindow(msg)

    def importWorkPrefWindowEv(self, _):
        ImportWorkPrefWindow()

    def importGeometryEv(self, _):
        w = self.selectedWorks()[0]
        importGeometry(w)

    def referenceWorkEv(self, _):
        '''선택된 작업들을 현재 씬에 레퍼런스로 추가한다.'''
        fails = referenceWorks(self.selectedWorks())
        if fails:
            msg = u'다음 작업이 진행되지 않아 불러오지 못했습니다.\n'
            msg += '\n'.join(fails)
            noticeWindow(msg)

    def saveWorkEv(self, _):
        '''선택된 작업을 저장하고, 서버에 작업이 진행중임을 알린다.'''
        def workToProgressing(w):
            err = updateWork(w, 'progressing', '', self.loginAccount, False)
            if err:
                noticeWindow(err)
            self.updateTable(w)

        w = self.selectedWorks()[0]
        # 만약 작업이 요청중인 상태이면 내 작업과 요청 작업중 어떤 작업을
        # 저장하고 있는지 체크해서 알려준다.
        if (w.progress == 'request') and w.requestProcess:
            if mayascene_path() == workScenePath(w.prj, w.prjtype, w.requestProcess, w.name):
                rw = queryOne(w.hostip, w.prjid, w.requestProcess+"__"+w.name, self.loginAccount)
                if (not rw) or (rw.progress == 'assigned'): # TODO: 요청 작업이 진행중 상태일때는 어떻게 해야 하는가?
                    noticeWindow(u'아직 {0} 작업이 생성되어 있지 않습니다. 작업을 저장할 수 없습니다.'.format(rw.process))
                    return
                ok = askWindow(u'{0}에서 요청받은 작업을 저장합니다.'.format(rw.process))
                if not ok:
                    return
                saveWork(rw)
                workToProgressing(rw)
                return
            elif mayascene_path() == w.mb:
                ok = askWindow(u'{0} 작업을 저장합니다.\n\n(현재 {1}에서 요청중입니다.)'.format(w.process, w.requestProcess))
                if not ok:
                    return
                saveWork(w)
                # 작업이 요청중일 때는 진행상태로 변경하지 않는다.
                # workToProgressing(w)
                return
            else:
                noticeWindow(u"경로가 저장하려는 작업과 맞지 않습니다. 작업을 저장할 수 없습니다.")
                return

        saveWork(w)
        if w.mb == mayascene_path():# 1.0.0
            workToProgressing(w)# 1.0.0

    def exportToWorkEv(self, _):
        '''현재 씬을 선택 작업에 덮어쓴다.'''
        exportToWork(self.selectedWorks()[0])

    def noteWorkWindowEv(self, _):
        '''선택된 작업에 노트를 단다. 이 노트는 웹에서 확인할 수 있다.'''
        NoteWorkWindow(self.selectedWorks()[0], self)

    def renderWorkEv(self, _):
        '''해당 작업을 렌더한다.'''
        submitRenderWindow(self.selectedWorks()[0], self)

    def downloadPreviewEv(self, _):
        '''선택된 작업들의 프리뷰를 다운로드 받는다.'''
        downloadPreview(self.selectedWorks())

    def uploadRenderviewEv(self, _):
        '''선택된 작업의 렌더뷰를 업로드 한다.'''
        uploadRenderview(self.selectedWorks()[0], self)

    def requestWorkWindowEv(self, _):
        '''선택된 작업에 요청사항을 전달한다. 이 작업은 요청중으로 바뀐다. 요청글은 웹에서 확인할 수 있다.'''
        RequestWorkWindow(self.selectedWorks()[0], self)

    def modifyWorkWindowEv(self, _):
        '''선택된 작업에 수정사항을 전달한다. 이 작업은 수정중으로 바뀐다. 수정글은 웹에서 확인할 수 있다.'''
        ModifyWorkWindow(self.selectedWorks()[0], self)

    def approveWorkEv(self, _):
        '''선택된 작업들을 승인한다.'''
        works = self.selectedWorks()
        if len(works) > 1:
            msg = u'{n}개의 작업을 승인합니다.'.format(n=len(works))
        else:
            msg = u'{work}를 승인합니다.'.format(work=works[0].name)
        ok = askWindow(msg)
        if not ok:
            return
        for w in works:
            err = updateWork(w, 'approved', '', self.loginAccount, False)
            if err:
                noticeWindow(err)
                return
            self.updateTable(w)
        noticeWindow(u'선택하신 작업이 승인되었습니다.')

    def completeWorkEv(self, _):
        '''선택된 작업을 완료한다.'''
        w = self.selectedWorks()[0]
        # 요청받은 작업이고 요청 공정이 있다면 현재 선택된 작업 대신 현재 씬의 작업을 연다. 공정이 없다면 일반적인 과정을 따른다.
        if (w.progress == 'request') and w.requestProcess:
            if mayascene_path() == workScenePath(w.prj, w.prjtype, w.requestProcess, w.name):
                rw = queryOne(w.hostip, w.prjid, w.requestProcess+"__"+w.name, self.loginAccount)
                if (not rw) or (rw.progress == 'assigned'): # TODO: 요청 작업이 진행중 상태일때는 어떻게 해야 하는가?
                    noticeWindow(u"아직 만들어지지 않은 작업입니다. 작업을 완료할 수 없습니다.")
                    return
                ok = askWindow(w.requestProcess+u'에서 요청받은 작업을 완료합니다.')
                if not ok:
                    return
                self.completeWork(rw, w)
                return
            elif mayascene_path() == w.mb:
                ok = askWindow(u'{0} 작업을 완료합니다.\n\n(현재 {1}에서 요청중입니다. 수정되었다면 고쳐짐 상태로 변경하세요.)'.format(w.process, w.requestProcess))
                if not ok:
                    return
                self.completeWork(w, None)
                return
            else:
                noticeWindow(u"열린 씬이 완료하려는 작업과 맞지 않습니다. 작업을 완료할 수 없습니다.")
                return

        self.completeWork(w, None)

    def completeWork(self, w, origw):
    
        '''
        작업을 완료한다.
        수정 요청을 받은 작업을 내 작업에 완료할 때에는 w가 요청받은 작업이고 origw는 내 작업이다.
        origw에 값이 들어오면 요청 작업 완료료 생각하면 된다.
        '''
        # 다른 작업자의 작업 완료시 요청에 의한 것이 아니면 이유 작성필요.
        xmlMatInfo = False
        isMyWork = True
        completeMessage = None
        if w.workerID != self.loginAccount and not origw:
            isMyWork = False
            completeMessage = promptWindow(u'다른 작업자의 작업을 완료하려 합니다. 이유를 써주세요.')
            if not completeMessage:
                noticeWindow(u'작업 완료가 취소되었습니다.')
                return

        # 완료 가능 여부 검사
        if w.mb != mayascene_path():
            noticeWindow(u'완료하려는 작업이 열려있는 작업과 달라 작업을 완료하지 못하였습니다.')
            return
        if not os.path.isfile(w.mb):
            noticeWindow(u'작업 파일이 없어서 작업을 완료하지 못하였습니다.')
            return

        # 텍스쳐 검사, 완료를 할수 없는 상황이면 False를 반환한다. 아니면 True 반환.
        ok = self.checkTextureForComplete(w)
        if not ok:
            noticeWindow(u'작업 완료가 취소되었습니다.')
            return
        
        linkOriginalTexture(LOCAL_ROOT)
        cmds.evalDeferred(partial(linkLowTexture, LOCAL_ROOT))
        # 저장
        if mayascene_modified():
            save = askWindow(u'변경사항을 적용하려면 저장을 해야합니다.\n저장하시겠습니까?')
            if not save:
                messageprint(u'취소되었습니다.')
                return

            lodNodeList = cmds.ls('|LOD_*')
            if lodNodeList:
                changeShotAssetQuality(True)
                cmds.delete(lodNodeList)

            for worldCtrlLow in cmds.ls(('World_Ctrl.Low', '*:World_Ctrl.Low'), long=True):
                worldCtrl = worldCtrlLow.split('.')[0]
                if cmds.referenceQuery(worldCtrl, isNodeReferenced=True):
                    rslvName = cmds.referenceQuery(worldCtrl, filename=True)
                    if rslvName.count('_LOW.'):
                        cmds.setAttr(worldCtrlLow, 2)
                    else:
                        cmds.setAttr(worldCtrlLow, 0)
                else:
                    cmds.setAttr(worldCtrlLow, 0)

            saveScene(w.mb, 'complete')

        if w.process == 'animation':
            minTime = cmds.playbackOptions(q=True, min=True)
            maxTime = cmds.playbackOptions(q=True, max=True)

            # 움직인 컨트롤러에 키 할당
            ctrlList = cmds.ls('*:*:*_Ctrl', '*:*_Ctrl', '*_Ctrl')# 1.0.1
            if ctrlList:
                cmds.currentTime(minTime)
                for ctrl in ctrlList:
                    changedList = cmds.listAttr(ctrl, changedSinceFileOpen=True, keyable=True)
                    if changedList:
                        for changed in changedList:
                            if not cmds.listConnections(ctrl+'.'+changed, d=False):
                                cmds.setKeyframe(ctrl+'.'+changed, time=minTime)

                aniCurveList = cmds.ls(type='animCurveTL')+cmds.ls(type='animCurveTA')+cmds.ls(type='animCurveTT')+cmds.ls(type='animCurveTU')
                if aniCurveList:
                    for actu in aniCurveList:
                        connList = cmds.listConnections(actu, plugs=True, s=False)
                        if connList and connList[0].count('.') and not connList[0].count('['):
                            dupName = 'ANI__'+connList[0].replace(':', '__ns__').replace('.', '__co__')
                            if cmds.ls(dupName):
                                cmds.delete(dupName)

                            cmds.duplicate(actu, name=dupName, returnRootsOnly=True)

                    dupAnimCurveList = cmds.ls('ANI__*__ns__*__co__*')
                    if dupAnimCurveList:
                        cmds.select(dupAnimCurveList, replace=True)
                        mayascene_exportSelection(w.mb.replace('.mb', '_ANI.mb').replace('.ma', '_ANI.mb'))
                        if dupAnimCurveList:
                            cmds.delete(dupAnimCurveList)

        elif w.process == 'stereoscopic':
            mel.eval('MBExportPath("'+w.mb.replace('.mb', '_CAM.mb')+'");')
            mel.eval('abcExportPath("'+w.mb.replace('.mb', '_CAM.abc')+'");')

        # 렌더 프로세스의 경우 렌더 관련 자원들을 렌더 드라이브로 복사하고, 텍스쳐 경로를 수정한다.
        elif w.process == 'rendering':
            # TODO: 외주 회사라면 R:를 다른 목적으로 사용하고 있을수도 있다.
            # 렌더드라이브가 None이라면 텍스쳐를 복사하지 않고 넘어가자.
            if not os.path.exists(RENDER_DRIVE):
                ok = askWindow(u"렌더 드라이브를 찾지 못했습니다.\n 텍스쳐를 복사하지 않고 넘어가시겠습니까?")
                if not ok:
                    noticeWindow(u'작업 완료가 취소되었습니다.')
                    return
            else:
                ok = copyRenderResourcesToRenderDrive()
                if not ok:
                    return
                relinkTexturesToRenderDrive()

        elif w.process == 'shading' or w.process == 'mapping':
            xmlMatInfo = True
            cleanRig()

            cmds.select(cmds.ls(geometry=True), replace=True)
            mayascene_exportSelection(w.mb)

            exportUVMesh()

            # 1.0.1 -->
            deleteTopList = []
            try: deleteTopList = list(set(cmds.ls(assemblies=True)) - set(cmds.ls('|*', undeletable=False)))
            except: pass
            if deleteTopList:
                cmds.delete(deleteTopList)
            # 1.0.1 <--
            cmds.select(cmds.ls(mat=True)+cmds.ls(type='shadingEngine'), replace=True, noExpand=True)
            mayascene_exportSelection(cmds.file(q=1, sn=1).replace('.mb', '_SHD.mb').replace('.ma', '_SHD.mb'))
            
            cmds.file(w.mb, force=True, open=True)
            # 2017-02-03 -->
            #convertToLowTexture(w)
            # 2017-02-03 <--

        elif w.process == 'rigging':
            xmlMatInfo = True

            at = ''
            if w.assetType in AssetType.labels:
                at = AssetType.id(w.assetType)

            if at == 'BG' and w.name.split('_')[0] != 'SET' :
                extractLow()
            #extractLow()#2017-02-09

            for ref in cmds.file(q=True, reference=True):
                cmds.file(ref, rr=True)

            deleteTopList = []
            try: deleteTopList = list(set(cmds.ls(assemblies=True)) - set(cmds.ls('|*', undeletable=False)))
            except: pass
            if deleteTopList:
                cmds.delete(deleteTopList)

            cmds.select(cmds.ls(mat=True)+cmds.ls(type='shadingEngine'), replace=True, noExpand=True)
            mayascene_exportSelection(w.mb.replace('.mb', '_SHD.mb').replace('.ma', '_SHD.mb'))

            cmds.file(w.mb, open=True, force=True)
            # 2017-02-03 -->
            #convertToLowTexture(w)
            # 2017-02-03 <--

        elif w.process == 'hair':
            for ref in cmds.file(q=True, reference=True):
                cmds.file(ref, rr=True)

            hairGeo = cmds.ls(('*_hairGeo', '*_scalpGeo'))
            if hairGeo:
                dupList = cmds.duplicate(hairGeo)
                cmds.select(dupList, replace=True)
                HairGeoGrpList = cmds.ls('HairGeo_Grp')
                if HairGeoGrpList: cmds.delete(HairGeoGrpList)
                cmds.group(name='HairGeo_Grp', world=True)
                for dup in dupList:
                    cmds.rename('HairGeo_Grp|'+dup.split('|')[-1], dup.split('|')[-1][:-1])

                cmds.select('HairGeo_Grp', replace=True)
                mayascene_exportSelection(w.mb.replace('.mb', '_GEO.mb').replace('.ma', '_GEO.mb'))
                HairGeoGrpList = cmds.ls('HairGeo_Grp')
                if HairGeoGrpList: cmds.delete(HairGeoGrpList)

        # 스크린샷
        lvis = cmds.headsUpDisplay(query=True, layoutVisibility=True)
        cmds.headsUpDisplay(edit=True, layoutVisibility=False)
        screenshot(w)
        cmds.headsUpDisplay(edit=True, layoutVisibility=lvis)

        if w.process == 'animation' or w.process == 'simulation' or w.process == 'stereoscopic':# 1.0.1
            # 플레이블래스트
            if askWindow(u'플래이블래스터를 실행하시겠습니까?'):
                previewWork(w)
                try:
                    cmds.deleteUI('WMS_PBWindow')
                except:
                    print 'WMS_PBWindow deleteUI False'
                
        # 레퍼런스 검사
        relrefs = makeRelativeReferences(w, getAllRefs())
        relrefnames = ','.join([os.path.splitext(os.path.basename(r))[0] for r in relrefs]) # 레퍼런스작업의 이름을 콤마로 묶음. 웹 작업정보 갱신에 쓰인다.

        # XML 생성
        checknum = checkTime()
        saveWorkXML(w, checknum, relrefs, xmlMatInfo, True)

        # 파일 전송
        err = uploadWork(w, checknum)
        if err:
            noticeWindow(err)
            return

        # 웹으로 파일 정보 전송
        infos = (
            [('name', 'framerate'), ('label', u'초당프레임'), ('([TEXT])', str(mayascene_frameRate())+' fps')],
            [('name', 'start_frame'), ('label', u'시작프레임'), ('([TEXT])', mayascene_animationStart())],
            [('name', 'end_frame'), ('label', u'종료프레임'), ('([TEXT])', mayascene_animationEnd())],
            [('name', 'frame'), ('label', u'프레임'), ('([TEXT])', mayascene_animationEnd()-mayascene_animationStart()+1)],
            [('name', 'asset'), ('label', u'에셋'), ('([TEXT])', relrefnames)],
        )
        it = ''
        for i in infos:
            it += infoText('information', i)
        if not origw:
            # 내 작업 완료
            # 현재 상태가 요청이면 그대로 놔두고 정보만 업데이트 한다.
            pg = 'finished'
            if w.progress == 'request':
                pg = ''
            err = updateWork(w, pg, it, self.loginAccount, False)
            if err:
                noticeWindow('작업을 완료하는데 실패했습니다: ' + err)
                return
        else:
            # 요청 작업 완료
            err = updateWork(w, 'finished', it, self.loginAccount, True)
            if err:
                noticeWindow('요청된 작업을 완료하는데 실패했습니다: ' + err)
                return
            self.updateTable(w)
            err = updateWork(origw, 'fixed', '', self.loginAccount, False)
            if err:
                noticeWindow('내 작업을 고쳐짐으로 변경하는데 실패했습니다: ' + err)
                return
            self.updateTable(origw)

        if completeMessage:
            infos = [
                ('id', infoID(self.loginAccount)),
                ('account', self.loginAccount),
                ('label', u'요청 메모'),
                ('([TEXT])', u'작업완료사유 - '+completeMessage),
                ('updated', time.strftime('%Y-%m-%d %H:%M:%S')),
            ]
            it = infoText('request', infos)
            err = updateWork(w, '', it, self.loginAccount, False)
            if err:
                noticeWindow(err)
                return
            w.progress = 'fixed'

        locked, _, _ = lockInfo(w)
        if locked:
            err = unlockWork(w, self.loginAccount)
            if err:
                noticeWindow(err)
                return

        self.updateTable(w)
        noticeWindow(u'작업이 완료되었습니다.')

    def checkTextureForComplete(self, w):
        '''작업 완료를 위한 텍스쳐 검사. 완료를 할수 없는 상황이면 False를 반환한다. 아니면 True 반환.'''
        def copytex(texs, dstdir):
            if not texs:
                return True
            msg = u'{n}개의 텍스쳐 경로가 {dstdir} 아래에 있지 않습니다. 복사하시겠습니까?\n\n'.format(n=len(texs), dstdir=dstdir)
            if len(texs) > 5:
                msg += '\n'.join(texs.keys()[:5]+['...'])
            else:
                msg += '\n'.join(texs.keys())

            answer = selectionWindow(msg, [u'예', u'아니오'],  title=u'텍스쳐 가져오기', cancel=u'취소')
            if not answer:
                return False
            if answer == u'아니오':
                return True

            # 여러 디렉토리에 있는 파일을 하나의 디렉토리로 복사하기 때문에
            # 같은 파일 이름이 있다면 덮어쓰게 된다.
            names = set([])
            dups = set([])
            for n in [os.path.basename(f) for f in texs]:
                if n not in names:
                    names.add(n)
                else:
                    dups.add(n)
            if dups:
                msg = u"다음 텍스쳐 파일의 이름이 여러 곳에 존재합니다. 덮어쓰시겠습니까?\n" + "\n".join(dups)
                ok = askWindow(msg, ok=u'예', cancel=u'아니오')
                if not ok:
                    return False
            # 복사
            if not smgpath_make(dstdir):
                noticeWindow(u'{dstdir}을 만들수 없습니다.'.format(dstdir=dstdir))
                return False

            copyTextures(texs, dstd=dstdir, linkToCopied=True)
            return True

        # 에셋이 아니라면 텍스쳐를 따로 검사할 필요가 없다.
        if self.prjtype != 'asset':
            return True

        # 빠진 텍스쳐가 있는지 검사한다.
        mistex = sorted(mayascene_missingTextures())
        if mistex:
            msg = u'{n}개의 텍스쳐 경로에 파일이 존재하지 않습니다. 계속하시겠습니까?\n'.format(n=len(mistex))
            if len(mistex) > 5:
                msg += '\n'.join(mistex[:5]+['...'])
            else:
                msg += '\n'.join(mistex)
            ok = askWindow(msg, ok=u'예', cancel=u'아니오')
            if not ok:
                return False

        if w.process == 'modeling':
            print RENDER_DRIVE+'/texture'
            if not w.assetType:
                # queryWorks가 등록되지 않은 셋에 타입을 보면 ''으로 변경한다. assetType을 이름 대신 아이디로 변경할지 고민 필요.
                if askWindow(u'작업의 셋에타입이 없거나 등록되지 않은 타입입니다.\n텍스쳐를 복사하지 않고 넘어가시겠습니까?', ok=u'예', cancel=u'아니오'):
                    return True
                return False
            # R드라이브 텍스쳐 디렉토리에 있지 않은 텍스쳐 파일을 R드라이브로 복사한다.
            rtexroot = RENDER_DRIVE+'/texture'
            notinr = mayascene_texturesNotInside(rtexroot)
            notinr = dict((t, n) for t, n in notinr.items() if glob.glob(t)) # 없는 파일 걸러내기
            assetDirName = {
                u'배경':'01_BG',
                u'캐릭터':'02_CH',
                u'프랍':'03_PRP',
                u'2D이펙트':'03_PRP/2d_fx_source',
            }
            rtexdir = rtexroot+'/'+self.prj+'/'+assetDirName[w.assetType]+'/'+w.name
            #2017-05-31->
            # 로컬 복사
            notinw = mayascene_texturesNotInside(w.dir)
            notinw = dict((t, n) for t, n in notinw.items() if glob.glob(t)) # 없는 파일 걸러내기
            return copytex(notinw, w.dir+'/texture')
            #2017-05-31 <-
            return copytex(notinr, rtexdir)
        else:
            notinw = mayascene_texturesNotInside(w.dir)
            notinw = dict((t, n) for t, n in notinw.items() if glob.glob(t)) # 없는 파일 걸러내기
            return copytex(notinw, w.dir+'/texture')

    def workToFixedEv(self, _):
        '''선택된 작업을 고쳐짐으로 변경한다.'''
        w = self.selectedWorks()[0]
        msg = promptWindow(u'어느 부분이 고쳐졌는지 써주세요.')
        if not msg:
            noticeWindow(u'내용이 없어 취소되었습니다.')
            return
        fixInfo = u'request|-CL-|id|-EQ-|'+infoID(self.loginAccount)+u'|-CM-|account|-EQ-|'+self.loginAccount+u'|-CM-|label|-EQ-|요청 메모|-CM-|updated|-EQ-|'+time.strftime('%Y-%m-%d %H:%M:%S')+u'|-CM-|([TEXT])|-EQ-|고쳐짐 - '+msg+u'|-SC-|'
        err = updateWork(w, 'fixed', fixInfo, self.loginAccount, False)
        if err:
            noticeWindow(err)
            return
        self.updateTable(w)

    def unlockWorkEv(self, w, _):
        '''해당 작업의 잠금을 푼다.'''
        err = unlockWork(w, self.loginAccount)
        if err:
            noticeWindow(err)
        self.updateTable(w)

    def works(self):
        '''현재 탭의 작업들을 반환한다.'''
        idx = self.TabLayout.query(selectTabIndex=True) - 1
        return [self.myWorks, self.teamWorks, self.searchWorks][idx]

    def selectedWorks(self):
        '''현재 선택된 작업들을 반환한다.'''
        rows = self.Table.query(selectedRows=True)
        if not rows:
            return []
        works = []
        for r in rows:
            works.append(self.workFromRow(r))
        return works

    def workFromRow(self, r):
        name = self.cellValue(r, 2)
        process = ProcessOf[self.hostip][self.prjid].id(self.cellValue(r, 3))
        key = '-'.join([self.prj, self.prjtype, name, process])
        return self.works()[key]

    def updateTable(self, w):
        '''
        현재 테이블에 해당 작업이 있다면 그 열을 수정한다.
        테이블에 해당 작업이 없으면 아무일도 하지 않는다.
        '''
        nrow = self.Table.query(rows=True)
        for r in range(1, nrow):
            name = self.cellValue(r, 2)
            process = ProcessOf[self.hostip][self.prjid].id(self.cellValue(r, 3))
            if name == w.name and process == w.process:
                break
        else:
            return
        sl = self.Table.query(selectedRows=True)
        self.Table.edit(selectedRows=[])
        self.setRow(r, w)
        if sl:
            self.Table.edit(selectedRows=sl)

    def cellValue(self, r, c):
        return self.Table.query(cellIndex=[r, c], cellValue=True)[0]

    def cellColor(self, r, c):
        '''해당 셀의 정보를 바탕으로 색상을 선택한다.'''
        if c == 1:
            workClass = self.cellValue(r, 1).lstrip()
            classColor = {
                'A':(128,0,0), 'B':(128,64,0), 'C':(128,121,0),
                'D':(72,128,0), 'E':(0,128,100), 'F':(0,65,128),
                '':(46,46,46)
            }
            return classColor[workClass]
        w = self.workFromRow(r)
        if w.mb == mayascene_path():
            return (180, 110, 164)
        lock = self.cellValue(r, 8)
        if lock:
            return (32, 32, 32)
        pg = self.cellValue(r, 4).split('(')[0]
        pgcolor = {
            u'없음':(128,128,128),
            u'완료':(0,0,128), u'진행':(132,132,30), u'승인':(12,120,8),
            u'대기':(128,128,128), u'요청':(128,0,0), u'고쳐짐':(92,4,156),
            u'수정':(128,64,32), u'대체':(64,64,64), u'비활성':(32,32,32)
        }
        return pgcolor[pg]

    def editCell(self, *_):
        '''셀을 수정할수 있는지 체크하는 함수. 항상 참을 반환한다..'''
        return True

    ######## 검색 ########
    def query(self):
        '''서버에서 해당 탭의 작업을 가져온다.'''
        if self.Tab == self.MyWorkTab:
            self.myWorks = queryWorks(self.hostip, self.prjid, 'owner', self.loginAccount, '', '', self.loginAccount)
            return self.myWorks
        if self.Tab == self.TeamWorkTab:
            self.teamWorks = queryWorks(self.hostip, self.prjid, 'team', self.loginAccount, '', '', self.loginAccount)
            return self.teamWorks
        if self.Tab == self.SearchTab:
            tg = self.searchTarget.id(self.SearchTargetOM.query(value=True))
            kw = self.SearchTF.query(text=True)
            try:
                pg = Progress.id(self.Menus['Progress'].query(value=True))
            except:
                pg = ''
            try:
                pc = ProcessOf[self.hostip][self.prjid].id(self.Menus['Process'].query(value=True))
            except:
                pc = ''
            self.searchWorks = queryWorks(self.hostip, self.prjid, tg, kw, pg, pc, self.loginAccount)
            return self.searchWorks

    def searchEv(self, _):
        '''검색 버튼이 눌리면 서버에서 작업을 가져와서 검색 탭의 테이블을 다시 그린다.'''
        workdic = self.query()
        self.refreshBar(workdic.values())
        self.refreshTable(workdic.values())

    ######## 로그인, 로그아웃 ########
    def loadSession(self):
        '''
        서버에 현재 컴퓨터의 로그인 세션을 부른다. 반환 값은 서버에서 보내주는 xml의 루트 엘리먼트이다.
        만약 세션이 남아있다면 엘리먼트 아래에 success태그가 있다.
        '''
        mac = ''.join(re.findall('..', '%012x' % uuid.getnode()))
        resp = smgweb_post(
            WMS_HOST,
            '/wms/script/check_session.php',
            {
                'mac':mac,
                'account':mayaoption_load('WMS_PreviousAccount', ''),
            }
        )
        rootEl = ET.XML(resp)
        return rootEl

    def saveSession(self, account, password):
        '''서버에 현재 컴퓨터의 로그인 세션을 저장한다.'''
        mac = ''.join(re.findall('..', '%012x' % uuid.getnode()))
        resp = smgweb_post(
            WMS_HOST,
            '/wms/script/check_session.php',
            {
                'mac':mac,
                'account':account,
                'password':password
            }
        )
        rootEl = ET.XML(resp)
        # rootEl로 넘어가는 xml정보 확인
        return rootEl

    def manualLoginEv(self, _):
        '''
        사용자가 로그인 버튼을 누르거나 패스워드 필드에서 엔터를 치면
        정보 필드를 확인해서 맞는지 확인한 후, 로그인 프로세스를 실행시킨다.
        '''
        account = cmds.textField('LoginAccount', q=True, text=True)
        password = cmds.textField('LoginPassword', q=True, text=True)
        # 로그인이 되었든 되지 않았든 패스워드 정보를 남겨두지 않는다.
        cmds.evalDeferred(partial(cmds.textField, 'LoginPassword', edit=True, tx=u''))
        try:
            account.encode('ascii')
            password.encode('ascii')
        except UnicodeEncodeError:
            cmds.text('LoginMessage', e=True, l=u'[ 아이디나 암호에는 한글을 쓰실 수 없습니다. ]', bgc=[1, 0.3, 0.3])
            return
        resp = smgweb_post(
            WMS_HOST,
            '/wms/script/login.php',
            {
                'account':account,
                'password':password
            }
        )
        rootEl = ET.XML(resp)
        if not rootEl.getiterator('success'):
            cmds.text('LoginMessage', e=True, l=u'[ 계정 정보가 올바르지 않습니다 ]', bgc=[1, 0.3, 0.3])
            return
        rootEl = self.saveSession(account, password)
        if rootEl.find('error') is not None:
            noticeWindow(u'세션을 저장하는데 실패했습니다.')
            return
        mayaoption_save('WMS_PreviousAccount', account)
        self.login(rootEl)

    def login(self, rootEl):
        global WMS_ACCOUNT
        '''서버에서 받은 xml정보를 바탕으로 로그인 정보를 등록하고 메인 레이아웃을 보인다.'''
        def get(x):
            for el in rootEl.getiterator('profile'):
                if el.attrib['item'] == x:
                    return el.text
            raise RuntimeError('key {0} not found'.format(x))
        self.loginAccount = get('account')
        self.loginName = get('name')
        self.loginTeam = get('team')
        self.loginPosition = get('position')
        WMS_ACCOUNT = self.loginAccount
        queryProjectInfo(self.loginAccount)
        menus = self.ProjectMenu.query(itemListLong=True)
        if menus:
            for m in self.ProjectMenu.query(itemListLong=True):
                cmds.deleteUI(m)

        # 프로젝트 정보를 호스트IP별로 정렬하되 현재 접속한 호스트가 가장 상단에 나오도록 함.
        for hostip in sorted(ProjectInfo, key=lambda x: x.replace(WMS_HOST, "")):
            # 프로젝트 아이디는 한글 표기 순으로 정렬.
            for prjid in sorted(ProjectInfo[hostip], key=lambda x: ProjectInfo[hostip][x][1]+" / "+ProjectInfo[hostip][x][2]):
                host, prj, prjtype = ProjectInfo[hostip][prjid]
                if hostip == WMS_HOST:
                    label = prj+' / '+prjtype
                else:
                    label = '(' + host + ') ' + prj+' / '+prjtype
                # 유니크 프로젝트 아이디 생성시 앞에 host_를 붙여 숫자로 시작하는 걸 방지.
                uniqProjectID = 'host_'+hostip+'__'+prjid
                uiName = cmds.menuItem(uniqProjectID, label=label, parent=self.ProjectMenu.name)
                self.uiData[uiName] = (hostip, prjid)

        self.LoginLayout.edit(visible=False)
        self.MainLayout.edit(visible=True)
        self.MainMenu.edit(label=self.loginName, enable=True)

        # 유틸리티 업데이트
        _, err = updateEnvDir(HTTP_FILE_ROOT+"wms/utilities", LOCAL_ROOT+"/utilities")
        if err:
            noticeWindow(u"utilities 디렉토리를 업데이트 할 수 없습니다: " + err)

        # 스크립트 업데이트
        updated, err = updateEnvDir(HTTP_FILE_ROOT+"wms/app/pipeline/scripts", LOCAL_ROOT+"/scripts")
        if err:
            noticeWindow(u"scripts 디렉토리를 업데이트 할 수 없습니다: " + err)
        if updated:
            # userSetup.py 파일은 내문서 마야의 scripts 디렉토리에 있어야
            # 마야가 실행될 때 함께 실행된다.
            shutil.copy(LOCAL_ROOT+"/scripts/maya/userSetup.py", os.environ['MAYA_APP_DIR']+'/scripts')

        # 이전에 보고 있었던 탭으로 변경한다 (tabChanged 이벤트 발생).
        # 이전 탭 설정이 없다면 수동으로 tabChanged 이벤트 발생시킨다.
        idx = mayaoption_load('WMS_TABINDEX', 0)
        if idx != 0:
            self.TabLayout.edit(selectTabIndex=idx + 1)
        else:
            self.tabChanged(None)
        #synergy-media NEW

        if WMS_HOST == '112.217.174.10':
            try: uploadInstalledList()
            except: pass
        '''
        #synergy-media
        if WMS_HOST == '192.168.0.130':
            try: uploadInstalledList()
            except: pass

        #Pingo
        if WMS_HOST == '121.167.145.193:7806':
            try: uploadInstalledList()
            except: pass

        #밤하늘
        if WMS_HOST == '175.197.68.192:7806':
            try: uploadInstalledList()
            except: pass
        '''
    def logoutEv(self, _):
        '''로그아웃 버튼이 눌리면 로그인 정보를 지운 후 로그인 레이아웃을 보인다.'''
        self.loginAccount = ''
        self.loginName = ''
        self.MainMenu.edit(label='', enable=False)
        self.MainLayout.edit(visible=False)
        self.LoginLayout.edit(visible=True)

# 유틸리티 윈도우
class SetEnvWindow:
    '''환경설정 창'''
    def __init__(self):
        self.Window = mayaui_New(cmds.window, 'SetEnvironmentWindow', title=u'설정창')
        self.Window.edit(width=100, height=50)
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, 'MainLayout', adj=True, adjustableColumn=2, rowSpacing=10):
                self.Menu = mayaui_New(cmds.optionMenuGrp, 'WMSDrive', label=u'작업관리기 드라이브')
                drives = {
                    'win32':['C:', 'D:', 'E:', 'F:'],
                    'linux2':['/mnt/D', '/mnt/E', '/mnt/F']
                }
                for d in drives[sys.platform]:
                    cmds.menuItem(label=d)
                cmds.optionMenuGrp('WMSDrive', edit=True, value=WMS_DRIVE)
                cmds.separator('sep', height=40, style='none')
                with mayaui_New(cmds.rowLayout, 'ButtonLayout', nc=2):
                    cmds.button('apply', l=u'적용', width=100, command=self.applyEv)
                    cmds.button('close', l=u'닫기',  width=100, command=self.closeEv)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def closeEv(self, _):
        self.close()

    def applyEv(self, _):
        '''환경설정 적용 이벤트. WMS드라이브를 재설정한다.'''
        cmds.evalDeferred(self.close)
        wmsdrv = self.Menu.query(value=True)
        if sys.platform == 'win32':
            mayaoption_save('WMS_DRIVE_WINDOWS', wmsdrv)
        else:
            mayaoption_save('WMS_DRIVE_LINUX', wmsdrv)

class PreviewPrefWindow:
    '''프리뷰 설정 창'''
    def __init__(self):
        self.Window = mayaui_New(cmds.window, 'WMS_PreviewOptionWindow', title=u'프리뷰 옵션')
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, 'MainLayout'):
                with mayaui_New(cmds.rowLayout, 'SizeRow', numberOfColumns=3):
                    cmds.text(label=u'프리뷰 크기')
                    w, h = mayaoption_load('WMS_Preview_Width', 864), mayaoption_load('WMS_Preview_Height', 486)
                    self.WidthTF = mayaui_New(cmds.textField, 'WidthField', text=str(w))
                    self.HeightTF = mayaui_New(cmds.textField, 'HeightField', text=str(h))
                with mayaui_New(cmds.rowLayout, 'ApplyRow', numberOfColumns=3):
                    cmds.button('Apply', label=u'적용', width=100, command=self.applyEv)
                    cmds.button('Close', label=u'닫기', width=100, command=self.closeEv)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def closeEv(self, _):
        self.close()

    def applyEv(self, _):
        '''프리뷰 설정을 마야 옵션 변수에 저장한다.'''
        cmds.evalDeferred(self.close)
        mayaoption_save('WMS_Preview_Width', int(self.WidthTF.query(text=True)))
        mayaoption_save('WMS_Preview_Height', int(self.HeightTF.query(text=True)))

class ImportWorkPrefWindow:
    '''작업 가져오기 설정 창'''
    def __init__(self):
        self.Window = mayaui_New(cmds.window, 'WMS_ImportWorkPrefWindow', title=u'임포트 옵션 창',  sizeable=False)
        cmds.window('WMS_ImportWorkPrefWindow', e=True,  width=120, height=80)
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, 'MainLayout', adj=True, adjustableColumn=2):
                self.UseNamespaceCB = mayaui_New(
                    cmds.checkBox, 'UseNamespace', l=u'네임스페이스 사용',
                    value=1-mayaoption_load('WMS_ImportWithoutNamespace', 0)
                )
                cmds.separator('sep', height=20, style='none')
                with mayaui_New(cmds.rowLayout, 'ButtonLayout', nc=2):
                    cmds.button('apply', l=u'적용', width=54, command=self.applyEv)
                    cmds.button('close', l=u'닫기',  width=54, command=self.closeEv)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def closeEv(self, _):
        self.close()

    def applyEv(self, _):
        '''가져오기 설정을 마야 옵션 변수에 저장한다.'''
        cmds.evalDeferred(self.close)
        ns = self.UseNamespaceCB.query(value=True)
        mayaoption_save('WMS_ImportWithoutNamespace', 1 - ns)

class NoteWorkWindow:
    '''작업 노트 작성 창'''
    def __init__(self, work, MainUI):
        self.work = work
        self.MainUI = MainUI

        self.Window = mayaui_New(cmds.window, 'NoteWorkWindow', title=u'작업 메모 작성', menuBar=True)
        self.Window.edit(width=200, height=170)
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, 'MainLayout', adj=True):
                cmds.text(l=u'작업 메모', font='fixedWidthFont')
                self.NoteField = mayaui_New(cmds.scrollField, 'NoteField', width=190, height=140)
                cmds.button(l=u'추가', c=self.applyEv)
                cmds.setFocus(self.NoteField.name)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def applyEv(self, _):
        '''작업 노트를 서버에 전달한다.'''
        cmds.evalDeferred(self.close)
        memo = self.NoteField.query(text=True)
        if not memo:
            noticeWindow(u'내용을 입력해야 합니다.')
            return
        info = [
            ('id', infoID(self.MainUI.loginAccount)),
            ('account', self.MainUI.loginAccount),
            ('label', u'요청 메모'),
            ('updated', time.strftime('%Y-%m-%d %H:%M:%S')),
            ('([TEXT])', memo),
        ]
        err = updateWork(self.work, '', infoText('note', info), self.MainUI.loginAccount, False)
        if err:
            noticeWindow(err)
            return
        noticeWindow(self.work.name+u' 작업에 메모가 추가되었습니다.')

class RequestWorkWindow:
    '''작업 요청 작성 창'''
    def __init__(self, work, MainUI):
        self.work = work
        self.MainUI = MainUI

        self.Window = mayaui_New(cmds.window, 'WMSRequestWindow', title=u'재작업 요청 작성', menuBar=True)
        self.Window.edit(width=200, height=170)
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, adj=True):
                cmds.text(l=u'요청 메모', font='fixedWidthFont')
                self.ProcessMenu = mayaui_New(cmds.optionMenuGrp, 'ProcessMenu', l=u'공정')
                cmds.menuItem('')
                for pl in ProcessOf[work.hostip][work.prjid].labels:
                    if pl not in [u'라이팅', u'렌더확인', u'맵핑']:
                        cmds.menuItem(pl)
                self.RequestField = mayaui_New(cmds.scrollField, 'RequestField',  width=190, height=140)
                self.ExplainText = mayaui_New(cmds.text, l='', width=200, height=35)

                def ProcessMenuChanged(_):
                    '''ProcessMenu가 변경되면 ExplainText의 내용을 고친다.'''
                    pcname = self.ProcessMenu.query(value=True)
                    if not pcname:
                        l = ''
                    else:
                        l = u'{0} 님에게 {1} 작업을\n수정해줄것을 요청합니다.'.format(self.work.worker, pcname)
                    self.ExplainText.edit(l=l)
                self.ProcessMenu.edit(changeCommand=ProcessMenuChanged)

                cmds.button(l=u'요청', command=self.applyEv)
                cmds.setFocus(self.RequestField.name)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def applyEv(self, _):
        '''작업 요청 메시지를 서버에 전달한다.'''
        cmds.evalDeferred(self.close)
        memo = self.RequestField.query(text=True)
        if not memo:
            noticeWindow(u'요청 사항을 써주세요.')
            return
        pcname = self.ProcessMenu.query(value=True)
        if pcname:
            pcid = ProcessOf[self.work.hostip][self.work.prjid].id(pcname)
        else:
            pcid = ''
        info = [
                ('id', infoID(self.MainUI.loginAccount)),
                ('account', self.MainUI.loginAccount),
                ('label', u'요청 메모'),
                ('updated', time.strftime('%Y-%m-%d %H:%M:%S')),
                ('request_process', pcid),
                ('([TEXT])', memo),
        ]
        err = updateWork(self.work, 'request', infoText('request', info), self.MainUI.loginAccount, False)
        if err:
            noticeWindow(err)
            return
        self.work.requestProcess = pcid
        noticeWindow(self.work.name+u' 작업에 요청 사항이 추가되었습니다.')
        self.MainUI.updateTable(self.work)

class ModifyWorkWindow:
    '''작업 수정사항 작성 창'''
    def __init__(self, work, MainUI):
        self.work = work
        self.MainUI = MainUI

        self.Window = mayaui_New(cmds.window, 'WMS_ModifyWindow', title=u'수정 사항 작성', menuBar=True)
        self.Window.edit(width=200, height=170)
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, adj=1):
                cmds.text(l=u'수정 사항', font='fixedWidthFont')
                self.ModifySF = mayaui_New(cmds.scrollField, 'ModifyField', width=190, height=140)
                cmds.button(l=u'수정', c=self.applyEv)
                cmds.setFocus(self.ModifySF.name)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def applyEv(self, _):
        '''작업 수정 메시지를 서버에 전달한다.'''
        cmds.evalDeferred(self.close)
        memo = self.ModifySF.query(text=True)
        if not memo:
            noticeWindow(u'수정하실 사항을 써주세요.')
            return
        info = [
                ('id', infoID(self.MainUI.loginAccount)),
                ('account', self.MainUI.loginAccount),
                ('label', u'요청 메모'),
                ('updated', time.strftime('%Y-%m-%d %H:%M:%S')),
                ('([TEXT])', memo),
        ]
        err = updateWork(self.work, 'modifying', infoText('request', info), self.MainUI.loginAccount, False)
        if err:
            noticeWindow(err)
        self.MainUI.updateTable(self.work)
        noticeWindow(self.work.name+u' 작업에 요청 사항이 추가되었습니다.')

class submitRenderWindow:
    '''렌더 창'''
    def __init__(self, work, MainUI):
        if (work.mb != mayascene_path()):
            noticeWindow(u'렌더하려고 하는 파일이 현재 열린 씬 파일이 아닙니다.')
            return
        if not os.path.exists(work.mb):
            noticeWindow(u'해당 파일이 없습니다.\n' + work.mb)
            return

        self.work = work
        self.MainUI = MainUI

        with mayaui_New(cmds.window, 'SubmitRenderWindow', title=u'렌더 서브밋 창', width=50, height=50) as self.Window:
            cmds.showWindow()

            MainLayout = mayaui_New(cmds.columnLayout, 'MainLayout', adj=True)
            with MainLayout:
                # 기본 옵션
                self.JobNameTFG = mayaui_New(cmds.textFieldGrp, 'jobname', l=u'이름', text=self.work.name)
                self.CommentTFG = mayaui_New(cmds.textFieldGrp, 'comment', l=u'코멘트')
                cmds.separator(height=20, style='in')

                # 그 외 옵션 1
                self.GroupOMG = mayaui_New(cmds.optionMenuGrp, 'group', l=u'그룹', changeCommand=partial(mayaoption_save,'deadlineGroupValue'))
                deadlinegroups = mayadeadline_groups()
                for g in deadlinegroups:
                    cmds.menuItem(l=g)
                try:
                    self.GroupOMG.edit(select=deadlinegroups.index(mayaoption_load('deadlineGroupValue', ''))+1)
                except ValueError:
                    # 데드라인 레포지터리에서 선택하려는 그룹이 사라진 경우 따로 설정하지 않음
                    pass
                self.PriorityISG = mayaui_New(
                    cmds.intSliderGrp, 'priority', l=u'중요도',
                    min=0, max=100, value=50,
                    field=True, fieldMinValue=0,
                )
                self.SuspendedCBG = mayaui_New(cmds.checkBoxGrp, 'suspended', l='', l1=u'대기 상태로 올리기')
                cmds.separator(height=20, style='in')

                # 그 외 옵션 2
                self.FramesTFG = mayaui_New(cmds.textFieldGrp, 'frames', l=u'프레임', text=mayascene_playbackRangeString())
                sf, ef = mayascene_animationRange()
                self.ChunksizeISG = mayaui_New(
                    cmds.intSliderGrp, 'chunksize', l=u'한번에 걸 프레임수',
                    min=1, max=ef-sf+1, value=mayaoption_load('deadlineChunkSize', 5),
                    field=True,
                    cc=partial(mayaoption_save, 'deadlineChunkSize'),
                )
                self.CameraOMG = mayaui_New(cmds.optionMenuGrp, 'camera', l=u'카메라')
                for c in mayascene_cameras():
                    cmds.menuItem(c)
                for i, v in enumerate(self.CameraOMG.query(itemListShort=True)):
                    if v.endswith('MS_CAMShape'):
                        self.CameraOMG.edit(select=i+1)
                        break
                self.MachineLimitISG = mayaui_New(
                    cmds.intSliderGrp, 'MachineLimit', l=u'렌더 댓수 제한',
                    min=0, max=100, value=0,
                    field=True,
                )
                cmds.separator(height=20, style='in')

                # 렌더 레이어 옵션
                self.UseLayerCBG = mayaui_New(
                    cmds.checkBoxGrp, 'usinglayer', l='',
                    l1=u'레이어 별로 렌더걸기', v1=mayaoption_load('deadlineUsingLayer', True),
                )
                self.LayerGroupCBG = mayaui_New(
                    cmds.checkBoxGrp, 'LayerGroupCheckBoxGrp', l=u'',
                    l1=u'렌더 그룹 재지정', v1=False,
                    enable=mayaoption_load('deadlineUsingLayer', True),
                )
                self.LayerGroupLayout = mayaui_New(cmds.scrollLayout, 'LayerGroupLayout', height=150)
                cmds.setParent("..")
                # 렌더 레이어 이벤트
                def toggleUseLayerEv(_):
                    '''`레이어 별로 렌더걸기` 옵션을 켜거나 끌 때 그 아래의 모든 ui를 켜거나 끈다.'''
                    v = self.UseLayerCBG.query(value1=True)
                    if v:
                        self.LayerGroupCBG.edit(enable=True)
                    else:
                        self.LayerGroupCBG.edit(enable=False)
                        self.LayerGroupCBG.edit(value1=False)
                        toggleLayerGroupEv(None)
                    mayaoption_save('deadlineUsingLayer', v)
                self.UseLayerCBG.edit(changeCommand=toggleUseLayerEv)
                def toggleLayerGroupEv(_):
                    '''`레이어 그룹 재지정`옵션을 켜거나 끄면 이하 모든 ui를 생성하거나 지운다.'''
                    v = self.LayerGroupCBG.query(value1=True)
                    if v:
                        cmds.setParent(self.LayerGroupLayout.name)
                        for rl in mayascene_enabledRenderLayers():
                            mayaui_New(cmds.optionMenuGrp, rl, l=rl)
                            cmds.menuItem(l=u'원래그룹')
                            for g in deadlinegroups:
                                cmds.menuItem(g)
                    else:
                        children = self.LayerGroupLayout.query(childArray=True)
                        if not children:
                            return
                        for c in children:
                            cmds.deleteUI(c)
                self.LayerGroupCBG.edit(changeCommand=toggleLayerGroupEv)
                cmds.separator(height=20, style='in')

                # 렌더 경로
                with mayaui_New(cmds.rowLayout, 'OutpathLayout', nc=5, adj=2):
                    cmds.text(l=u'렌더경로')
                    self.OutpathTF = mayaui_New(cmds.textField, 'outpath')
                    def setTestPathEv(_):
                        pth = '{0}/output/_test/{1}/{2}/{3}'.format(
                                RENDER_DRIVE, self.work.prj, self.work.episode, self.work.name
                        )
                        self.OutpathTF.edit(text=pth)
                    cmds.button(l=u'테스트', command=setTestPathEv)
                    def setFinalPathEv(_):
                        pth = '{0}/output/{1}/{2}/{3}'.format(
                                RENDER_DRIVE, self.work.prj, self.work.episode, self.work.name
                        )
                        self.OutpathTF.edit(text=pth)
                    cmds.button(l=u'파이널', command=setFinalPathEv)
                    def setCustomPathEv(_):
                        pths = cmds.fileDialog2(fileMode=2, okc=u'선택', dir=self.OutpathTF.query(text=True))
                        if pths:
                            self.OutpathTF.edit(text=pths[0])
                    cmds.button(l='...', command=setCustomPathEv)
                    # 기본 경로를 파이널 경로로 변경
                    setFinalPathEv(None)
                cmds.separator(height=20, style='in')

                # 렌더 버튼
                with mayaui_New(cmds.rowLayout, 'ButtonLayout', nc=2, adjustableColumn=2):
                    cmds.button('renderglobal', l=u'렌더 글로벌', command="mel.eval('unifiedRenderGlobalsWindow')")
                    cmds.button('submitjob', l=u'렌더 걸기',  command=self.applyEv)

    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

    def applyEv(self, _):
        ####################################
        #    렌더 서버로 ABC파일 전송 하는 구문
        ####################################
        # 로컬 / 서버 경로 
        localPathA = os.path.dirname(cmds.file(q=1, sn=1))#+'/.abc/'
        localPath = localPathA.replace('rendering', 'animation')
        localPath = localPath.replace('/','//')
        renderPathA = localPath.replace('D:', 'R:')
        locList = sorted(glob.glob(localPath+'//.abc//*.abc'))
        renList = sorted(glob.glob(renderPathA+'//.abc//*.abc'))

        #디렉토리가 있으면 파일 Copy작업 시작
        locL = []
        renAddList = []
        resultList = []
        for i in locList:
            locL.append(i.replace('D:','R:'))
        locLset = set(locL)
        addList = [x for x in locLset if x not in renList] #순서 보존됨
        for i in addList:
            renAddList.append(i)
        #디렉토리가 있으면 파일 Copy작업 시작
        if locList:
            if glob.glob(renderPathA+'//'):
                #렌더 서버 파일 
                if glob.glob(renderPathA+'//.abc//*.*'):
                    for abc in locList:
                        checkABC = abc.replace('D:', 'R:')
                        for r in renList:
                            if r == checkABC:
                                # 마지막 수정 시간 비교
                                LFInfo = time.ctime(os.path.getmtime(abc)) #Local file Information
                                RFInfo = time.ctime(os.path.getmtime(r)) #Render file Information
                                if str(LFInfo) != str(RFInfo):# File Last Update Compare
                                    resultList.append(r)
                else:
                    if glob.glob(renderPathA+'//.abc'):
                        locList = sorted(glob.glob(localPath+'//.abc//*.*'))
                        for abcFile in locList:
                            fileName = abcFile.split('\\')[-1]
                            renFile = abcFile.replace('D:', 'R:')
                            shutil.copy2(abcFile, renFile)
                            print fileName+u' [ 디렉토리 : 0 , 파일 : X ]'
                    else:
                        os.makedirs(renderPathA+'//.abc')
                        locList = sorted(glob.glob(localPath+'//.abc//*.*'))
                        for abcFile in locList:
                            fileName = abcFile.split('\\')[-1]
                            renFile = abcFile.replace('D:', 'R:')
                            shutil.copy2(abcFile, renFile)
                            print fileName+u' [ 디렉토리 : 0 , 파일 : X ]'
            else:
                os.makedirs(renderPathA+'//.abc')
                locList = sorted(glob.glob(localPath+'//.abc//*.*'))
                for abcFile in locList:
                    renFile = abcFile.replace('D:', 'R:')
                    shutil.copy2(abcFile, renFile)
                    print renFile + u' 디렉토리 생성 후 Copy [ 디렉토리 : X , 파일 : X ]'
        else:
            print "로컬에 ABC 파일이 없습니다."

        #추가 파일은 추가한다.
        if renAddList:
            for i in renAddList:
                shutil.copy2(i.replace('R:','D:'), i)
        #최종 파일 복사
        if resultList:
            for i in resultList:
                name = i.split('\\')[-1]
                shutil.copy2(i.replace('R:','D:'), i)
                print name + u" 최신 파일 업데이트."
        else:
            print u"모두 최신 파일 입니다."
        '''렌더를 건다.'''
        cmds.evalDeferred(self.close)
        if (self.work.mb != mayascene_path()):
            noticeWindow(u'렌더하려고 하는 파일이 현재 열린 씬 파일이 아닙니다.')
            return
        if not os.path.exists(self.work.mb):
            noticeWindow(u'파일이 없습니다.\n\n' + self.work.mb)
            return

        # 씬의 레퍼런스를 체크해 관리되지 않는 레퍼런스를 내 작업 디렉토리에 복사한다.
        invtex = {}
        for tex, nodes in mayascene_textures().iteritems():
            if re.match(LOCAL_ROOT, tex, re.I):
                continue
            if re.match(RENDER_DRIVE, tex, re.I):
                continue
            if not glob.glob(tex):
                continue
            invtex[tex] = nodes
        if invtex:
            sqs = [t for t in set(invtex) if '*' in t]
            fs = [t for t in set(invtex) if '*' not in t]
            cutSqs = sqs[:]
            if len(sqs) > 5:
                cutSqs = sqs[:5]+['...']
            cutFs = fs[:]
            if len(fs) > 5:
                cutFs = fs[:5]+['...']
            msg = u'{0}개의 시퀀스와 {1}개의 파일을 복사합니다.\n\n시퀀스\n{2}\n\n파일\n{3}'.format(
                len(sqs), len(fs), cutSqs, cutFs
            )
            ok = askWindow(msg, cancel=u'렌더취소')
            if not ok:
                return
            scenedir = os.path.dirname(self.work.mb)
            smgpath_make(scenedir+'/texture')
            copyTextures(invtex, dstd=scenedir+'/texture', linkToCopied=True)

        # 텍스쳐와 관련 자원들을 렌더 드라이브로 복사하고, 파일 노드의 경로를 렌더 드라이브로 변경한다.
        ok = copyRenderResourcesToRenderDrive()
        if not ok:
            return
        relinkTexturesToRenderDrive()

        if mayascene_modified():
            save = askWindow(u'저장되지 않은 작업이 있습니다.\n파일을 저장하시겠습니까?', cancel=u'렌더취소')
            if not save:
                return
            saveScene(mayascene_path(), 'render')

        # 텍스쳐 검사
        mistex = sorted(mayascene_missingTextures())
        if mistex:
            msg = u'{0}개의 텍스쳐 경로에 파일이 존재하지 않습니다. 계속하시겠습니까?\n'.format(len(mistex))
            if len(mistex) > 5:
                mistex = mistex[:5]+['...']
            msg += '\n'.join(mistex)
            ok = askWindow(msg)
            if not ok:
                return

        # 마야 씬 R드라이브로 익스포트
        ok = smgpath_make(renderPath(os.path.dirname(self.work.mb)))
        if not ok:
            raise RuntimeError(u'R 드라이브에 디렉토리를 만들수 없습니다.')
        mayascene_exportAll(renderPath(self.work.mb))

        # 데드라인 잡 서브밋
        layergroup = {}
        if self.LayerGroupCBG.query(value1=True):
            children = self.LayerGroupLayout.query(childArray=True)
            if children:
                for c in children:
                    v = cmds.optionMenuGrp(c, q=True, value=True)
                    if v != u'원래그룹':
                        layergroup[c] = v
        opts = {
            'scene' : renderPath(self.work.mb),
            'prjpath' : ''.join([RENDER_DRIVE, '/wms/pipeline/work/', self.work.prj]),
            'renderer' : mayascene_defaultRenderer(),
            'jobname' : self.JobNameTFG.query(text=True),
            'comment' : self.CommentTFG.query(text=True),
            'department' : self.MainUI.loginTeam,
            'group' : self.GroupOMG.query(value=True),
            'priority' : self.PriorityISG.query(value=True),
            'suspended' : self.SuspendedCBG.query(value1=True),
            'frames' : self.FramesTFG.query(text=True),
            'chunksize' : self.ChunksizeISG.query(value=True),
            'camera' : self.CameraOMG.query(value=True),
            'outpath' : self.OutpathTF.query(text=True),
            'machinelimit' : self.MachineLimitISG.query(value=True),
            'usinglayer' : self.UseLayerCBG.query(value1=True),
            'layergroup' : layergroup,
            'version' : cmds.about(version=True),
        }
        mayadeadline_jobSubmit(opts)

        # 작업 완료
        if self.MainUI is None:
            return

        # 레퍼런스 체크
        relrefs = makeRelativeReferences(self.work, getAllRefs())
        relrefnames = ','.join([os.path.splitext(os.path.basename(r))[0] for r in relrefs]) # 레퍼런스작업의 이름을 콤마로 묶음. 웹 작업정보 갱신에 쓰인다.

        # 파일 전송
        checknum = checkTime()
        saveWorkXML(self.work, checknum, relrefs)
        err = uploadWork(self.work, checknum)
        if err:
            noticeWindow(err)
            return

        # 작업 정보 전송
        infos = (
            [('name', 'framerate'), ('label', u'초당프레임'), ('([TEXT])', str(mayascene_frameRate())+' fps')],
            [('name', 'start_frame'), ('label', u'시작프레임'), ('([TEXT])', mayascene_animationStart())],
            [('name', 'end_frame'), ('label', u'종료프레임'), ('([TEXT])', mayascene_animationEnd())],
            [('name', 'frame'), ('label', u'프레임'), ('([TEXT])', mayascene_animationEnd()-mayascene_animationStart()+1)],
            [('name', 'asset'), ('label', u'에셋'), ('([TEXT])', relrefnames)],
        )
        it = ''
        for i in infos:
            it += infoText('information', i)
        err = updateWork(self.work, 'finished', it, self.MainUI.loginAccount, False)
        if err:
            noticeWindow(err)
            return
        noticeWindow(u'작업이 완료되었습니다.')
        self.MainUI.updateTable(self.work)

class ProgressWindow():
    def __init__(self, title, maxv):
        if maxv <= 0:
            raise ValueError("could not make progress window, maxv value is {0}, should greater than 0".format(maxv))
        self.Window = mayaui_New(
            cmds.window, 'WMSProgressWindow', title=title,
        )
        self.Window.edit(width=864, height=1)
        cmds.showWindow()
        with self.Window:
            with mayaui_New(cmds.columnLayout, adj=True):
                self.PgBar = mayaui_New(cmds.progressBar, max=maxv, progress=0)
        self.it = 0
        cmds.refresh(currentView=True)
    def advance(self, n):
        self.PgBar.edit(step=n)
        # 가끔씩 ui 강제 표시
        self.it += 1
        if self.it == 100:
            cmds.refresh(currentView=True)
            self.it = 0
    def close(self):
        cmds.deleteUI(self.Window.name, window=True)

# 로그인
# 이 함수는 login에 의해 호출된다.
def queryProjectInfo(account):
    '''서버에서 프로젝트 정보를 수집한다.'''
    global ProjectInfo, ProcessOf
    resp = smgweb_post(
        WMS_HOST,
        '/wms/app/pipeline/script/check_db.php',
        {
            'session_account':account,
            'remote':'1',
        }
    )

    rootEl = ET.XML(resp)
    for tag in ['project', 'remote_project']:
        for el in rootEl.getiterator(tag):
            # 호스트와 호스트IP를 찾는다.
            host = ''
            hostip = WMS_HOST
            if tag == 'remote_project':
                host = el.get('host')
                hostip = hostIP(host, account)

            if hostip not in ProcessOf:
                ProjectInfo[hostip] = {}
                ProcessOf[hostip] = {}

            # 각 호스트->프로젝트 별 프로젝트 정보를 저장한다.
            for tableEl in el.getiterator('table'):
                if tableEl.get('pipeline_type') not in ['asset', 'shot']:
                    continue

                prjid = tableEl.get('name')
                prj = tableEl.find('name').find('project_name').text
                prjtype = tableEl.find('name').find('pipeline_name').text

                ProjectInfo[hostip][prjid] = (host, prj, prjtype)
                ProcessOf[hostip][prjid] = NamePair([])
                pids = tableEl.find('order').find('process').find('id').text.split(',')
                plbs = tableEl.find('order').find('process').find('name').text.split(',')
                for i, l in zip(pids, plbs):
                    ProcessOf[hostip][prjid].append((i, l))

def hostIP(host, account):
    if not host:
        return WMS_HOST
    resp = smgweb_post(
        WMS_HOST,
        '/wms/script/get_host_info.php',
        {
            'host':host,
            'account':account,
        }
    )
    rootEl = ET.XML(resp)
    if rootEl.find('error') is not None:
        raise RuntimeError('failed to get host information.')
    if rootEl.find('host') is None:
        raise RuntimeError('failed to get host information.')
    return rootEl.find('host').attrib['ip']

def webInfo(w):
    '''웹을 띄워 해당 작업의 정보를 본다.'''
    smgpath_openUp('"http://{0}/wms/app/pipeline/process_info.html?pid={1}&wid={2}"'.format(w.hostip, w.prjid, w.wid))

def openWorkDir(w):
    '''해당 작업 폴더를 연다.'''
    smgpath_make(w.dir)
    smgpath_openUp(w.dir)

def openWork(w):
    '''해당 작업을 연다.'''
    '''
    #   07.20.22 -->
    #texture directory remove
    import shutil
    nowPath = cmds.file(q=True, sceneName=True)
    nowPathSplit = nowPath.split('/')
    removePath = nowPath.replace(nowPathSplit[-1], 'texture')
    if glob.glob(removePath+'//'):
        shutil.rmtree(removePath, ignore_errors=False)
        print 'texture directory remove'
    #   07.20.22<--
    '''
    # 1.0.0 텍스쳐 퀄리티 원본으로 변경 코드 제거
    # 현재 씬 저장
    cmds.file(q=True, sceneName=True)
    if mayascene_modified():
        answer = selectionWindow(u'현재 작업이 저장되지 않았습니다.', title=u'작업 열기', items=[u'그냥 열기', u'저장하고 열기'])
        if not answer:
            return
        if answer == u'저장하고 열기':
            saveScene(mayascene_path(), 'save')

    mayascene_new() # 2017-01-13 다운로드 된 파일로 덮어쓰기가 안되는 문제 수정
    
    # 작업을 연다. 로컬, 서버에 모두 작업 파일이 없을 때는 새 작업을 생성한다.
    # 리깅, 렌더링, fx의 경우 이전 프로세스에서 작업을 가져올 수 있다.
    downloadWorks = downloadRelatedWorks(w)
    if w.process == 'lighting' or w.process == 'rendering':
        stW = workFromPath(w.path.replace('/'+w.process+'/', '/stereoscopic/'), WMS_HOST)
        chk = checkVersion(stW)
        if chk < 2 and chk != 0:
            downloadWork(stW)

    if os.path.exists(w.mb):
        mayascene_load(w.mb)
    else:
        prior = {'rigging':'modeling', 'rendering':'animation', 'lighting':'animation', 'fx':'animation'}
        if w.process not in prior:
            newWork(w)
        else:
            answer = selectionWindow(u'작업이 없습니다. 이전 공정의 작업을 가져오시겠습니까?', title=u'이전 공정 작업 열기', items=[u'가져오기', u'새로 시작'])
            if answer == u'새로 시작':
                newWork(w)
            elif answer == u'가져오기':
                priormb = w.mb.replace('/'+w.process+'/', '/'+prior[w.process]+'/')
                storageIP = projectStorageIP(w.hostip, w.prjid) # 2017-01-12 스토리지 분리
                storageIP = storageIP.replace(':80', '')
                downloadWorks.extend(downloadRelatedWorks(workFromPath(priormb, storageIP)))

                if not os.path.isfile(priormb):
                    noticeWindow(u'이전공정의 작업이 없습니다. 새 씬을 만듭니다.')
                    newWork(w)
                else:
                    mayascene_load(priormb)
                    saveScene(w.mb, 'priorwork')
            else:
                return
    toWireframeMode()# 1.0.0
    linkOriginalTexture(LOCAL_ROOT)# 1.0.0
    
    if w.process == 'animation':
        # 마스터 카메라 로드
        if not cmds.ls('MS_CAM*', recursive=True):
            try:
                mayascene_embed(LOCAL_ROOT+'/scripts/process/animation/MS_CAM.mb')
            except:
                messageprint(u'마스터 카메라를 가져오려 했으나 실패했습니다.')

        for w in checkRefWorks(w):
            convertToLowTexture(w)

        linkLowTexture(LOCAL_ROOT)

    elif w.process == 'stereoscopic':
        stereoscopicTool()
        #updateShaders()#일시변경 수동으로 사용요구

    elif w.process == 'simulation':
        #downloadRefWorks(workFromPath(mayascene_path().replace('/simulation/', '/animation/'), w.hostip), 'hair')
        updateHairs()

    elif w.process == 'lighting' or w.process == 'rendering':
        stCamPath = w.mb.replace('/lighting/', '/stereoscopic/').replace('/rendering/', '/stereoscopic/').replace('.mb', '_CAM.mb')
        if not cmds.ls('R*:S_cam') and os.path.isfile(stCamPath):
            mayascene_reference(stCamPath, namespace='R')
        #updateShaders()#일시변경 수동으로 사용요구
        
    elif w.process == 'shading' or w.process == 'mapping':
        saveUVSnapshot()

    elif w.process == 'hair':
        modFile = w.mb.replace('/'+w.process+'/', '/modeling/')

        checkModRef = False
        for ref in cmds.file(q=True, reference=True):
            if ref.count(modFile.split('/modeling/')[-1]):
                checkModRef = True
                break

        if not checkModRef:
            modW = workFromPath(w.path.replace('/'+w.process+'/', '/modeling/'), WMS_HOST)
            chk = checkVersion(modW)
            if chk < 2 and chk != 0:
                downloadWork(modW)

            if os.path.isfile(modFile):
                mayascene_reference(modFile, namespace='R')
            else:
                messageprint(u'모델링 작업을 찾을 수 없어 레퍼런스를 불러오기를 건너뜁니다.')

    if w.prjtype == 'shot':
        if w.process != 'animation':
            openAbc(w, True)

        resp = smgweb_post(
            w.hostip,
            '/wms/app/pipeline/script/process_info.php',
            {
                'project_id' : w.prjid,
                'wid' : 'base__' + w.name
            }
        )

        root = ET.XML(resp)
        infoEls = root.getiterator("information")

        fps = 0
        startFrame = START_FRAME# 1.0.1
        endFrame = startFrame + extraFrames# 1.0.1

        for el in infoEls:
            if str(el.get('name')).lower() == 'start_frame':
                if el.text:
                    startFrame = float(el.text)

            elif str(el.get('name')).lower() == 'end_frame':
                if el.text:
                    endFrame = float(el.text)

            elif str(el.get('name')).lower() == 'frame':
                frame = float(el.text)+startFrame-1
                if  frame != endFrame:
                    endFrame = frame

            elif str(el.get('name')).lower() == 'fps' or str(el.get('name')).lower() == 'framerate':
                if el.text:
                    fps= int(int(filter(str.isdigit, el.text)))

        if fps:
            mayascene_setFrameRate(fps)
        cmds.playbackOptions(ast=startFrame, aet=endFrame)
        cmds.playbackOptions(min=startFrame, max=endFrame)

    # 텍스쳐 갱신
    if w.prjtype == 'shot' or w.process == 'rigging':
        wd = w.dir + '/texture'
        rd = RENDER_DRIVE + '/texture/' + w.prj
        for d, _, files in os.walk(wd):
            for f in files:
                wf = d+'/'+f
                rf = wf.replace(wd, rd)
                if os.path.isfile(rf) and (filecmp.cmp(rf, wf) is False):
                    if os.stat(rf).st_size < 100: # 파일 크기가 100바이트 아래면
                        debugprint(u'{f} 가 있지만 파일이 의심스러워 갱신하지 않았습니다.'.format(f=f))
                        continue
                    shutil.copyfile(rf, wf)
                    messageprint(u'{f} 가 갱신되었습니다.'.format(f=f))

def stereoscopicTool():
    mel.eval('source "'+LOCAL_ROOT+'/scripts/process/stereoscopic/threeDCameraSetupSingle.mel";')
    mel.eval('if ( !`window -exists "stereoCameraSetup"` ) threeDCameraSetupSingle();')

def offProxyLow():
    refFileList = cmds.file(q=True, reference=True)
    for refFile in refFileList:
        if refFile.count('_PRX'):
            refNs = cmds.referenceQuery(refFile, namespace=True, shortName=True)
            if refNs:
                lowAttr = refNs+':World_Ctrl.Low'
                if cmds.ls(lowAttr):
                    lowAttrSrc = cmds.connectionInfo(lowAttr, sourceFromDestination=True)
                    if lowAttrSrc:
                        cmds.disconnectAttr(lowAttrSrc, lowAttr)

                    cmds.setAttr(lowAttr, 0)

hairVerDict = None
def updateHairs():
    snPath = cmds.file(q=True, sn=True)
    if not snPath:
        messageprint(u'씬을 새 이름으로 저장한 후 다시 시도해주십시오.')
        return

    global hairVerDict
    hairVerDict = hairVerDict = { 'name':[], 'checknum':[] }

    assetFileDict = {}
    for ref in cmds.file(q=True, reference=True):
        refNs = cmds.referenceQuery(ref, namespace=True, shortName=True)
        if refNs:
            assetFileDict[ref] = refNs

    aniXmlPath = snPath.replace('/simulation/', '/animation/').replace('.mb', '.xml').replace('.ma', '.xml')
    if os.path.isfile(aniXmlPath):
        aniRoot = ET.parse(aniXmlPath)
        for refTag in aniRoot.findall('reference'):
            if refTag.attrib.keys().count('top_node') and refTag.attrib.keys().count('resolved_name'):
                assetFileDict[refTag.attrib['resolved_name']] = refTag.attrib['top_node'].split('|')[-1].split(':')[0]

    if assetFileDict.keys():
        snHairVers = {'name':[], 'checknum':[]}
        snXmlPath = snPath.replace('.mb', '.xml').replace('.ma', '.xml')
        if os.path.isfile(snXmlPath):
            snRoot = ET.parse(snXmlPath)
            for snHair in snRoot.findall('hair'):
                snHairVers['name'].append(snHair.attrib['name'])
                snHairVers['checknum'].append(snHair.attrib['checknum'])

        for assetFile in assetFileDict.keys():
            if assetFile.count('_PRX.'):
                messageprint(assetFile.split('/')[-1]+u' 에셋은 렌더 프록시가 적용되어 건너뜁니다.')
                continue

            try:
                hairW = workFromPath(assetFile.replace('/rigging/', '/hair/').split('{')[0], WMS_HOST)
                chk = checkVersion(hairW)
                if chk < 2 and chk != 0:
                    downloadWork(hairW)
            except:
                pass

            stripPath = assetFile.replace('/rigging/', '/hair/').split('{')[0].replace('_LOW.', '.').replace('.mb', '').replace('.ma', '')
            stripName = stripPath.split('/')[-1]
            xmlPath = stripPath+'.xml'

            if not os.path.isfile(xmlPath):
                #messageprint(stripName+u' 헤어 정보가 존재하지 않아 건너뜁니다.')
                continue

            root = ET.parse(xmlPath)
            checknum = root.find('information').attrib['checknum']

            try:
                if not stripName in hairVerDict['name']:
                    hairVerDict['name'].append(stripName)
                    hairVerDict['checknum'].append(checknum)
            except: pass

            snHairNameIndex = None
            try: snHairNameIndex = snHairVers['name'].index(stripName)
            except: pass

            snChecknum = None
            if snHairNameIndex != None:
                try: snChecknum = snHairVers['checknum'][snHairNameIndex]
                except: pass

            hairNamespace = 'H'+assetFileDict[assetFile][1:]
            if os.path.isfile(stripPath+'.mb') and snChecknum != checknum or not (cmds.ls(hairNamespace+':*_hairGeo')+cmds.ls(hairNamespace+':*_scalpGeo')):
                if cmds.namespace(exists=hairNamespace):
                    try: cmds.namespace(force=True, deleteNamespaceContent=True, removeNamespace=hairNamespace)
                    except: pass

                mayascene_embed(stripPath+'.mb', namespace=hairNamespace)

                hairGeoList = cmds.ls(hairNamespace+':*_hairGeo')+cmds.ls(hairNamespace+':*_scalpGeo')
                if hairGeoList:
                    for hairGeo in hairGeoList:
                        if cmds.ls('R'+hairGeo[1:]):
                            cmds.blendShape('R'+hairGeo[1:], hairGeo, weight=(0,1))
                        else:
                            messageprint('R'+hairGeo[1:]+u' 헤어 지오메트리가 존재하지 않습니다.')

            else:
                messageprint(stripName+u' 헤어는 이미 최신 버전입니다.')

    else:
        messageprint(u'헤어를 업데이트 할 에셋이 없습니다.')

shdVerDict = None
def updateShaders():
    global shdVerDict
    checkUpdateSHD = 0
    snPath = cmds.file(q=True, sn=True)
    if not snPath:
        messageprint(u'씬을 새 이름으로 저장한 후 다시 시도해주십시오.')
        return
    
    shdVerDict = { 'name':[], 'checknum':[] }

    support = True
    assetFileList = cmds.file(q=True, reference=True, withoutCopyNumber=True)
    if snPath.count('/shot/') and (snPath.count('/lighting/') or snPath.count('/rendering/') or snPath.count('/simulation/') or snPath.count('/stereoscopic/')):
        aniXmlPath = snPath.replace('/lighting/', '/animation/').replace('/rendering/', '/animation/').replace('/simulation/', '/animation/').replace('/stereoscopic/', '/animation/').replace('.mb', '.xml').replace('.ma', '.xml')
        if os.path.isfile(aniXmlPath):
            aniRoot = ET.parse(aniXmlPath)
            for refTag in aniRoot.findall('reference'):
                assetFileList.append(os.path.dirname(cmds.workspace(q=True, fullName=True))+'/'+refTag.attrib['path'])

        else:
            support = False

    elif snPath.count('/asset/'):
        assetFileList.append(snPath)

    else:
        support = False

    if not support:
        messageprint(u'쉐이더 업데이트는 라이팅, 렌더링, 시뮬레이션, 스테레오스코픽과 에셋만 지원됩니다.')
        return

    if assetFileList:
        assetFileList = list(set(assetFileList))
        proxyList = []
        refFileList = cmds.file(q=True, reference=True)
        if refFileList:
            for refFile in refFileList:
                refName = os.path.basename(refFile.split('{')[0])
                if refFile.count('_PRX.'):
                    proxyList.append(refName.replace('_PRX.', '.'))

                else:
                    if snPath.count('/lighting/') or snPath.count('/rendering/'):
                        proxyPath = refFile.split('{')[0].replace('/rigging/', '/shading/').replace('_LOW.', '.').replace('.ma', '_PRX.ma').replace('.mb', '_PRX.mb')
                        if os.path.isfile(proxyPath):
                            proxyList.append(os.path.basename(proxyPath.replace('_PRX.', '.')))
                            cmds.file(proxyPath, lr=cmds.file(refFile, q=True, rfn=True))
                            messageprint(os.path.basename(refFile).split('{')[0]+u' 파일은 렌더 프록시로 대체되어 쉐이더 업데이트에서 제외됩니다.')

        proxyList = list(set(proxyList))

        snShdVers = {'name':[], 'checknum':[]}
        snXmlPath = snPath.replace('.mb', '.xml').replace('.ma', '.xml')
        if os.path.isfile(snXmlPath):
            snRoot = ET.parse(snXmlPath)
            for snShd in snRoot.findall('shader'):
                snShdVers['name'].append(snShd.attrib['name'])
                snShdVers['checknum'].append(snShd.attrib['checknum'])

        for assetFile in assetFileList:
            if not assetFile.count(LOCAL_ROOT):
                messageprint(assetFile.split('/')[-1]+u' 에셋은 지원되지 않는 에셋입니다.')
                continue

            if assetFile.count('_PRX.') or proxyList.count(os.path.basename(assetFile)):
                messageprint(assetFile.split('/')[-1]+u' 에셋은 렌더 프록시가 적용되어 건너뜁니다.')
                continue

            pathForWork = assetFile.replace('_LOW.', '.')
            if not snPath.count('/shot/') or snPath.count('/lighting/') or snPath.count('/rendering/'):
                pathForWork = assetFile.replace('/rigging/', '/shading/').replace('_LOW.', '.')

            try:
                aw = workFromPath(pathForWork, WMS_HOST)
                chk = checkVersion(aw)
                if chk < 2 and chk != 0:
                    downloadWork(aw)
                    downloadWork(aw)
            except:
                #pass #2017-01-03
                messageprint(pathForWork, u'쉐이더 다운로드 실패') #2017-01-03
            
            stripPath = pathForWork.replace('.mb', '').replace('.ma', '')
            print stripPath
            stripName = stripPath.split('/')[-1]
            shdPath = stripPath+'_SHD.mb'
            uvPath = stripPath+'_UV.mb'
            xmlPath = stripPath+'.xml'

            if not os.path.isfile(xmlPath) or not os.path.isfile(shdPath):
                messageprint(stripName+u' 쉐이딩 정보가 존재하지 않아 건너뜁니다.')
                continue

            root = ET.parse(xmlPath)
            checknum = root.find('information').attrib['checknum']

            if snPath.count('/shot/'):
                try:
                    if not stripName in shdVerDict['name']:
                        shdVerDict['name'].append(stripName)
                        shdVerDict['checknum'].append(checknum)
                except: pass

                snShdNameIndex = None
                try: snShdNameIndex = snShdVers['name'].index(stripName)
                except: pass

                snChecknum = None
                if snShdNameIndex != None:
                    try: snChecknum = snShdVers['checknum'][snShdNameIndex]
                    except: pass
                    #if snChecknum != checknum:
                    #    print stripName, snShdVers['checknum'][snShdNameIndex], checknum, snShdNameIndex
                #continue
                matTags = []
                for matTag in root.findall('material'):
                    sgName = matTag.attrib['name']
                    if 'shading_engine' in matTag.attrib:# 쉐이딩엔진 이름이 name에 저장되어 있는 구버전에 대한 검사. 현재는 머티리얼 이름.
                        sgName = matTag.attrib['shading_engine']
                    if not matTags.count(sgName) and sgName != 'initialShadingGroup':
                        matTags.append(sgName)

                shdNamespace = stripName+'_SHD'

                sgList = []
                if cmds.namespace(exists=shdNamespace):
                    nsInfo = cmds.namespaceInfo(shdNamespace, listOnlyDependencyNodes=True, fullName=True, dagPath=True, recurse=True)
                    if nsInfo:
                        for nsNode in nsInfo:
                            if cmds.nodeType(nsNode) == 'shadingEngine':
                                sgList.append(nsNode)
                
                if True: #os.path.isfile(shdPath) and (len(matTags) != len(sgList) or snChecknum != checknum): #2017-01-03
                    try: cmds.namespace(force=True, deleteNamespaceContent=True, removeNamespace=shdNamespace)
                    except: pass
                    cmds.file(shdPath, i=True, namespace=shdNamespace, renameAll=True, mergeNamespacesOnClash=False)

                    for matTag in root.findall('material'):
                        sgName = matTag.attrib['name']
                        if 'shading_engine' in matTag.attrib:# 쉐이딩엔진 이름이 name에 저장되어 있는 구버전에 대한 검사. 현재는 머티리얼 이름.
                            sgName = matTag.attrib['shading_engine']
                        if sgName == 'initialShadingGroup':
                            continue
                        
                        try:
                            importedGeoList = cmds.ls('*'+matTag.attrib['assigned'], long=True)
                            refGeo = matTag.attrib['assigned'].replace('|', '|*:')[1:]
                            refGeoList = cmds.ls(refGeo, long=True)
                            refGeoDeformedList = cmds.ls('|'.join(refGeo.split('|')[:-1])+'|'+refGeo.split(':')[-1]+'Deformed*', long=True)
                            lowRefGeoList = cmds.ls(matTag.attrib['assigned'].replace('|', '|*:')[1:].replace(':Low_Grp|', '**:*_LOW|').split('|**')[-1], long=True)
                            geoList = importedGeoList + refGeoList + refGeoDeformedList + lowRefGeoList
                            for geo in geoList:
                                #messageprint(shdNamespace.replace('_SHD', '')+u' 머티리얼 적용: '+geo)
                                if cmds.referenceQuery(geo, isNodeReferenced=True) and (snPath.count('/simulation/') or snPath.count('/stereoscopic/')):
                                    continue

                                cmds.select(geo, replace=True)
                                cmds.sets(e=True, forceElement=shdNamespace+':'+sgName)

                                try:
                                    geoSplit = geo.split('.')
                                    if len(geoSplit) < 2:
                                        geoSplit = [geo]
                                    for uvsetTag in matTag.findall('uvset'):
                                        for uvTex in uvsetTag.attrib['texture'].split(','):
                                            cmds.uvLink(uvSet=geoSplit[0]+'.uvSet['+uvsetTag.attrib['index']+'].uvSetName', texture=shdNamespace+':'+uvTex)
                                    checkUpdateSHD = 1
                                except:
                                    messageprint(u'UV Set 적용 실패: '+geoSplit[0])
                        except:
                            messageprint(u'머티리얼 적용 실패: '+shdNamespace+':'+sgName+' -> '+geo)
                            pass
                    messageprint(shdNamespace.replace('_SHD', '')+u' 머티리얼들이 갱신되었습니다.')
            else:
                try: cmds.delete(cmds.ls(type='shadingEngine') + cmds.ls(mat=True))
                except: pass
                mel.eval('MLdeleteUnused;')

                cmds.file(shdPath, i=True, mergeNamespacesOnClash=True, namespace=':')

                for matTag in root.findall('material'):
                    sgName = matTag.attrib['name']
                    if 'shading_engine' in matTag.attrib:# 쉐이딩엔진 이름이 name에 저장되어 있는 구버전에 대한 검사. 현재는 머티리얼 이름.
                        sgName = matTag.attrib['shading_engine']
                    if sgName == 'initialShadingGroup':
                        continue

                    try:
                        importedGeoList = cmds.ls('*'+matTag.attrib['assigned'], long=True)
                        refGeo = matTag.attrib['assigned'].replace('|', '|*:')[1:]
                        refGeoList = cmds.ls(refGeo, long=True)
                        refGeoDeformedList = cmds.ls('|'.join(refGeo.split('|')[:-1])+'|'+refGeo.split(':')[-1]+'Deformed*', long=True)
                        lowRefGeoList = cmds.ls(matTag.attrib['assigned'].replace('|', '|*:')[1:].replace(':Low_Grp|', '**:*_LOW|').split('|**')[-1], long=True)
                        geoList = importedGeoList + refGeoList + refGeoDeformedList + lowRefGeoList
                        for geo in geoList:
                            cmds.select(geo, replace=True)
                            cmds.sets(e=True, forceElement=sgName)
                            try:
                                geoSplit = geo.split('.')
                                if len(geoSplit) < 2:
                                    geoSplit = [geo]
                                for uvsetTag in matTag.findall('uvset'):
                                    for uvTex in uvsetTag.attrib['texture'].split(','):
                                        cmds.uvLink(uvSet=geoSplit[0]+'.uvSet['+uvsetTag.attrib['index']+'].uvSetName', texture=uvTex)
                                    checkUpdateSHD = 1
                            except:
                                messageprint(u'UV Set 적용 실패: '+geoSplit[0])

                    except:
                        messageprint(u'머티리얼 적용 실패: '+sgName+' -> '+geo)

                messageprint(u' 머티리얼들이 갱신되었습니다.')
            if os.path.isfile(uvPath):
                uvNamespace = stripName+'_UV'
                try: cmds.namespace(force=True, deleteNamespaceContent=True, removeNamespace=uvNamespace)
                except: pass
                cmds.file(uvPath, i=True, namespace=uvNamespace, renameAll=True, mergeNamespacesOnClash=False)
                try: cmds.select('|'+uvNamespace+':UVTransfer', hierarchy=True, replace=True)
                except: pass
                uvUpdates = cmds.ls(selection=True, long=True, geometry=True)
                for uvUpdate in uvUpdates:
                    uvOrig = uvUpdate.replace('|'+uvNamespace+':', '|').replace('|UVTransfer', '').replace('|UV_', '|').replace('_oo_', ':')
                    for geo in cmds.ls('*'+uvOrig)+cmds.ls(uvOrig.replace('|', '|*:')[1:]):
                        geoSrc = cmds.listConnections(geo, d=0)
                        if geoSrc:
                            for conn in geoSrc:
                                if conn.count('transferAttributes'):
                                    cmds.delete(conn)
                        cmds.select(cmds.listRelatives(uvUpdate, parent=True, fullPath=True)+cmds.listRelatives(geo, parent=True, fullPath=True), replace=True)
                        try: mel.eval('transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 4 -searchMethod 3 -flipUVs 0 -colorBorders 1;')
                        except: messageprint(uvNamespace+u' UV 업데이트가 실패됐습니다.')
                        
        if checkUpdateSHD:
            # 1.0.1 --> restore shading network bake
            aniDir = os.path.dirname(cmds.file(q=1, sn=1)).replace('/rendering/', '/animation/').replace('/lighting/', '/animation/').replace('/simulation/', '/animation/')+'/'
            matKeyPath = aniDir+'SHD_ANI.json'

            try:
                fd = open(matKeyPath, 'r')
                jsonString = fd.read()
                fd.close()
                animDict = json.loads(jsonString)
                minTime = cmds.playbackOptions(q=True, min=True)
                maxTime = cmds.playbackOptions(q=True, max=True)
                for currFrame in range(int(minTime), int(maxTime+1)):
                    #print currFrame, currFrame-int(minTime)
                    for animAttr in animDict.keys():
                        attrName = cmds.ls('*_SHD:'+animAttr, '*_SHD:'+animAttr.replace(':', '_'), '*_SHD:'+animAttr.split(':')[-1])
                        if len(attrName) < 1:
                            print animAttr, ' does not exist'
                            continue
                            
                        try:
                            idx = currFrame-int(minTime)
                            cmds.setAttr(attrName[0], animDict[animAttr][idx])
                            cmds.setKeyframe(attrName[0], time=currFrame)
                            '''
                            if idx == 0 or idx == len(animDict[animAttr]):
                                cmds.setAttr(attrName[0], animDict[animAttr][idx])
                                cmds.setKeyframe(attrName[0], time=currFrame)
                                #print attrName, 'setKey', currFrame
                                
                            elif idx < len(animDict[animAttr]):
                                if animDict[animAttr][idx] != animDict[animAttr][idx+1] or animDict[animAttr][idx] != animDict[animAttr][idx-1]:
                                    cmds.setAttr(attrName[0], animDict[animAttr][idx])
                                    cmds.setKeyframe(attrName[0], time=currFrame)
                                    #print attrName, 'setKey', currFrame
                            '''
                        except:
                            pass
                                    
            except: 
                messageprint(u'쉐이더 베이크 복원 실패.')
            # 1.0.1 <--
            
            noticeWindow(u'쉐이더 업데이트를 완료되었습니다.')
            
    else:
        messageprint(u'쉐이더를 업데이트 할 에셋이 없습니다.')

    proxyExists = False
    for ref in cmds.file(q=True, reference=True):
        if ref.count('_PRX.'):
            proxyExists = True
            break

    if proxyExists:
        offProxyLow()

def mergeReferences(shader=True):
    timestamp = time.strftime('%Y%m%d_%H%M%S')
    snPath = cmds.file(q=1, sn=1)
    if snPath:
        snDir = os.path.dirname(snPath)
        snFile = os.path.basename(snPath)
        bakPath = snDir+'/.save/'+snFile.replace('.ma', '__'+timestamp+'.ref.ma').replace('.mb', '__'+timestamp+'.ref.mb')
        cmds.file(bakPath, force=True, type='mayaBinary', exportAll=True)

    while 1:
      refFiles = cmds.file(q=True, reference=True)
      if not refFiles: break
      for refFile in refFiles:
        if not cmds.referenceQuery(refFile, isLoaded=True):
          cmds.file(refFile, removeReference=True)
        else:
          cmds.file(refFile, importReference=True)

    if shader:
        shdEngList = []
        objList = []
        uvSetDict = {}
        for shdEng in cmds.ls(type='shadingEngine'):
          assignedList = cmds.sets(shdEng, q=True)
          if assignedList:
            currObjList = []
            for assigned in assignedList:
              strippedName = assigned.split(':')[-1]
              assignedSplit = assigned.split('.')
              if len(assignedSplit) > 1:
                strippedName = assignedSplit[0].split(':')[-1]+'.'+assignedSplit[-1]

              currObjList.append(strippedName)

              if cmds.nodeType(assignedSplit[0]) == 'mesh':
                uvSetInds = cmds.polyUVSet(assignedSplit[0], query=True, allUVSetsIndices=True)
                if uvSetInds != None and len(uvSetInds) > 1:
                  for uvSetInd in uvSetInds[1:]:
                    uvSetTex = cmds.uvLink(query=True, uvSet=assignedSplit[0]+'.uvSet['+str(uvSetInd)+'].uvSetName')
                    uvSetKey = strippedName.split('.')[0]+'.uvSet['+str(uvSetInd)+'].uvSetName'
                    if not uvSetDict.keys().count(uvSetKey) and uvSetTex:
                      uvSetDict[uvSetKey] = uvSetTex

            currObjList.sort()
            currObjList = list(set(currObjList))
            currObjStr = ';'.join(currObjList)

            if not objList or not objList.count(currObjStr):
              shdEngList.append(shdEng)
              objList.append(currObjStr)

            else:
              existShdEng = shdEngList[objList.index(currObjStr)]
              if existShdEng.split(':')[-1] == shdEng.split(':')[-1]:
                for assigned in assignedList:
                  try:
                    cmds.select(assigned, replace=True)
                    cmds.sets(e=True, forceElement=existShdEng)

                    strippedName = assigned.split(':')[-1]
                    assignedSplit = assigned.split('.')
                    if len(assignedSplit) > 1:
                      strippedName = assignedSplit[0].split(':')[-1]+'.'+assignedSplit[-1]

                    if cmds.nodeType(assignedSplit[0]) == 'mesh':
                      uvSetInds = cmds.polyUVSet(assignedSplit[0], query=True, allUVSetsIndices=True)
                      if uvSetInds != None and len(uvSetInds) > 1:
                        for uvSetInd in uvSetInds[1:]:
                          uvSetKey = strippedName.split('.')[0]+'.uvSet['+str(uvSetInd)+'].uvSetName'
                          if uvSetDict.keys().count(uvSetKey):
                            for uvSetTex in uvSetDict[uvSetKey]:
                               cmds.uvLink(uvSet=assignedSplit[0]+'.uvSet['+str(uvSetInd)+'].uvSetName', texture=uvSetTex)

                  except:
                    warningprint('Assign Failed: '+existShdEng+' -> '+assigned)

                if shdEng:
                    cmds.delete(shdEng)

        mel.eval('MLdeleteUnused;')

    nsNodeList = cmds.ls(('*:*', '*:*:*', '*:*:*:*', '*:*:*:*:*', '*:*:*:*:*:*', '*:*:*:*:*:*:*', '*:*:*:*:*:*:*:*', '*:*:*:*:*:*:*:*:*', '*:*:*:*:*:*:*:*:*:*'), long=True)
    if nsNodeList:
        nsNodeList.sort(key=len, reverse=True)
        for nsNode in nsNodeList:
            try: cmds.rename(nsNode, nsNode.split('|')[-1].split(':')[-1])
            except: print nsNode.split('|')[-1], 'Rename failed'

def extractLow():
    snPath = cmds.file(q=1, sn=1)
    if not snPath:
        messageprint(u'이름 없는 씬은 Low 추출을 지원하지 않아 건너뜁니다.')
        return

    if snPath.count('_LOW.'):
        messageprint(u'Low 씬은 추출할 수 없습니다.')
        return

    worldCtrlLowList = cmds.ls('World_Ctrl.Low')
    if not worldCtrlLowList:
        return

    for lowAttr in worldCtrlLowList:
        cmds.setAttr(lowAttr, 1)

    for check in cmds.ls(('World_Ctrl', 'Move_Ctrl', 'Mod_Box', 'Rig_Box', 'Mod_Grp', 'Rig_Grp'), long=True):
        if not cmds.ls(check):
            continue

        rigSysList = cmds.ls('RigSys*')
        if rigSysList: cmds.delete(rigSysList)

        children = cmds.listRelatives(check, children=True, fullPath=True, type='transform')
        if children:
            for child in children:
                childName = child.split('|')[-1]
                if childName.count('Low_Grp') or childName[:5] == 'World' or childName[:4] == 'Move':
                    continue

                cmds.delete(child)

    exportList = []
    for topNode in cmds.ls(assemblies=True):
        if not cmds.listRelatives(topNode, shapes=True):
            exportList.append(topNode)

    cmds.select(exportList, replace=True)
    mayascene_exportSelection(snPath.replace('.mb', '_LOW.mb').replace('.ma', '_LOW.mb'))

def changeSelectedAssetQuality():
    slList = cmds.ls(selection=True, long=True)
    if not slList:
        messageprint(u'원본을 불러들일 오브젝트를 선택해야 합니다.')
        return

    changeAssetQuality(slList)

def changeAssetQuality(assetList=None):
    if assetList:
        nsList = []
        for asset in assetList:
            asset = asset.split('.')[0]
            if cmds.referenceQuery(asset, isNodeReferenced=True):
                rslvName = cmds.referenceQuery(asset, filename=True)
                namsSpace = cmds.referenceQuery(asset, namespace=True, shortName=True)
                if nsList.count(namsSpace):
                    continue

                nsList.append(namsSpace)
                if rslvName.count('_LOW.'):
                    changePath = rslvName.split('{')[0].replace('_LOW.', '.')
                else:
                    changePath = rslvName.split('{')[0].replace('.ma', '_LOW.ma').replace('.mb', '_LOW.mb')

                if os.path.isfile(changePath):
                    cmds.file(changePath, lr=cmds.file(rslvName, q=True, rfn=True))

def cleanRig():
    for ref in cmds.file(q=True, reference=True):
        cmds.file(ref, rr=True)

    for geo in cmds.ls(type=('mesh',  'nurbsSurface')):
        if geo.count('Orig'):continue
        for geoHis in cmds.listHistory(geo, allConnections=True):
            cmds.setAttr(geoHis+'.isHistoricallyInteresting', 2)

    cmds.select(cmds.ls(assemblies=True), replace=True)
    try: mel.eval('DetachSkin;')
    except: pass

    mel.eval('DeleteAllNonLinearDeformers;')
    cmds.delete(cmds.ls(type=('nurbsCurve', 'joint', 'blendShape', 'lattice', 'wrap', 'lattice', 'cluster', 'softMod', 'sculpt', 'jiggle', 'wire', 'tweak')))

    for tr in cmds.ls(type='transform'):
        try: cmds.setAttr(tr+'.translateX', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.translateY', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.translateZ', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.rotateX', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.rotateY', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.rotateZ', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.scaleX', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.scaleY', lock=False)
        except: pass
        try: cmds.setAttr(tr+'.scaleZ', lock=False)
        except: pass
    mel.eval('DeleteAllConstraints;')
    #2015-06-01->
    try: cmds.delete('Rig_Box')
    except: pass
    #2015-06-01<-
    
try: uvSnapshotDict
except NameError: uvSnapshotDict = {}

def saveUVSnapshot():
    global uvSnapshotDict
    for mesh in cmds.ls(type='mesh', long=True, visible=True):
        uvSets = cmds.polyUVSet(mesh, query=True, allUVSets=True)
        if uvSets:
            uvSnapshotDict[mesh] = {}
            for uvSet in uvSets:
                cmds.polyUVSet(mesh, currentUVSet=True, uvSet=uvSet)
                uvSnapshotDict[mesh][uvSet] = cmds.polyEditUV(mesh+'.map[:]', query=True)

    if uvSnapshotDict:
        messageprint(u'UV 스냅샷이 저장 되었습니다.')

def checkUVSnapshot():
    global uvSnapshotDict

    uvMeshList = []
    for mesh in cmds.ls(type='mesh', long=True, visible=True):
        if mesh.count('|UVTransfer'): continue

        uvSets = cmds.polyUVSet(mesh, query=True, allUVSets=True)
        try: uvSnapshotDict[mesh]
        except:
            uvMeshList.append(mesh)
            messageprint(mesh+u' 내보내기: UV 스냅샷에 저장되지 않은 새 Mesh 입니다.')
            continue

        uvSets.sort()
        snapshotUVSets = uvSnapshotDict[mesh].keys()
        snapshotUVSets.sort()
        if snapshotUVSets != uvSets:
            uvMeshList.append(mesh)
            messageprint(mesh+u' 내보내기: UV 스냅샷에 저장된 uvSet 구성과 다릅니다.')
            continue

        for uvSet in uvSets:
            cmds.polyUVSet(mesh, currentUVSet=True, uvSet=uvSet)
            if not snapshotUVSets.count(uvSet):
                uvMeshList.append(mesh)
                messageprint(mesh+' 내보내기: UV 스냅샷에 저장되지 않은 새 uvSet이 존재합니다.')
                break

            if uvSnapshotDict[mesh][uvSet] != cmds.polyEditUV(mesh+'.map[:]', query=True):
                uvMeshList.append(mesh)
                messageprint(mesh+u' 내보내기: UV 스냅샷에 저장된 UV 모양과 다릅니다.')
                break

    messageprint(u'UV 스냅샷 확인 완료')

    return uvMeshList

def mkNodes(path):
    mdPath = ''
    for node in path.split('|'):
        if not node: continue

        parentPath = mdPath
        nodeName = node.split(':')[-1]
        mdPath += '|'+nodeName

        if cmds.ls(mdPath): continue

        if cmds.ls(parentPath): cmds.group(empty=True, name=nodeName, parent=parentPath)
        else: cmds.group(empty=True, name=nodeName)

    return mdPath

def exportUVMesh():
    uvTransferList = cmds.ls('|UVTransfer')
    if uvTransferList: cmds.delete(uvTransferList)

    uvModified = checkUVSnapshot()
    if uvModified:
        uvPath = cmds.file(q=1, sn=1).replace('.mb', '_UV.mb').replace('.ma', '_UV.mb')
        if os.path.isfile(uvPath):
            cmds.file(cmds.file(q=1, sn=1).replace('.mb', '_UV.mb').replace('.ma', '_UV.mb'), force=True, i=True, mergeNamespacesOnClash=False)

        if not cmds.ls('|UVTransfer'):
            cmds.group(empty=True, name='UVTransfer')

        cmds.select('|UVTransfer', hierarchy=True, replace=True)
        uvExports = cmds.ls(selection=True, long=True, geometry=True)
        for uvMdf in uvModified:
            uvMdfTr = cmds.listRelatives(uvMdf, parent=True, fullPath=True)
            if not uvMdfTr: continue

            uvMdfName = uvMdfTr[0].split('|')[-1]
            if uvExports:
                for uvExp in uvExports:
                    try:
                        if uvMdf.replace(':', '_oo_') == uvExp.replace('|UVTransfer|', '|').replace('|UV_', '|'):# and cmds.shapeCompare(uvMdf, uvExp) == 0:
                            cmds.delete(cmds.listRelatives(uvExp, parent=True, fullPath=True))
                            messageprint(uvExp+' deleted')

                    except:
                        pass

            cmds.select(uvMdf, replace=True)
            uvDup = cmds.duplicate(returnRootsOnly=True)
            uvTrName = cmds.rename(uvDup[0], 'UV_'+uvMdfName.replace(':', '_oo_'))
            uvShNode = cmds.listRelatives(uvTrName, shapes=True, fullPath=True)

            try:
                cmds.setAttr(uvShNode[0]+'.overrideEnabled', 1)
                cmds.setAttr(uvShNode[0]+'.overrideDisplayType', 1)
                cmds.setAttr(uvShNode[0]+'.castsShadows', 0)
                cmds.setAttr(uvShNode[0]+'.receiveShadows', 0)
                cmds.setAttr(uvShNode[0]+'.motionBlur', 0)
                cmds.setAttr(uvShNode[0]+'.primaryVisibility', 0)
                cmds.setAttr(uvShNode[0]+'.smoothShading', 0)
                cmds.setAttr(uvShNode[0]+'.visibleInReflections', 0)
                cmds.setAttr(uvShNode[0]+'.visibleInRefractions', 0)
                cmds.setAttr(uvShNode[0]+'.doubleSided', 0)

            except:
                pass

            try:
                cmds.select(uvTrName, replace=True)
                cmds.sets(e=True, forceElement='initialShadingGroup')

            except:
                pass

            try: cmds.parent(uvTrName, mkNodes('|UVTransfer'+('|'.join(uvMdfTr[0].split('|')[0:-1])).replace(':', '_oo_')))
            except: messageprint('Parent failed')

        uvTransferList = cmds.ls('|UVTransfer')
        if uvTransferList:
            cmds.setAttr('|UVTransfer.visibility', 0)
            cmds.select(uvTransferList, replace=True)
            mel.eval('DeleteHistory;')
            mayascene_exportSelection(cmds.file(q=1, sn=1).replace('.mb', '_UV.mb').replace('.ma', '_UV.mb'))
            cmds.delete(uvTransferList)

# 1.0.0 -->
def bakeAbcUI():
    def getBakesetList(_):
        cmds.select(cl=True)
        cmds.textScrollList("AbcBakesetList", e=True, removeAll=True)
        objSetL = cmds.ls(type='objectSet')
        for obj in objSetL:
            if obj.count('BakeSet'):
                cmds.textScrollList("AbcBakesetList", e=True, append=obj)
                
    def selectAllBakesetItem(obj):
        siList = cmds.textScrollList('AbcBakesetList', q=True, allItems=True)
        if siList == None:
            return
        for si in siList:
            cmds.textScrollList('AbcBakesetList', e=True, selectItem=si)
            
    def selectClearBakesetItem(_):
        cmds.textScrollList('AbcBakesetList', e=True, deselectAll=True)
        cmds.select(cl=True)
            
    def bakeSelected(_):
        siList = cmds.textScrollList('AbcBakesetList', q=True, selectItem=True)
        if siList != None and len(siList) > 0:
            shaderBake('_')#shader bake    #07.2.27
            bakeAbc(siList)#ABC Bake
        else:
            noticeWindow(u'반드시 하나 이상을 선택해야 합니다.')
    
    #07.2.27 -->
    def bakeSelectedTwo(_):
        siList = cmds.textScrollList('AbcBakesetList', q=True, selectItem=True)
        if siList != None and len(siList) > 0:
            bakeAbc(siList)# 1.0.1
        else:
            noticeWindow(u'반드시 하나 이상을 선택해야 합니다.')
    #07.2.27 <--
    
    if 'BakeAbcWindow' in cmds.lsUI(windows=True):
        cmds.deleteUI('BakeAbcWindow')
        
    cmds.window('BakeAbcWindow', title=u'Bake ABC', sizeable=False)
    rcl = cmds.rowColumnLayout(numberOfColumns=2, columnWidth=[(1, 220), (2, 80)], width=220, height=80)
    cmds.textScrollList('AbcBakesetList', allowMultiSelection=True, width=220, height=300)
    cl = cmds.columnLayout()
    cmds.button('Select All', width=80, height=40, command=selectAllBakesetItem)
    cmds.button('Select Clear', width=80, height=40, command=selectClearBakesetItem)
    cmds.button('Refresh', width=80, height=40, command=getBakesetList)
    cmds.button('Shader Bake', width=80, height=40, command=shaderBake)#07.2.23
    cmds.button('Bake ABC', width=80, height=40, command=bakeSelectedTwo)#07.2.27
    cmds.setParent(cl)
    cmds.setParent(rcl)
    cmds.button('Bake', width=300, height=40, command=bakeSelected)
    cmds.window('BakeAbcWindow', e=True, width=300, height=340)
    cmds.showWindow()
    
    getBakesetList(0)
# 1.0.0 <--

# 1.0.1 -->
# T-Pose 만드는 함수
def initPose():
    startFrame = START_FRAME
    initPoseFrame = startFrame - extraFrames
    ctrlList = cmds.ls('*:*:*Ctrl', '*:*Ctrl', '*Ctrl', '*:*:*ctrl', '*:*ctrl', '*ctrl', '*:*:*Ctr', '*:*Ctr', '*Ctr', '*:*:*ctr', '*:*ctr', '*ctr')
    if ctrlList != None:
        cmds.currentTime(startFrame)
        cmds.setKeyframe(ctrlList, breakdown=False, hierarchy='none', controlPoints=False, shape=False)
        cmds.currentTime(initPoseFrame)
        for ctrl in ctrlList:
            attrList = cmds.listAttr(ctrl, keyable=True, visible=True, connectable=True, locked=False)
            if attrList == None:
                continue
                
            for attr in attrList:
                if attr == u'visibility':
                    continue
                    
                if attr.startswith('scale'):
                    try: cmds.setAttr(ctrl+'.'+attr, 1)
                    except: continue
                    continue
        
                ctrlName = ctrl.lower().split(':')[-1]
                if ctrlName.startswith('world') or ctrlName.startswith('move') or ctrlName.startswith('fly'):# or ctrlName.startswith('root'):
                    if attr.startswith('translate'):
                        continue
                
                attrType = cmds.getAttr(ctrl+'.'+attr, type=True)
                if attrType == u'double' or attrType == u'doubleLinear' or attrType == u'doubleAngle' or attrType == u'long':# or attrType == u'enum' or attrType == u'bool':
                    try: cmds.setAttr(ctrl+'.'+attr, 0)
                    except: pass
        cmds.setKeyframe(ctrlList, breakdown=False, hierarchy='none', controlPoints=False, shape=False)
        
    cmds.currentTime(startFrame)
# 1.0.1 <--
    
#   2017.02.23 -->
def shaderBake(_):

    minTime = int(cmds.playbackOptions(q=True, minTime=True))
    maxTime = int(cmds.playbackOptions(q=True, maxTime=True))

    # 1.0.5 --> bake Layer Fake View
    #bake Layer 생성하여 보이는 화면 일시적으로 감추기
    bakeLayer = "bake_layer"
    cmds.createRenderLayer(name=bakeLayer, number=1, nr=True)
    cmds.editRenderLayerGlobals( currentRenderLayer=bakeLayer)

    # 1.0.4 --> bake shading network
    # 쉐이딩 네트워크가 'transform', 'animCurve', 'expression' 노드와 연결되어 값이 변경되는 경우 키를 SHD_ANI.json 파일로 저장
    
    checkNodeList = []
    def getSrcConns(node):
        bakeNodeList = []
        passTypeList = ['transform', 'animCurve', 'expression']# 이 노드들로부터 연결된 값들을 베이크 하기 때문에 노드 목록 조사 시 이 노드들은 넘어감
        for typeName in passTypeList:
            if cmds.nodeType(node).startswith(typeName):
                return bakeNodeList
                
        connList = cmds.listConnections(node, plugs=True, d=False)
        if connList != None:
            for conn in connList:
                passType = False
                connNode = conn.split('.')[0]
                if not checkNodeList.count(connNode):
                   checkNodeList.append(connNode)
                   bakeNodeList = bakeNodeList + getSrcConns(connNode)
                   
                for typeName in passTypeList:
                   if cmds.nodeType(connNode).startswith(typeName):
                       passType = True
                       break
                       
                if passType:
                    bakeConnList = cmds.listConnections(conn, s=False, plugs=True)
                    if bakeConnList != None:
                        for bakeConn in bakeConnList:
                            subAttrList = cmds.listAttr(bakeConn)
                            if len(subAttrList) > 1:
                                node_attr = bakeConn.split('.')
                                nodeName = node_attr[0]
                                attrName = '.'.join(node_attr[1:])
                                for subAttr in subAttrList:
                                    if attrName == subAttr:
                                        continue
                                        
                                    if not bakeNodeList.count(nodeName+'.'+subAttr):
                                        bakeNodeList.append(nodeName+'.'+subAttr)
                            else:
                                if not bakeNodeList.count(bakeConn):
                                    bakeNodeList.append(bakeConn)
                                        
        return bakeNodeList

    bakeMatAttrList = []
    matList = cmds.ls(materials=True)
    if matList != None:
        for mat in matList:
            bakeMatAttrList = bakeMatAttrList + getSrcConns(mat)
        bakeMatAttrList = list(set(bakeMatAttrList))
        
    if len(bakeMatAttrList) > 0:
        bakeMatAttrDict = {}
        
        for bakeMatAttr in bakeMatAttrList:
            bakeMatAttrDict[bakeMatAttr] = []
            
        # 전체 프레임을 조사하여 키 값을 딕셔너리에 저장
        for currFrame in range(int(minTime), int(maxTime+1)):
            cmds.currentTime(currFrame)
            #print currFrame
            for bakeMatAttr in bakeMatAttrList:
                try: bakeMatAttrDict[bakeMatAttr].append(cmds.getAttr(bakeMatAttr))
                except: pass
                
        # 딕셔너리를 JSON 파일로 저장
        jsonString = json.dumps(bakeMatAttrDict)
        matKeyPath = os.path.dirname(cmds.file(q=1, sn=1))+'/'+'SHD_ANI.json'
        fd = open(matKeyPath, 'w')
        fd.write(jsonString)
        fd.close()
    #    Render Layer delete
    cmds.editRenderLayerGlobals( currentRenderLayer='defaultRenderLayer')# 1.0.5 <--
    cmds.delete(bakeLayer)# 1.0.5 <--
    
    #upload file to server 
    w = workFromPath(mayascene_path(), WMS_HOST)
    checknum = checkTime()
    # 파일 전송
    err = uploadWork(w, checknum)
    if err:
        noticeWindow(err)
        return
    #   2017.02.23 -->

def bakeAbc(selected=None):
    global extraFrames, mayaBinPath
    
    # 1.0.1 -->
    bake = askWindow(u'ABC를 생성하시겠습니까? 현재 씬은 저장됩니다.', title=u'ABC 생성')
    if not bake:
      return

    abcDir = os.path.dirname(cmds.file(q=1, sn=1))+'/.abc/'
    try:
        cmds.loadPlugin('MayaExocortexAlembic', quiet=True)
    except:
        messageprint(u'"MayaExocortexAlembic" Plug-in이 설치되지 않아 Abc 생성은 건너뜁니다..')
        return
      
    #initPose()#t-pose 실행 함수
    mayascene_save()
    # 1.0.1 <--
    
    if not cmds.file(q=1, sn=1):
        messageprint(u'씬을 새 이름으로 저장한 후 다시 시도해주십시오.')
        return
        
    minTime = int(cmds.playbackOptions(q=True, minTime=True))
    maxTime = int(cmds.playbackOptions(q=True, maxTime=True))

    snName = os.path.basename(cmds.file(q=1, sn=1)).replace('.mb', '').replace('.ma', '')
    if not os.path.isdir(abcDir):
        os.makedirs(abcDir)
    if not os.path.isdir(abcDir):
        messageprint(abcDir+u'에 접근할 수 없습니다. 확인 후 다시 시도해주십시오')
        return

    mel.eval('DisplayWireframe;')
    # ABC List
    abcList = []
    # 1.0.0 -->
    objSetL = selected
    if objSetL == None:
        objSetL = cmds.ls(type='objectSet')
    # 1.0.0 <--
    for obj in objSetL:
        if obj.count('BakeSet'):
            abcList.append(obj)# 1.0.0
    
    #Camera ABC List
    msCamTrList = []
    msCamList = cmds.ls('MS_CAM*', '*:MS_CAM*', '*:*:MS_CAM*', type='camera')# 1.0.1
    if msCamList:
        for msCam in msCamList:
            msCamTr = cmds.listRelatives(msCam, parent=True, fullPath=True)
            if msCamTr:
                msCamTrList.append(msCamTr[0])

    postShellCommand = ''# .abc 폴더 압축 및 업로드 명령어
    try: w = workFromPath(cmds.file(q=1, sn=1), WMS_HOST)
    except: w = None
    if w != None:
        abcArchPath = os.path.dirname(cmds.file(q=1, sn=1)).replace('/work/', '/update/')+'/'+w.name+'-abc.7z'
        if os.path.isfile(abcArchPath):
            try: os.remove(abcArchPath)
            except: pass

        storageIP = projectStorageIP(w.hostip, w.prjid)
        postShellCommand += 'print "ABC Bake Post Processing...\\n";\n'
        postShellCommand += 'print "7z Compressing...\\n";\n'
        postShellCommand += 'system("'+UTIL_DIR+'/7za a -xr!*.log '+abcArchPath+' '+abcDir+' > '+abcDir+'archive.log'+'");\n'
        postShellCommand += 'print "Check Remote ABC Version\\n";\n'
        postShellCommand += 'system("'+UTIL_DIR+'/curl -X POST --fail --silent --show-error -F upload_dir=app/pipeline/update/'+w.prj+'/'+w.prjtype+'/'+w.process+'/'+w.name+' -F file=@'+abcArchPath+' http://'+storageIP+'/wms/script/upload.php'+'");\n'
        postShellCommand += 'print "Uploading ABC Archive...\\n";\n'
        postShellCommand += 'system("'+UTIL_DIR+'/curl -sI http://'+storageIP+'/files/wms/app/pipeline/update/'+w.prj+'/'+w.prjtype+'/'+w.process+'/'+w.name+'/'+os.path.basename(abcArchPath)+' > '+abcDir+'upload.log'+'");\n'
        postShellCommand += 'print "ABC Bake Complete\\n";\n'
        postShellCommand += 'print "This window closes after 10 seconds\\n";\n'
        postShellCommand += 'pause -sec 5;\n'
        postShellCommand += 'print "...5\\n";\n'
        postShellCommand += 'pause -sec 2;\n'
        postShellCommand += 'print "...3\\n";\n'
        postShellCommand += 'pause -sec 1;\n'
        postShellCommand += 'print "...2\\n";\n'
        postShellCommand += 'pause -sec 1;\n'
        postShellCommand += 'print "...1\\n";\n'
        postShellCommand += 'pause -sec 1;\n'

    script = 'loadPlugin -quiet MayaExocortexAlembic;\n'
    script += 'python("import ExocortexAlembic");\n'
    
    # 1.0.0 -->
    #for exists in glob.glob(abcDir+'*.log'):
    #    try: os.remove(exists)
    #    except: pass

    # 수동 베이크 모드인지 작업 완료 모드인지 검사
    shName = 'selected'
    if selected == None:
        shName = 'complete'
        # 작업 완료 모드 시 기존 abc 파일 제거
        for exists in glob.glob(abcDir+'*.abc'):
            try: os.remove(exists)
            except: pass
    # 1.0.0 <--
    
    # 베이크 될 노드의 목록을 파일로 저장
    abcListPath = abcDir+shName+'.lst'# 1.0.0
    fd = open(abcListPath, 'w')
    fd.write('\n'.join(msCamTrList+abcList))
    fd.close()
    
    if msCamTrList:
        for msCam in msCamTrList:
            basePath = abcDir+msCam.split('|')[-1].replace('|', '__').replace(':', '--')# 1.0.1
            fbxPath = basePath+'.fbx'# 1.0.1
            abcPath = basePath+'.abc'# 1.0.1
            script += 'print "'+''+msCam+' ABC Bake Start\\n";\n'
            script += 'select -replace '+msCam+';\n'
            script += 'file -force -options "v=0;" -typ "FBX export" -pr -es "'+fbxPath+'";\n'# 1.0.1
            # 0.20.30.30 #script += 'AbcExport -j "-frameRange '+str(minTime)+' '+str(maxTime)+' -attr horizontalFilmOffset -attr filmFit -attr horizontalFilmAperture -attr verticalFilmAperture -attr focalLength -attr lensSqueezeRatio -attr fStop -attr focusDistance -attr shutterAngle -attr centerOfInterest -attr nearClipPlane -attr farClipPlane -dataFormat ogawa -root '+msCam+' -file \\\"'+abcPath+'\\\"";\n'
            script += 'python("ExocortexAlembic._export.doIt(\''+abcPath+'\', '+str(minTime - extraFrames)+', '+str(maxTime + extraFrames)+', None, 1, 1, 3, 1, 1, 0, 0, 0, 0, 0, 1)");\n'# 0.20.30.30
            script += 'print "'+''+msCam+' ABC Bake End\\n";\n'

    if abcList:
        for abc in abcList:
            abcName = abc.split('|')[-1]#| 이 있으면 실제로 bakeSet리스트를 선택이 안되므로 강제로 이름을 만들어 주었습니다. 체크 해야 할 사항
            abcPath = abcDir+abc.split('|')[-1].replace('|', '__').replace(':', '--')+'.abc'
            script += 'print "'+''+abc+' ABC Bake Start\\n";\n'
            script += 'select -replace -hierarchy '+abcName+';\n'
            script += 'python("ExocortexAlembic._export.doIt(\''+abcPath+'\', '+str(minTime - extraFrames)+', '+str(maxTime + extraFrames)+', None, 1, 1, 3, 1, 1, 0, 0, 0, 0, 0, 1)");\n'
            script += 'print "'+''+abc+' ABC Bake End\\n";\n'

    if postShellCommand:
        script += postShellCommand

    # 백그라운드 마야 배치에 사용 될 MEL 파일
    scriptPath = abcDir+shName+'.mel'# 1.0.0
    if not os.path.isdir(os.path.dirname(scriptPath)):
        os.makedirs(os.path.dirname(scriptPath))
    fd = open(scriptPath, 'w')
    fd.write(script)
    fd.close()

    # abc 베이크 쉘 스크립트
    shellCommand = '"'+mayaBinPath+'maya" -batch -log '+abcDir+shName+'.log -proj "'+cmds.workspace(q=1, rd=1)+'" -file "'+cmds.file(q=1, sn=1)+'" -script "'+scriptPath+'"'
    cmdPath = abcDir+shName+'.bat'# 1.0.0
    if sys.platform != 'win32':# 1.0.0
        cmdPath = abcDir+shName+'.sh'# 1.0.0
    if not os.path.isdir(os.path.dirname(cmdPath)):
        os.makedirs(os.path.dirname(cmdPath))
    fd = open(cmdPath, 'w')
    fd.write(shellCommand)
    fd.close()

    subprocess.Popen(cmdPath, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

abcEtag = None# abc 파일 버전 확인을 위해 http header의 etag를 이용
def openAbc(w, check=False):
    if w.prjtype != 'shot':
        messageprint(u'ABC 열기 기능은 샷 작업에만 적용됩니다.')
        return

    # abc 플러그인 활성화
    try: cmds.loadPlugin('MayaExocortexAlembic', quiet=True)
    except:
        messageprint(u'MayaExocortexAlembic를 설치한 후 다시 시도해주십시오.')
        return

    # 씬에 abc 노드가 있는지 검사
    abcNodeList = cmds.ls(type='ExocortexAlembicFile')
    if check:
        if len(abcNodeList) < 1:
            return

    global abcEtag
    abcEtag = None

    # abc 다운로드 및 쉐이더 에셋과 버전 검사를 위해 애니메이션 작업을 다운로드
    downloadRelatedWorks(workFromPath(w.path.replace('/'+w.process+'/', '/animation/'), WMS_HOST), False)
    downloadRefWorks(workFromPath(w.path.replace('/rendering/', '/animation/').replace('/lighting/', '/animation/'), WMS_HOST), 'shading')

    # abc 폴더 생성
    abcDir = os.path.dirname(w.mb).replace('/'+w.process+'/', '/animation/')+'/.abc/'
    if not os.path.isdir(abcDir):
        os.makedirs(abcDir)
    if not os.path.isdir(abcDir):
        messageprint(abcRoot+u'에 접근할 수 없습니다. 확인 후 다시 시도해주십시오')
        return

    # 스토리지에서 abc 버전 확인
    storageIP = projectStorageIP(w.hostip, w.prjid) # 2017-01-12 스토리지 분리
    abcUrl = 'http://'+storageIP+'/files/wms/app/pipeline/update/'+w.prj+'/'+w.prjtype+'/animation/'+w.name+'/'+w.name+'-abc.7z'  # 2017-01-12 스토리지 분리
    remoteAbcEtag = ''
    proc = subprocess.Popen(UTIL_DIR+'/curl -sI '+abcUrl, stdout=subprocess.PIPE, shell=True)
    (out, err) = proc.communicate()
    if out.count('ETag:'):
        remoteAbcEtag = out.split('ETag:')[-1].split('"')[1]

    localAbcEtag = ''
    if os.path.isfile(abcDir+'upload.log'):
        fd = open(abcDir+'upload.log', 'r')
        data = fd.read()
        fd.close()
        if data.count('ETag:'):
            localAbcEtag = data.split('ETag:')[-1].split('"')[1]

    sceneAbcEtag = ''
    snXmlPath = w.mb.replace('.mb', '.xml').replace('.ma', '.xml')
    if os.path.isfile(snXmlPath):
        snRoot = ET.parse(snXmlPath)
        try :sceneAbcEtag = snRoot.find('abc').attrib['etag']
        except: pass

    # abc 다운로드
    if remoteAbcEtag and remoteAbcEtag != localAbcEtag:
        resp = urllib2.urlopen(abcUrl)
        dnPath = LOCAL_ROOT+'/'+abcUrl.split('/pipeline/')[-1]
        dnDir = os.path.dirname(dnPath)
        if not os.path.isdir(dnDir):
            os.makedirs(dnDir)
        else:
            try: os.remove(dnPath)
            except OSError: pass

        if not os.path.isdir(dnDir):
            messageprint(dnDir+u'에 접근할 수 없습니다. 확인 후 다시 시도해주십시오.')
            return

        fsize = int(resp.info().getheader('Content-Length'))
        pgwin = ProgressWindow('download : ' + dnPath, fsize)
        n = 8192
        with open(dnPath, 'ab') as fd:
            buf = resp.read(n)
            while buf:
                fd.write(buf)
                pgwin.advance(n)
                buf = resp.read(n)

        fd.close()
        pgwin.close()

        if os.stat(dnPath).st_size != fsize:
            messageprint(u'다운로드 중 파일이 손상되었습니다. 다시 시도해주십시오')
            return

        for exists in glob.glob(abcDir+'*'):
            try: os.remove(exists)
            except OSError: pass

        proc = subprocess.Popen(UTIL_DIR+'/7za x '+dnPath+' -y -o'+abcDir.split('.abc')[0], stdout=subprocess.PIPE, shell=True)
        (out, err) = proc.communicate()
        subprocess.Popen(UTIL_DIR+'/curl -sI '+abcUrl+' > '+abcDir+'upload.log', stdout=subprocess.PIPE, shell=True)

    # etag 업데이트
    if os.path.isfile(abcDir+'upload.log'):
        fd = open(abcDir+'upload.log', 'r')
        data = fd.read()
        fd.close()
        if data.count('ETag:'):
            abcEtag = data.split('ETag:')[-1].split('"')[1]

    # abc 목록 파일과 실제 abc 파일 검사
    abcCompleteList = []
    if os.path.isfile(abcDir+'complete.lst'):
        fd = open(abcDir+'complete.lst', 'r')
        for line in fd.readlines():
            abcCompleteList.append(line.strip().split('|')[-1])# 1.0.0
        fd.close()
        abcCompleteList.sort()

    abcFileList = []
    for abc in glob.glob(abcDir+'*.abc'):
        abcFileList.append(str(os.path.basename(os.path.splitext(abc)[0]).replace('--', ':')))
    abcFileList.sort()

    # 파일 수가 다르면 메시지 출력
    if abcCompleteList != abcFileList:
        print '-------------------- Scene ABC List --------------------'
        print '\n'.join(abcCompleteList)
        print '-------------------- File ABC List --------------------'
        print '\n'.join(abcFileList)
        warningprint(u'원본 씬의 ABC 목록과 생성된 ABC 파일의 목록이 다릅니다. 위 목록을 확인해주십시오.')

    # 1.0.1 -->
    bakeSetList = []
    for topNode in cmds.ls(['*:*:*BakeSet', '*:*BakeSet', '*BakeSet'], type='objectSet'):#cmds.ls(assemblies=True, long=True):
        if not cmds.listRelatives(topNode, shapes=True) and not topNode.count('_UV:') and not topNode.count('_SHD:') or topNode.count('MS_CAM'):
            topName = topNode.split('|')[-1]
            bakeSetList.append(topName)
    
    needUpdate = False
    if len(bakeSetList) != len(abcFileList) or sceneAbcEtag != localAbcEtag:
        needUpdate = True
    # 1.0.1 <--
    
    needReplace = False
    if len(abcNodeList):
        if check:
            needReplace = True

        else:
            abcReplaceOk = selectionWindow(u'교체 가능한 ABC 에셋들이 존재합니다.\nABC 에셋들을 교체하시겠습니까?\n(불러오는 씬에 없는 에셋들은 제거됩니다)', title=u'ABC 교체', items=[u'교체하기', u'새로 구성'])
            if not abcReplaceOk:
                return
            elif abcReplaceOk == u'교체하기':
                needReplace = True

    assetFileDict = {}
    aniXmlPath = w.mb.replace('/'+w.process+'/', '/animation/').replace('.mb', '.xml').replace('.ma', '.xml')
    if os.path.isfile(aniXmlPath):
        aniRoot = ET.parse(aniXmlPath)
        for refTag in aniRoot.findall('reference'):
            if refTag.attrib.keys().count('top_node'):
                assetFileDict[refTag.attrib['top_node'].split('|')[-1]] = os.path.dirname(cmds.workspace(q=True, fullName=True))+'/'+refTag.attrib['path']
                
    # 새로 추가된 탑노드를 BakeSet에 추가
    def addBakeSet(setName, topList): # 2017-01-03 -->
        if len(cmds.ls(setName)) < 1 and len(topList) > 0:
            ns_Name = setName.split(':')
            if len(ns_Name) == 2:
                try: cmds.namespace(add=ns_Name[0])
                except: pass
                cmds.namespace(set=ns_Name[0])
                cmds.select(topList, hi=True, r=True)
                cmds.sets(n=ns_Name[1])
                cmds.namespace(set=':')
            elif len(ns_Name) < 2:
                cmds.sets(n=ns_Name[0])  # 2017-01-03 <--
                
    if needReplace:# abc 노드가 존재
        # 렌더링, 라이팅 공정에서는 프록시로 교체
        if w.mb.count('/lighting/') or w.mb.count('/rendering/'):
            for abcFile in abcFileList:
                if bakeSetList.count(abcFile):# 1.0.1
                    ns = abcFile.split(':')[0]
                    proxyPath = ''
                    try: proxyPath = assetFileDict[abcFile].replace('/rigging/', '/shading/').replace('_LOW.', '.').replace('.ma', '_PRX.ma').replace('.mb', '_PRX.mb')
                    except: pass

                    if os.path.isfile(proxyPath):
                        if cmds.referenceQuery(abcFile, isNodeReferenced=True):
                            if not cmds.referenceQuery(abcFile, filename=True).count('_PRX.'):
                                cmds.file(cmds.referenceQuery(abcFile, filename=True), rr=True)
                        else:
                            cmds.delete(abcFile)

                        if cmds.namespace(exists=ns):
                            try: cmds.namespace(force=True, deleteNamespaceContent=True, removeNamespace=ns)
                            except: pass

                        needUpdate = True

        # 렌더 공정이 아니면 프록시 제거
        else:
            for ref in cmds.file(q=True, reference=True):
                if ref.count('_PRX.'):
                    refNs = cmds.file(ref, q=True, namespace=True)
                    cmds.file(ref, rr=True)

                    if cmds.namespace(exists=refNs):
                        try: cmds.namespace(force=True, deleteNamespaceContent=True, removeNamespace=refNs)
                        except: pass

                    needUpdate = True

        if needUpdate:
            messageprint(u'ABC 에셋들을 교체합니다.')
            # 2017-01-16 --> abc를 무조건 새로 불러들이는 문제 해결
            for setNode in cmds.ls(['*:*:*BakeSet', '*:*BakeSet', '*BakeSet'], type='objectSet'):# 1.0.1
                if not setNode in abcFileList:
                    try:
                        if cmds.referenceQuery(setNode, isNodeReferenced=True):
                            cmds.file(cmds.referenceQuery(setNode, filename=True), rr=True)
                        else:
                            # 1.0.1 -->
                            cmds.select(setNode, hi=True, r=True)
                            deleteAsset = cmds.ls(sl=True)
                            if deleteAsset != None:
                                cmds.delete(deleteAsset)
                            # 1.0.1 <--
                            
                        messageprint(u'교체할 씬에 포함되지 않은 '+setNode+u' ABC 에셋을 제거했습니다.')
                    except:
                      pass
            # 2017-01-16 <-- abc를 무조건 새로 불러들이는 문제 해결
            # 1.0.1 -->
            deleteAbcNodeList = cmds.ls('MS_CAM', '*:MS_CAM', '*:*:MS_CAM')
            if deleteAbcNodeList: cmds.delete(deleteAbcNodeList)
            # 1.0.1 <--
            for abcFile in abcFileList:
                replAbcFile = abcDir+abcFile.replace(':', '--')+'.abc'
                # 2017-01-06 --> abc 열기 실패 처리 27->28버전
                if replAbcFile.count('MS_CAM-PipelineCache'):# 1.0.1
                    try:
                        deleteAbcNodeList = cmds.select((abcFile, abcFile.split(':')[-1]), hi=True, r=True) # 2017-01-03 추가 hi=True, r=True)
                        if deleteAbcNodeList: cmds.delete(cmds.ls(sl=True))
                        mel.eval('AbcImport -mode import "'+replAbcFile+'";')
                        if cmds.ls('Cam3D'):
                            mel.eval('connectStereoCameraPin("'+abcFile.split(':')[-1]+'");')
                    except:
                        pass
                # 2017-01-06 <-- abc 열기 실패 처리 27->28버전
                elif len(cmds.ls(abcFile)) > 0:
                    if cmds.referenceQuery(abcFile, isNodeReferenced=True) and cmds.referenceQuery(abcFile, filename=True).count('_PRX.'):
                        messageprint(abcFile+u' 프록시 데이터에는 ABC를 적용하지 않고 건너뜁니다.')
                        continue

                    topExists = cmds.ls(assemblies=True, long=True) # 2017-01-03
                    try: mel.eval('ExocortexAlembic_import -j "filename='+replAbcFile+';normals=0;uvs=1;facesets=1;attachToExisting=1;overXforms=1;overDforms=1";')
                    except: pass
                    topAdded = cmds.ls(assemblies=True, long=True) # 2017-01-03
                    topForNewSet = list(set(topAdded) - set(topExists)) # 2017-01-03
                    addBakeSet(abcFile, topForNewSet) # 2017-01-03

                else:
                    ns = abcFile.split(':')[0]
                    proxyPath = ''
                    try: proxyPath = assetFileDict[abcFile].replace('/rigging/', '/shading/').replace('_LOW.', '.').replace('.ma', '_PRX.ma').replace('.mb', '_PRX.mb')
                    except: pass

                    if os.path.isfile(proxyPath) and (w.mb.count('/lighting/') or w.mb.count('/rendering/')):
                        messageprint(abcFile+u' 에셋을 프록시로 대체합니다.')
                        mayascene_reference(proxyPath, ns)

                    else:
                        topExists = cmds.ls(assemblies=True, long=True) # 2017-01-03
                        mel.eval('ExocortexAlembic_import -j "filename='+replAbcFile+';normals=0;uvs=1;facesets=1;multi=0;fitTimeRange=1";')
                        topAdded = cmds.ls(assemblies=True, long=True) # 2017-01-03
                        topForNewSet = list(set(topAdded) - set(topExists)) # 2017-01-03
                        addBakeSet(abcFile, topForNewSet) # 2017-01-03

    else:
        if mayascene_modified():
            saveOk = abcReplaceOk = selectionWindow(u'새 ABC 씬을 구성합니다. 저장 후 진행하시겠습니까?', title=u'새 ABC 구성', items=[u'저장', u'무시'])
            if not abcReplaceOk:
                return

            elif saveOk == u'저장':
                mayascene_save()

        cmds.file(new=True, force=True)
        for abcFile in abcFileList:
            newAbcFile = abcDir+abcFile.replace(':', '--')+'.abc'
            ns = abcFile.split(':')[0]
            proxyPath = ''
            try: proxyPath = assetFileDict[abcFile].replace('/rigging/', '/shading/').replace('_LOW.', '.').replace('.ma', '_PRX.ma').replace('.mb', '_PRX.mb')
            except: pass

            if os.path.isfile(proxyPath) and (w.mb.count('/lighting/') or w.mb.count('/rendering/')):
                messageprint(abcFile+u' 에셋을 프록시로 대체합니다.')
                mayascene_reference(proxyPath, ns)
            else:
                if newAbcFile.count('MS_CAM-PipelineCache'):# 1.0.1
                    mel.eval('AbcImport -mode import "'+newAbcFile+'"')
                else:
                    topExists = cmds.ls(assemblies=True, long=True) # 2017-01-03
                    mel.eval('ExocortexAlembic_import -j "filename='+newAbcFile+'; normals=0; uvs=1; facesets=1; multi=0; fitTimeRange=1";')
                    topAdded = cmds.ls(assemblies=True, long=True) # 2017-01-03
                    topForNewSet = list(set(topAdded) - set(topExists)) # 2017-01-03
                    addBakeSet(abcFile, topForNewSet) # 2017-01-03

    proxyExists = False
    for ref in cmds.file(q=True, reference=True):
        if ref.count('_PRX.'):
            proxyExists = True
            break
    if proxyExists:
        animCurveList = cmds.ls('ANI__*__ns__*__co__*')
        if animCurveList: cmds.delete(animCurveList)
        aniFile = w.mb.replace('/'+w.process+'/', '/animation/').replace('.mb', '_ANI.mb').replace('.ma', '_ANI.mb')
        if os.path.isfile(aniFile):
            mayascene_embed(aniFile, useNamespace=False)#, namespace='')
            aniCurveList = cmds.ls('ANI__*__ns__*__co__*')
            if aniCurveList:
                for aniCurve in aniCurveList:
                    destAttr = aniCurve.replace('ANI__', '').replace('__ns__', ':').replace('__co__', '.')
                    if cmds.ls(destAttr):
                        if not cmds.listConnections(destAttr, d=False):
                            cmds.connectAttr(aniCurve+'.output', destAttr, force=True)
                    else:
                        allAttrList = cmds.ls('*:'+destAttr.split(':')[-1])
                        if len(allAttrList) == 1:
                            if not cmds.listConnections(allAttrList[0], d=False):
                                cmds.connectAttr(aniCurve+'.output', allAttrList[0], force=True)
                                messageprint(destAttr+u' 속성을 대체 가능한 '+allAttrList[0]+u'에 AnimCurve를 연결했습니다.')
                        else:
                            messageprint(destAttr+u' 속성이 존재하지 않아 AnimCurve를 연결하지 못했습니다.')
        offProxyLow()

    # timeline 25fps setting
    if w.prjtype == 'shot':
        resp = smgweb_post(
            w.hostip,
            '/wms/app/pipeline/script/process_info.php',
            {
                'project_id' : w.prjid,
                'wid' : 'base__' + w.name
            }
        )
        root = ET.XML(resp)
        infoEls = root.getiterator("information")

        fps = 0
        startFrame = START_FRAME# 1.0.1
        endFrame = startFrame + extraFrames# 1.0.1

        for el in infoEls:
            if str(el.get('name')).lower() == 'start_frame':
                if el.text:
                    startFrame = float(el.text)

            elif str(el.get('name')).lower() == 'end_frame':
                if el.text:
                    endFrame = float(el.text)

            elif str(el.get('name')).lower() == 'frame':
                frame = float(el.text)+startFrame-1
                if  frame != endFrame:
                    endFrame = frame

            elif str(el.get('name')).lower() == 'fps' or str(el.get('name')).lower() == 'framerate':
                if el.text:
                    fps= int(int(filter(str.isdigit, el.text)))
    # timeline start / end frame setting
    if fps:
        mayascene_setFrameRate(fps)
    cmds.playbackOptions(ast=startFrame, aet=endFrame)
    cmds.playbackOptions(min=startFrame, max=endFrame)


def importGeometry(w):
    chk = checkVersion(w)
    if chk < 2 and chk != 0:
        downloadWork(w)

    geoFile = w.mb.replace('.mb', '_GEO.mb')
    if os.path.isfile(geoFile):
        mayascene_embed(geoFile, useNamespace=False)

def createVrayProxy():
    #downloadRefWorks(workFromPath(mayascene_path().replace('/rendering/', '/animation/').replace('/lighting/', '/animation/'), WMS_HOST), 'shading')
    updateShaders()
    slList = cmds.ls(selection=True)
    cmds.select(slList, replace=True)
    mel.eval('vrayCreateProxyButtonPressed;')
    mel.eval('MLdeleteUnused;')

    snPath = cmds.file(q=1, sn=1)
    if snPath:
        if not snPath.count('_PRX.'):
            cmds.file(rename=snPath.replace('/rigging/', '/shading/').replace('.ma', '_PRX.ma').replace('.mb', '_PRX.mb'))
        cmds.file(save=True, force=True)

    cmds.deleteUI('vrayCreateProxyWindow')

def openVrayProxyWindow():
    try:
        cmds.loadPlugin('vrayformaya', quiet=True)
    except:
        messageprint(u'"VRay for Maya" Plug-in을 설치한 후 다시 시도해주십시오.')
        return

    try: w = workFromPath(cmds.file(q=1, sn=1), WMS_HOST)
    except: w = None

    if w != None and w.process == 'rigging':
            mel.eval('vrayCreateCreateProxyWindow')

            proxyDir = w.dir.replace('/rigging/', '/shading/')+'/proxy/vray/'
            if not os.path.isdir(proxyDir):
                os.makedirs(proxyDir)
            if not os.path.isdir(proxyDir):
                messageprint(proxyDir+u'에 접근할 수 없습니다. 확인 후 다시 시도해주십시오')
                return

            cmds.textField('vraycpPathCtrl', e=True, text=proxyDir)

            mel.eval('button -e -c "python(\\"createVrayProxy()\\")" vrayCreateProxyButtonControl;')

    else:
        noticeWindow(u'리깅 데이터만 프록시로 만들 수 있습니다.')

def createRenderProxy():
    openVrayProxyWindow()

def changeAssetQualityByAttribute(changeAll=True):
    originalWorldCtrlList = []
    for worldCtrlLow in cmds.ls(('World_Ctrl.Low', '*:World_Ctrl.Low'), long=True):
        if cmds.getAttr(worldCtrlLow) == 0:
            worldCtrl = worldCtrlLow.split('.')[0]
            if not originalWorldCtrlList.count(worldCtrl):
                originalWorldCtrlList.append(worldCtrl)
            if cmds.referenceQuery(worldCtrlLow, isNodeReferenced=True):
                if cmds.referenceQuery(worldCtrlLow, filename=True).count('_LOW.'):
                    cmds.select(worldCtrl, replace=True)
                    changeSelectedAssetQuality()

    if changeAll:
        for worldCtrlLow in cmds.ls(('World_Ctrl.Low', '*:World_Ctrl.Low'), long=True):
            worldCtrl = worldCtrlLow.split('.')[0]
            if not originalWorldCtrlList.count(worldCtrl):
                if cmds.referenceQuery(worldCtrl, isNodeReferenced=True):
                    rslvName = cmds.referenceQuery(worldCtrl, filename=True)
                    lowFile = rslvName.replace('.ma', '_LOW.mb').replace('.mb', '_LOW.mb').split('{')[0]
                    if os.path.isfile(lowFile):
                        cmds.file(lowFile, lr=cmds.file(rslvName, q=True, rfn=True))

    return originalWorldCtrlList

def changeShotAssetQuality(changeAll=False):
    toWireframeMode()

    minTime = cmds.playbackOptions(q=True, min=True)
    maxTime = cmds.playbackOptions(q=True, max=True)
    cmds.currentTime(minTime)

    originalWorldCtrlList = []
    while cmds.currentTime(q=True) < maxTime + 1:
        cmds.currentTime(cmds.currentTime(q=True) + 1)
        for originalWorldCtrl in changeAssetQualityByAttribute():
            if not originalWorldCtrlList.count(originalWorldCtrl):
                originalWorldCtrlList.append(originalWorldCtrl)

    if changeAll:
        for worldCtrlLow in cmds.ls(('World_Ctrl.Low', '*:World_Ctrl.Low'), long=True):
            worldCtrl = worldCtrlLow.split('.')[0]
            if not originalWorldCtrlList.count(worldCtrl):
                if cmds.referenceQuery(worldCtrl, isNodeReferenced=True):
                    rslvName = cmds.referenceQuery(worldCtrl, filename=True)
                    lowFile = rslvName.replace('.ma', '_LOW.mb').replace('.mb', '_LOW.mb').split('{')[0]
                    if os.path.isfile(lowFile):
                        cmds.file(lowFile, lr=cmds.file(rslvName, q=True, rfn=True))

def updateLodThreshold():
    threshold1Multiple = 2

    assetList = []
    slList = cmds.ls(selection=True, long=True)
    if slList:
        for sl in slList:
            if sl.count('Rig_Box|') or sl.count('Rig_Grp|') or sl.count('Mod_Box|') or sl.count('Mod_Grp|'):
                assetTop = '|'.join(sl.split('Rig_Box')[0].split('Rig_Grp')[0].split('Mod_Box')[0].split('Mod_Grp')[0].split('|')[:-1])
                if not assetList.count(assetTop):
                    assetList.append(assetTop)

    if assetList:
        for worldCtrlLow in cmds.ls(('World_Ctrl.Low', '*:World_Ctrl.Low'), long=True):
            worldCtrl = worldCtrlLow.split('.')[0]
            if not originalWorldCtrlList.count(worldCtrl):
                if cmds.referenceQuery(worldCtrl, isNodeReferenced=True):
                    rslvName = cmds.referenceQuery(worldCtrl, filename=True)
                    lowFile = rslvName.replace('.ma', '_LOW.mb').replace('.mb', '_LOW.mb').split('{')[0]
                    if os.path.isfile(lowFile):
                        cmds.file(lowFile, lr=cmds.file(rslvName, q=True, rfn=True))

def setLod():
    lodNodeList = cmds.ls('|LOD_*')
    if lodNodeList:
        cmds.delete(lodNodeList)

    distanceBase = 0.4
    threshold1Multiple = 2
    worldCtrlLowList = cmds.ls(('World_Ctrl.Low', '*:World_Ctrl.Low'), long=True)
    if worldCtrlLowList:
        for worldCtrlLow in worldCtrlLowList:
            cmds.setAttr(worldCtrlLow, 1)

            lodPrefix = 'LOD_'+worldCtrlLow.split('|')[-1].split('.')[0].replace(':', '__')
            alert(lodPrefix);
            cmds.group(empty=True, name=lodPrefix+'0')
            cmds.addAttr(lodPrefix+'0', ln='Lv', at='long', min=0, dv=0)
            cmds.setAttr(lodPrefix+'0.Lv', e=True, keyable=True)
            cmds.group(empty=True, name=lodPrefix+'1')
            cmds.addAttr(lodPrefix+'1', ln='Lv', at='long', min=0, dv=2)
            cmds.setAttr(lodPrefix+'1.Lv', e=True, keyable=True)
            cmds.group(empty=True, name=lodPrefix+'2')
            cmds.addAttr(lodPrefix+'2', ln='Lv', at='long', min=0, dv=1)
            cmds.setAttr(lodPrefix+'2.Lv', e=True, keyable=True)

            cmds.select((lodPrefix+'0', lodPrefix+'1', lodPrefix+'2'), replace=True)
            mel.eval('LevelOfDetailGroup')
            lodGroupNode = cmds.rename(cmds.ls(selection=True)[0], lodPrefix)

            worldCtrlNs = ''
            if worldCtrlLow.split('|')[-1].count(':'):
                worldCtrlNs = worldCtrlLow.split('|')[-1].split(':')[0]

            pcTarget = worldCtrlLow.split('.')[0]
            try:
                if worldCtrlNs:
                    chkTarget = worldCtrlNs+':Root_Ctrl'
                    if cmds.ls(chkTarget): pcTarget = chkTarget
                    else: chkTarget = worldCtrlNs+':Move_Ctrl'

                    if cmds.ls(chkTarget): pcTarget = chkTarget

                else:
                    chkTarget = pcTarget+'|*|*|*|*|*|Root_Ctrl'
                    if cmds.ls(chkTarget): pcTarget = chkTarget
                    else: chkTarget = pcTarget+'|*|Move_Ctrl'

                    if cmds.ls(chkTarget): pcTarget = chkTarget

            except: pass

            cmds.parentConstraint((pcTarget, lodGroupNode), weight=1)

            lowGrp = worldCtrlLow.split('.')[0]
            if worldCtrlLow.count('Rig_Box'):
                if worldCtrlNs: lowGrp = worldCtrlLow.split('Rig_Box')[0]+'Mod_Box|'+worldCtrlNs+':Low_Grp'
                else: lowGrp = worldCtrlLow.split('Rig_Box')[0]+'Mod_Box|Low_Grp'

            elif worldCtrlLow.count('Rig_Grp'):
                if worldCtrlNs: lowGrp = worldCtrlLow.split('Rig_Grp')[0]+'Mod_Grp|'+worldCtrlNs+':Low_Grp'
                else: lowGrp = worldCtrlLow.split('Rig_Grp')[0]+'Mod_Grp|Low_Grp'

            if not lowGrp:
                continue

            size = 1
            if cmds.ls(lowGrp):
                bBox = cmds.xform(lowGrp, q=True, boundingBoxInvisible=True)
                x2 = bBox[3]
                if x2 > 0: x2 = x2 * -1
                y2 = bBox[4]
                if y2 > 0: y2 = y2 * -1
                z2 = bBox[5]
                if z2 > 0: z2 = z2 * -1
                size = (abs(abs(bBox[0]) + x2) + abs(abs(bBox[1]) + y2) + abs(abs(bBox[2]) + z2)) / 3

            threshold0 = 250
            lodCamList = cmds.listConnections(lodGroupNode, type='camera', d=False)
            if lodCamList:
                lodCamShapeList = cmds.listRelatives(lodCamList, shapes=True)
                threshold0 = cmds.getAttr(lodCamShapeList[0]+'.focalLength') * size * distanceBase

            cmds.setAttr(lodGroupNode+'.threshold[0]', threshold0)
            cmds.setAttr(lodGroupNode+'.threshold[1]', threshold0 * threshold1Multiple)

            cmds.shadingNode('condition', name=lodPrefix+'Condition0', asUtility=True)
            cmds.setAttr(lodPrefix+'Condition0.operation', 2)
            cmds.setAttr(lodPrefix+'Condition0.colorIfFalseR', 0)
            cmds.shadingNode('condition', name=lodPrefix+'Condition1', asUtility=True)
            cmds.setAttr(lodPrefix+'Condition1.operation', 2)
            cmds.setAttr(lodPrefix+'Condition1.colorIfFalseR', 0)
            cmds.shadingNode('condition', name=lodPrefix+'Condition2', asUtility=True)
            cmds.setAttr(lodPrefix+'Condition2.operation', 2)
            cmds.setAttr(lodPrefix+'Condition2.colorIfFalseR', 0)

            cmds.connectAttr(lodPrefix+'0.lodVisibility', lodPrefix+'Condition0.firstTerm', force=True)
            cmds.connectAttr(lodPrefix+'1.lodVisibility', lodPrefix+'Condition1.firstTerm', force=True)
            cmds.connectAttr(lodPrefix+'2.lodVisibility', lodPrefix+'Condition2.firstTerm', force=True)

            cmds.connectAttr(lodPrefix+'0.Lv', lodPrefix+'Condition0.colorIfTrue.colorIfTrueR', force=True)
            cmds.connectAttr(lodPrefix+'1.Lv', lodPrefix+'Condition1.colorIfTrue.colorIfTrueR', force=True)
            cmds.connectAttr(lodPrefix+'2.Lv', lodPrefix+'Condition2.colorIfTrue.colorIfTrueR', force=True)

            cmds.shadingNode('plusMinusAverage', name=lodPrefix+'plusMinusAverage', asUtility=True)
            cmds.setAttr(lodPrefix+'plusMinusAverage.operation', 1)

            cmds.connectAttr(lodPrefix+'Condition0.outColorR', lodPrefix+'plusMinusAverage.input1D[0]', force=True)
            cmds.connectAttr(lodPrefix+'Condition1.outColorR', lodPrefix+'plusMinusAverage.input1D[1]', force=True)
            cmds.connectAttr(lodPrefix+'Condition2.outColorR', lodPrefix+'plusMinusAverage.input1D[2]', force=True)

            cmds.connectAttr(lodPrefix+'plusMinusAverage.output1D', worldCtrlLow, force=True)

        lodNodeList = cmds.ls('|LOD_*')
        if lodNodeList:
            cmds.select(lodNodeList, replace=True)
            cmds.group(name='LOD_Grp')

def applyLod():
    def setLodEv(_):
        setLod()

    def updateLodThresholdEv(_):
        updateLodThreshold()

    def changeAssetQualityByAttributeEv(_):
        changeAssetQualityByAttribute(True)

    def changeShotAssetQualityEv(_):
        changeShotAssetQuality(True)

    if 'WMSLODSettingWindow' in cmds.lsUI(windows=True):
        cmds.deleteUI('WMSLODSettingWindow')
    cmds.window('WMSLODSettingWindow', title=u'LOD 설정', width=250, height=90)
    cmds.showWindow()
    cmds.columnLayout(adj=1)
    cmds.button(u'뷰포트의 카메라로 LOD 적용', height=30, command=setLodEv)
    cmds.button(u'선택된 에셋의 Low 재설정', height=30, command=updateLodThresholdEv)
    cmds.button(u'현재 프레임 에셋 전환', height=30, command=changeAssetQualityByAttributeEv)
    cmds.button(u'전체 프레임 에셋 전환', height=30, command=changeShotAssetQualityEv)
    cmds.window('WMSLODSettingWindow', e=True, width=250, height=90)

    if not cmds.ls('|LOD_*'):
        setLod()
        
def changeTextureQuality():
    # 1.0.0 -->
    def toOriginalTextureEv(_):
        #toOriginalTexture()
        if linkOriginalTexture(LOCAL_ROOT):
            noticeWindow(u'Original 텍스쳐를로 변경되었습니다.')
        else:
            noticeWindow(u'Original로 변경된 텍스쳐가 없습니다.')
    
    def toLowestTextureEv(_):
        #toLowTexture('lowest')
        if linkLowTexture(LOCAL_ROOT, 'lowest'):
            noticeWindow(u'Lowest 텍스쳐를로 변경되었습니다.')
        else:
            noticeWindow(u'Lowest 로 변경된 텍스쳐가 없습니다.')
            
    def toLowTextureEv(_):
        #toLowTexture('low')
        if linkLowTexture(LOCAL_ROOT, 'low'):
            noticeWindow(u'Low 텍스쳐를로 변경되었습니다.')
        else:
            noticeWindow(u'Low 로 변경된 텍스쳐가 없습니다.')
            
    def toMediumTextureEv(_):
        #toLowTexture('medium')
        if linkLowTexture(LOCAL_ROOT, 'medium'):
            noticeWindow(u'Medium 텍스쳐를로 변경되었습니다.')
        else:
            noticeWindow(u'Medium 로 변경된 텍스쳐가 없습니다.')
            
    def toHighTextureEv(_):
        #toLowTexture('high')
        if linkLowTexture(LOCAL_ROOT, 'high'):
            noticeWindow(u'High 텍스쳐를로 변경되었습니다.')
        else:
            noticeWindow(u'High 로 변경된 텍스쳐가 없습니다.')
            
    if 'WMSChangeTextureQualityWindow' in cmds.lsUI(windows=True):
        cmds.deleteUI('WMSChangeTextureQualityWindow')
    cmds.window('WMSChangeTextureQualityWindow', title=u'텍스쳐 링크 변경', width=250, height=100)
    cmds.showWindow()
    cmds.columnLayout(adj=1)
    cmds.text(l=u'씬을 열 때 변환되는 텍스쳐는\nLowest, Low만 지원됩니다.')
    cmds.button(u'원본 텍스쳐로 변경', height=30, command=toOriginalTextureEv)
    cmds.button(u'Lowest(10%) 텍스쳐로 변경', height=30, command=toLowestTextureEv)
    cmds.button(u'Low(25%) 텍스쳐로 변경', height=30, command=toLowTextureEv)
    cmds.button(u'Medium(50%) 텍스쳐로 변경', height=30, command=toMediumTextureEv)
    cmds.button(u'High(75%) 텍스쳐로 변경', height=30, command=toHighTextureEv)
    # 1.0.0 <--
    
def newWork(w):
    '''해당 작업을 새로 연다.'''
    smgpath_make(w.dir)
    mayascene_new(w.mb)
    fps = workFPS(w)
    mayascene_setFrameRate(fps)
    mayascene_setAnimationRange(1, fps*2)
    mayascene_setPlaybackRange(1, fps)
    mayascene_setCurrentFrame(1)
    cmds.setAttr("defaultResolution.width", 1280)
    cmds.setAttr("defaultResolution.height", 720)
    newWorkProcess(w)
    #saveScene(w.mb, 'new')

def newWorkProcess(w):
    if w.process == 'animation':
        # 애니메이션의 경우 씬을 처음 생성할 때
        # 씬에 등록된 셋에을 자동으로 다운받도록 한다.
        resp = smgweb_post(
            w.hostip,
            '/wms/app/pipeline/script/process_info.php',
            {
                'project_id' : w.prjid,
                'wid' : 'base__' + w.name
            }
        )
        root = ET.XML(resp)
        infoEls = root.getiterator("information")
        assets = []
        for el in infoEls:
            if str(el.get('name')).lower() in ['ch', 'bg', 'pr', 'asset']:
                if el.text is not None:
                    el.text.split(',')
                    assets.extend(el.text.split(','))
        if not assets:
            return
        assetPrjid = w.prjid.replace('__shot', '__asset')
        fails = []
        for a in assets:
            a = a.strip()
            aw = Work(w.hostip, assetPrjid, a, 'rigging')
            fails.extend(referenceWorks([aw]))
        if fails:
            msg = u'다음 작업이 진행되지 않아 불러오지 못했습니다.\n'
            msg += '\n'.join(fails)
            noticeWindow(msg)

def importWorks(works):
    '''해당 작업들을 현재 씬에 가져온다.'''
    fails = []
    for w in works:
        downloadRelatedWorks(w)
        if not os.path.exists(w.mb):
            fails.append(w.name)
            continue
        useNs = bool(1 - mayaoption_load('WMS_ImportWithoutNamespace', failValue=0))
        ns = w.name
        '''
        if useNs:
            if mayaoption_load('WMS_ImportNamespaceType', 'R') == 'R':
                ns = 'R'
            elif mayaoption_load('WMS_ImportNamespaceType', 'B') == 'B':# 1.01
                ns = 'B'# 1.01
            else:
                ns = w.name
        else:
            ns = None
        '''
        mayascene_embed(w.mb, useNamespace=useNs, namespace=ns)
    return fails

def referenceWorks(works):
    '''해당 작업들을 현재 씬에 레퍼런스로 부른다.'''
    fails = []
    for w in works:
        downloadRelatedWorks(w)
        if not os.path.exists(w.mb):
            fails.append(w.name)
            continue
        ns = w.name
        print ns
        '''
        if mayaoption_load('WMS_ImportNamespaceType', 'R') == 'R':
            ns = 'R'
        elif mayaoption_load('WMS_ImportNamespaceType', 'B') == 'B':# 1.01
            ns = 'B'# 1.01
        else:
            ns = w.name
        '''
        openPath = w.mb
        lowPath = w.mb.replace('.mb', '_LOW.mb').replace('.ma', '_LOW.mb')
        if os.path.isfile(lowPath):
            ok = askWindow(u'해당 에셋은 Low를 사용할 수 있습니다.\nLow 에셋으로 불러들이시겠습니까?\n(에셋 퀄리티 전환 기능을 사용하여 원본으로 전환 가능합니다)')
            if ok:
                openPath = lowPath

        if w.mb.count('/SET_'): mayascene_embed(w.mb, useNamespace=False)
        else: mayascene_reference(openPath, namespace=ns)

    return fails

def saveWork(w):
    '''작업을 저장한다.'''
    diffWork = 0
    if w.mb != mayascene_path():
        diffWork = 1
        ok = askWindow(u'열려있는 씬이 저장하려는 작업과 다릅니다.\n정말로 저장하시겠습니까?', title=u'저장확인')
        if not ok:
            return

    refs = getAllRefs()
    relrefs = makeRelativeReferences(w, refs)

    # 작업 저장
    if w.process == 'animation':
        linkOriginalTexture(LOCAL_ROOT)
        cmds.evalDeferred(partial(linkLowTexture, LOCAL_ROOT))

    elif w.process == 'simulation':
        refFileList = cmds.file(q=True, reference=True)
        if refFileList:
            for refFile in refFileList:
                lowPath = refFile.split('{')[0].replace('.ma', '_LOW.mb').replace('.mb', '_LOW.mb')
                if os.path.isfile(lowPath):
                    cmds.file(lowPath, lr=cmds.file(refFile, q=True, rfn=True))
                    messageprint(os.path.basename(refFile).split('{')[0]+u' 파일은 Low로 교체되었습니다.')

    elif w.process == 'stereoscopic':
        stereoscopicTool()

    elif diffWork and (w.process == 'shading' or w.process == 'mapping'):
        saveUVSnapshot()

    saveScene(w.mb, 'save')

    # XML 생성
    checknum = checkTime()
    saveWorkXML(w, checknum, relrefs)

def saveWorkXML(w, checknum, relrefs, matInfo=False, existInfo=False):
    global WMS_ACCOUNT
    '''현재 씬을 바탕으로 작업 정보를 작업 xml파일에 저장한다.'''
    at = ''
    if w.assetType in AssetType.labels:
        at = AssetType.id(w.assetType)

    existEl = None
    if os.path.isfile(w.xml):
        existEl = ET.parse(w.xml)

    rootEl = ET.Element('root')

    ET.SubElement(
        rootEl, 'information',
        dict(
            project=w.prj, pipeline=w.prjtype,
            process=w.process, work=w.name,
            checknum=checknum, size=str(os.stat(w.mb).st_size),
            type=at, updated=time.strftime('%Y-%m-%d %H:%M:%S'),
            account=WMS_ACCOUNT, worker=w.workerID, host_ip=WMS_HOST, project_ip=w.hostip, ip=socket.gethostbyname(socket.gethostname())
        )
    )

    ET.SubElement(
        rootEl, 'frame',
        dict(
            # mayascene_animation{Start|End}는 int를 반환하기에 float이었던 기존 데이터 유지를 위해 쓰지 않음.
            start=str(cmds.playbackOptions(q=True, animationStartTime=True)),
            end=str(cmds.playbackOptions(q=True, animationEndTime=True)),
            fps=str(mayascene_frameRate())
        )
    )

    for ref in cmds.file(q=True, reference=True):
        topNode = ''
        refNs = cmds.file(ref, q=True, namespace=True)
        nsTrList = cmds.ls(refNs+':*', transforms=True, long=True, referencedNodes=True)
        if nsTrList:
            nsTrList.sort()
            topNode = nsTrList[0]

        refChecknum = ''
        refPath = ref.split('{')[0].replace('_LOW.', '.').replace('_PRX.', '.')
        xmlPath = os.path.splitext(refPath)[0]+'.xml'
        if os.path.isfile(xmlPath):
            refRootEl = ET.parse(xmlPath)
            refInfoEl = refRootEl.find('information')
            if refInfoEl is None:
                refInfoEl = refRootEl.find('infomation')
            refChecknum = refInfoEl.attrib['checknum']

        ET.SubElement(rootEl, 'reference',
            dict(
                path=refPath.split('/work/')[-1],
                checknum=refChecknum,
                resolved_name=ref,
                top_node=topNode
            )
        )

    global shdVerDict
    if shdVerDict != None:
        arrCnt = 0
        for shName in shdVerDict['name']:
            shChecknum = shdVerDict['checknum'][arrCnt]
            ET.SubElement(rootEl, 'shader',
                dict(
                    name=shName,
                    checknum=shChecknum
                )
            )
            arrCnt +=  1

    else:
        if existInfo and existEl:
            for prop in existEl.findall('shader'):
                ET.SubElement(rootEl, 'shader', prop.attrib)

    global hairVerDict
    if hairVerDict != None:
        arrCnt = 0
        for hairName in hairVerDict['name']:
            hairChecknum = hairVerDict['checknum'][arrCnt]
            ET.SubElement(rootEl, 'hair',
                dict(
                    name=hairName,
                    checknum=hairChecknum
                )
            )
            arrCnt +=  1

    else:
        if existInfo and existEl:
            for prop in existEl.findall('hair'):
                ET.SubElement(rootEl, 'hair', prop.attrib)

    global abcEtag
    if abcEtag != None:
        ET.SubElement(rootEl, 'abc',
            dict(
                etag=abcEtag
            )
        )

    else:
        if existInfo and existEl:
            for prop in existEl.findall('abc'):
                ET.SubElement(rootEl, 'abc', prop.attrib)

    if matInfo:
        for sg in cmds.ls(type='shadingEngine'):
            mat = cmds.connectionInfo(sg+'.surfaceShader', sfd=1).split('.')[0]
            if mat:
                matType = cmds.nodeType(mat)
            else:
                matType = 'unknown'
            assnList = cmds.sets(sg, q=1)
            if not assnList:
                continue

            matName = ''
            sgMat = cmds.ls(cmds.listConnections(sg, destination=False, source=True, plugs=False), materials=True)
            if sgMat:
                matName = list(set(sgMat))[0]

            for assn in assnList:
                assnNode = assn
                longNames = cmds.ls(assn, long=True)
                if longNames:
                    assnNode = longNames[0]
                matEl = ET.SubElement(rootEl, 'material', dict(name=matName, shading_engine=sg, type=matType, assigned=assnNode))

                assignedSplit = assn.split('.')
                if cmds.nodeType(assignedSplit[0]) == 'mesh':
                    uvSetInds = cmds.polyUVSet(assignedSplit[0], query=True, allUVSetsIndices=True)
                    if uvSetInds != None and len(uvSetInds) > 1:
                        for uvSetInd in uvSetInds[1:]:
                            uvSetTex = cmds.uvLink(query=True, uvSet=assignedSplit[0]+'.uvSet['+str(uvSetInd)+'].uvSetName')
                            if uvSetTex:
                                ET.SubElement(matEl, 'uvset', dict(index=str(uvSetInd), texture=','.join(uvSetTex) ))

    with open(w.path+'.xml', 'w') as f:
        f.write(ET.tostring(rootEl, 'utf-8'))
        shdVerDict = None

def exportToWork(w):
    '''현재 씬을 (일부분 또는 전체) 다른 작업에 덮어쓴다.'''
    answer = selectionWindow(u'주의 : 선택된 작업을 백업한 후 덮어 씁니다!\n\n범위를 선택해주세요.', title=u'다른 작업에 덮어 쓰기', items=[u'전체', u'선택된 오브젝트'])
    if not answer:
        return
    # 백업
    try:
        backupScene(w.mb, 'before_overwrited', True)
    except RuntimeError:
        debugprint(u'백업하려는 씬이 없습니다.')
    # 내보내기
    if answer == u'전체':
        mayascene_exportAll(w.mb)
        messageprint(u'씬을 {work}에 저장하였습니다.'.format(work=w.mb))
    elif answer == u'선택된 오브젝트':
        mayascene_exportSelection(w.mb)
        messageprint(u'선택된 오브젝트를 {work}에 저장하였습니다.'.format(work=w.mb))
    else:
        raise ValueError('unknown export option - ' + answer)

def workFPS(w):
    '''
    작업의 fps를 찾는다.
    중요도는 에피소드 fps > 프로젝트 fps 순이다.
    어떤 곳에도 fps 정보가 없다면 25가 반환된다.
    '''
    def projectFPS():
        resp = smgweb_post(
            w.hostip,
            '/wms/app/pipeline/script/header_info.php',
            {
                'project_id' : w.prjid
            }
        )
        rootEl = ET.XML(resp)
        infoEl = rootEl.getiterator('information')
        if infoEl is None:
            infoEl = rootEl.getiterator('infomation')
        for el in infoEl:
            if el.get('name') == 'framerate':
                if el.text:
                    return int(el.text.rstrip('fps'))

    def episodeFPS():
        resp = smgweb_post(
            w.hostip,
            '/wms/app/pipeline/script/class_info.php',
            {
                'project_id' : w.prjid,
                'class' : 'episode',
                'work' : w.episode,
                'process' : 'base'
            }
        )
        rootEl = ET.XML(resp)
        header = rootEl.find('header')
        if header is None:
            return
        infoEl = header.getiterator('information')
        if infoEl is None:
            infoEl = header.getiterator('infomation')
        for el in infoEl:
            if el.get('name') == 'framerate':
                if el.text:
                    return int(el.text.rstrip('fps'))

    def myFPS():
        resp = smgweb_post(
            w.hostip,
            '/wms/app/pipeline/script/process_info.php',
            {
                'project_id' : w.prjid,
                'wid' : 'base__'+w.name
            }
        )
        rootEl = ET.XML(resp)
        process = rootEl.find('process')
        if process is None:
            return
        infoEl = process.getiterator('information')
        if infoEl is None:
            process.getiterator('infomation')
        for el in infoEl:
            if el.get('name') == 'fps' or el.get('name') == 'framerate':
                if el.text:
                    return int(el.text.rstrip('fps'))

    myfps = myFPS()
    if myfps:
        print(u'작업 fps - ' + str(myfps))
        return myfps
    epfps = episodeFPS()
    if epfps:
        print(u'에피소드 fps - ' + str(epfps))
        return epfps
    prjfps = projectFPS()
    if prjfps:
        print(u'프로젝트 fps - ' + str(prjfps))
        return prjfps

    return 25

def havePermission(account, w):
    '''작업자가 해당 작업에 대한 권한이 있는지 체크한다.'''
    if w.workerID == account:
        return True
    resp = smgweb_post(
        w.hostip,
        '/wms/script/check_permission.php',
        {
            'account' : account,
            'relation' : w.prjid
        }
    )
    root = ET.XML(resp)
    for el in root.getiterator('relation'):
        if el.attrib['relation'] == w.process and el.attrib['level']:
            return True
    return False

def lockInfo(w):
    '''작업의 잠김 상태를 확인한다. 반환값은 (잠김, 잠근계정, 잠근이) 이다.'''
    wid = w.process+'__'+w.name
    resp = smgweb_post(
        w.hostip,
        '/wms/app/pipeline/script/process_info.php',
        {
            'project_id':w.prjid,
            'wid':wid
        }
    )
    rootEl = ET.XML(resp)
    pel = rootEl.find('process')
    states = pel.attrib['state'].split(',')
    if 'lock' not in states:
        return False, '', ''
    # 잠근이 확인
    if pel.find('logs') is None:
        raise KeyError('{work} locked, but log not found.'.format(work=wid))
    logs = pel.find('logs').findall('log')
    if not logs:
        raise KeyError('{work} locked, but log not found.'.format(work=wid))

    lockerAccount = ''
    lockerName = ''
    find = False
    for l in reversed(logs):
        if l.attrib['type'] == 'state':
            if l.attrib['state'] == 'lock':
                if l.attrib['operation'] != 'add':
                    raise ValueError("{work} locked, but last operation is not 'add'".format(work=wid))
                else:
                    find = True
                    lockerAccount = l.attrib['account']
                    lockerName = l.attrib['name']
                    break
                if not lockerAccount:
                    raise ValueError('{work} locked, but not found worker'.format(work=wid))
    if not find:
        raise ValueError('{work} locked, but not found a log'.format(work=wid))

    return True, lockerAccount, lockerName

def lockWork(w, account, name):
    '''서버에 작업 잠금을 요청하고, 작업의 `locked`, `lockerAccount`, `lockerName` 변수를 수정한다.'''
    resp = smgweb_post(
        w.hostip,
        '/wms/app/pipeline/script/update_process_state.php',
        {
            'project_id':w.prjid,
            'wid':w.process+'__'+w.name,
            'account':account,
            'state':'lock',
            'operation':'add'
        }
    )
    rootEl = ET.XML(resp)
    warn = rootEl.find('warning')
    if warn is not None:
        if warn.text:
            return warn.text
        return warn.attrib.decode('utf8')
    w.locked = True
    w.lockerAccount = account
    w.lockerName = name

def unlockWork(w, account):
    '''서버에 작업 잠금해제를 요청하고, 작업의 `locked`, `lockerAccount`, `lockerName` 변수를 수정한다.'''
    resp = smgweb_post(
        w.hostip,
        '/wms/app/pipeline/script/update_process_state.php',
        {
            'project_id':w.prjid,
            'wid':w.process+'__'+w.name,
            'account':account,
            'state':'lock',
            'operation':'remove'
        }
    )
    rootEl = ET.XML(resp)
    warn = rootEl.find('warning')
    if warn is not None:
        if warn.text:
            return warn.text
        return warn.attrib.decode('utf8')
    w.locked = False
    w.lockerAccount = ''
    w.lockerName = ''

def workFromPath(scene, hostip):
    '''
    씬 경로를 통해 추측할수 있는 정보만 가진 작업을 반환한다.
    씬 경로가 작업 경로 바깥에 있으면 ValueError를 일으킨다.
    '''
    if not isWorkPath(scene):
        raise ValueError(u'not a work path - '+scene)
    relpath = scene[len(LOCAL_ROOT+'/work/'):]
    prj, prjtype, process, name, _ = relpath.split('/')
    print hostip, 'pipeline__'+prj+'__'+prjtype
    return Work(hostip, 'pipeline__'+prj+'__'+prjtype, name, process)

def isWorkPath(scene):
    '''받아들인 패스가 wms작업 경로인지 판단한다. 여기로 들어오는 패스는 마야씬패스여야 한다.'''
    if not re.match(LOCAL_ROOT+'/work/', scene, re.I):
        return False
    relpath = scene[len(LOCAL_ROOT+'/work/'):].split('/')
    if len(relpath) != 5:
        return False
    d, f = relpath[-2:]
    if os.path.splitext(f)[0] != d:
        return False
    return True

def workDirPath(prj, prjtype, process, name):
    '''작업정보를 통해 해당 작업의 디렉토리 경로를 반환한다. 마지막에 경로 구분자는 붙지 않는다.'''
    return LOCAL_ROOT+"/work/"+prj+"/"+prjtype+"/"+process+"/"+name

def workScenePath(prj, prjtype, process, name):
    '''작업정보를 통해 해당 작업의 씬 경로를 반환한다.'''
    return LOCAL_ROOT+"/work/"+prj+"/"+prjtype+"/"+process+"/"+name+"/"+name+".mb"

# 저장 및 백업
def saveScene(scenepath, label):
    '''현재 씬을 저장한다. 이전 파일은 백업한다.'''
    if not scenepath:
        scenepath = mayascene_path()
    smgpath_make(os.path.dirname(scenepath))
    now = time.strftime('%Y%m%d_%H%M%S')
    lastBackup = ''
    if os.path.exists(scenepath):
        lastBackup = backupScene(scenepath, 'before_'+label, False, timestamp=now)
    # 저장
    with mayaviewport_TempAppearance(mayascene_viewports(), 'wireframe'):
        scene = mayascene_saveAs(scenepath)
        cmds.evalDeferred(partial(cmds.file, modified=False))
    if not scene:
        noticeWindow(u'저장된 파일에 문제가 있습니다!')
        raise RuntimeError('file has no name.')
    if lastBackup:
        cursize = os.path.getsize(scene)
        lastsize = os.path.getsize(lastBackup)
        percent = float(cursize)/lastsize * 100
        if percent < 95:
            msg = [
                u'지난 파일에 비해 사이즈가 줄어들었습니다. ({0:.0f}%)\n'.format(percent),
                u'지난 파일 : {0:.2f}MB'.format(float(lastsize)/1024/1024),
                u'현재 파일 : {0:.2f}MB\n'.format(float(cursize)/1024/1024),
                u'문제가 있다고 생각하시면 새 마야창을 열어 파일을 확인해주세요.'
            ]
            noticeWindow('\n'.join(msg))
    backup = backupScene(scenepath, label, True, timestamp=now)
    messageprint(u'{0}로 저장되었습니다. (백업 : {1})'.format(os.path.basename(scenepath), os.path.basename(backup)))

def backupScene(scene, label, force, timestamp=''):
    '''
    파일을 백업하고 마지막으로 백업된 파일의 패스를 반환한다.
    force가 False이고 현재 파일과 마지막으로 백업된 파일이 동일하다면 백업하지 않고 마지막 파일만 반환한다.
    '''
    if not os.path.isfile(scene):
        raise RuntimeError(u'백업하려는 파일이 없습니다.')
    if not force:
        bfs = backupFiles(scene)
        if bfs and filecmp.cmp(bfs[-1], scene):
            return bfs[-1]
    d, n, _ = smgpath_split(scene)
    smgpath_make(d + '/.save')
    if not timestamp:
        timestamp = time.strftime('%Y%m%d_%H%M%S')
    backuppath = d+'/.save/'+n+'__'+timestamp+'.mb'
    if label:
        backuppath = d+'/.save/'+n+'__'+timestamp+'.'+label+'.mb'
    shutil.copy(scene, backuppath)
    messageprint(u'씬 파일이 {0} 로 백업되었습니다.'.format(backuppath))
    return backuppath

def backupFiles(scene):
    '''백업 파일 리스트를 반환한다. 여기서 백업 파일은 해당 씬 디렉토리 밑 .save 디렉토리 안에 있는 파일이다.'''
    d, n, _ = smgpath_split(scene)
    bd = d + '/.save'
    if not os.path.isdir(bd):
        return None
    bfs = []
    for f in os.listdir(bd):
        # 파일이 백업파일 형식을 갖추었는지 체크한다.
        m = re.match(n + r'__(\d+_\d+).*\w*.mb', f)
        if not m:
            continue
        bfs.append(bd+'/'+f)
    return sorted(bfs)


# 레퍼런스
def getAllRefs(scene=''):
    '''씬의 모든 하위 레퍼런스들을 재귀적으로 검색해 반환한다.'''
    allrefs = []
    def getRefs(scn=''):
        try:
            if scn: refs = cmds.referenceQuery(scn, child=True, filename=True)
            else: refs = cmds.file(q=1, reference=1)
        except:
            refs = None

        if not refs:
            return

        for r in refs:
            r = r.split('{')[0] # 같은 파일을 레퍼런스 했을때 뒤에 붙는 {0}, {1} 등 제거
            if r not in allrefs:
                allrefs.append(r.replace('_LOW.', '.').replace('_PRX.', '.'))
                getRefs(r)

    getRefs(scene)
    return allrefs

def makeRelativeReferences(work, refs):
    '''
    관리되지 않는 경로에 있는 레퍼런스를 관리경로 내로 복사할것인지 물어본다.
    최종적으로 관리되고 있는 레퍼런스 경로를 리스트로 반환한다.
    '''
    if not [r for r in refs if os.path.splitext(r)[-1] == '.mb']:
        return []
    relrefs = []

    # 레퍼런스가 관리되는 경로에 있는지 여부에 따라 분류
    def validRef(work, ref):
        rdir, _ = os.path.split(ref)
        rxml = os.path.splitext(ref)[0]+'.xml'
        isthisref = re.match(work.dir+'/reference', rdir, re.I) # TODO : 마찬가지.
        isotherwork = re.match(LOCAL_ROOT, rdir, re.I) and os.path.isfile(rxml)
        isotherref = re.match(LOCAL_ROOT, rdir, re.I) and rdir.endswith('/reference')
        return any([isthisref, isotherwork, isotherref])

    validrefs = []
    invalidrefs = []
    for r in refs:
        if validRef(work, r):
            validrefs.append(r)
        else:
            invalidrefs.append(r)

    # 어떤 작업의 레퍼런스 디렉토리로 복사된 파일은 추가하지 않는다.
    for r in validrefs:
        if not r.count('/reference/'):
            relrefs.append(r.split('/work/')[-1])

    # 모든 레퍼런스파일이 다 관리경로에 있다면 더이상 할 일이 없다.
    if not invalidrefs:
        return relrefs

    # 관리되지 않는 경로에 있는 레퍼런스파일을 현재 작업 디렉토리의 reference폴더 안에 넣는다.
    invnames = [os.path.basename(r) for r in invalidrefs]
    msg = u'{n}개의 레퍼런스가 관리되지 않는 경로에 있습니다.\n\n'.format(n=len(invalidrefs))
    msg += '\n'.join(invnames)
    msg += u'\n\n작업 폴더로 가져오시겠습니까?'
    ok = askWindow(msg)
    if not ok:
        return relrefs

    smgpath_make(work.dir+'/reference')
    for r in invalidrefs:
        if r.count('{'): # 중복 레퍼런스 제거
            continue
        localr = work.dir + '/reference/' + os.path.basename(r)
        try: shutil.copy(r, localr)
        except:
            #messageprint("copied failed: {r} -> {localr}".format(r=r, localr=localr))
            print '[message] copied:', copied, r, '->', localr
            continue

        #messageprint("copied : {r} -> {localr}".format(r=r, localr=localr))
        print '[message] copied:', copied, r, '->', localr
        
        # 관련노드 패스 변경
        rnode = cmds.file(r, q=True, referenceNode=True)
        cmds.file(localr, loadReference=rnode, type='mayaBinary', options='v=0;')
        relrefs.append(localr)

    return relrefs

# 렌더
def renderPath(workpath):
    '''로컬 WMS 경로를 받아 드라이브를 R:로 변경해서 돌려준다.'''
    if not re.match(LOCAL_ROOT, workpath, re.I):
        raise KeyError('file must be inside of ' + LOCAL_ROOT)
    return RENDER_DRIVE+workpath[len(WMS_DRIVE):]

def renderScene():
    # 다시 디자인 해야 한다. 일반 작업과 경로를 맞출것인가??
    raise RuntimeError('unimplemented yet.')

def copyRenderResourcesToRenderDrive():
    '''
    렌더를 걸기 위한 씬 자원 복사.
    같은 파일이 이미 렌더드라이브에 있다면 복사하지 않는다.
    텍스쳐 복사가 성공했다면 True, 실패했다면 False를 반환한다.
    '''
    scenepath = mayascene_path()
    if not re.match(LOCAL_ROOT, scenepath, re.I):
        raise RuntimeError("current opened scene should inside LOCAL_ROOT")

    # 렌더 디렉토리로 복사할 파일 추가
    # 프로젝트 워크스페이스
    srcfiles = []
    if isWorkPath(scenepath):
        w = workFromPath(scenepath, WMS_HOST) # TODO: prjFromPath(scenepath)
        srcfiles.append(''.join([LOCAL_ROOT, '/work/', w.prj, '/workspace.mel']))
    # 레퍼런스 파일
    refs = getAllRefs()
    srcfiles.extend(refs)
    '''
    # 작업 디렉토리 안의 알렘빅 파일
    pths = [scenepath] + refs
    for p in pths:
        if not isWorkPath(p):
            continue
        for root, _, files in os.walk(os.path.dirname(p)+'/abc'):
            for f in files:
                srcfiles.append(root+'/'+f)
    '''
    # 텍스쳐
    for f in mayascene_textures():
        if re.match(LOCAL_ROOT, f, re.I):
            srcfiles.extend(glob.glob(f))
    # 멘탈레이 프록시
    proxies = set()
    for n in cmds.ls(type='mesh'):
        if 'miProxyFile' not in cmds.listAttr(n):
            continue
        f = cmds.getAttr(n+'.miProxyFile')
        if not f:
            continue
        if not re.match(LOCAL_ROOT, f, re.I):
            continue
        proxies.add(f)
    srcfiles.extend(sorted(proxies))

    # 폴더에 있는 파일을 검색해서 추가한 경우는 괜찮지만 씬에 있는 정보를 검색해서 파일을 추가한 경우
    # 파일이 해당경로에 존재하지 않을수도 있다. 이런 경우 작업자에게 질문후 찾지 못한 파일을 뺀채 진행한다.
    notfound = []
    for f in srcfiles:
        if not os.path.isfile(f):
            notfound.append(f)
    if notfound:
        ok = askWindow(u"렌더드라이브로 복사하려는 파일을 찾을수 없습니다. 계속하시겠습니까?\n\n찾지 못한 파일\n\n{0}".format("\n".join(notfound)))
        if not ok:
            return False
        srcfiles = [f for f in srcfiles if f not in notfound]

    # 복사
    for s in set(srcfiles):
        d = renderPath(s)
        if os.path.exists(d):
            if os.stat(s).st_size == os.stat(d).st_size:
                continue
            else:
                os.remove(d)
        smgpath_make(os.path.dirname(d))
        try:
            shutil.copyfile(s, d)
        except:
            noticeWindow(u'{0} 파일을 렌더 드라이브로 복사하는데 실패했습니다'.format(s))
            raise
        # 프록시 파일안의 텍스쳐 주소가 로컬 주소로 되어있기 때문에 파일이 실제 위치에 있지 않아
        # 텍스쳐가 검게 나온다. 이를 렌더 드라이브쪽 주소로 수정한다.
        # 지금으로서는 mi파일안에 있는 텍스쳐 주소를 직접 고치는 방법 말고는 해결책을 모른다.
        if d.endswith('.mi'):
            with open(d, 'rb') as f:
                data = f.read()
            with open(d, 'wb') as f:
                newdata = data.replace(
                    '"' + WMS_DRIVE.encode('utf8') + '/',
                    '"' + RENDER_DRIVE.encode('utf8') + '/'
                ).replace(
                    '"' + WMS_DRIVE.lower().encode('utf8') + '/',
                    '"' + RENDER_DRIVE.encode('utf8') + '/'
                )
                f.write(newdata)
    return True

def relinkTexturesToRenderDrive():
    '''텍스쳐 링크 위치를 렌더드라이브로 변경한다.'''
    changed = []
    for node, wpath in mayascene_textureNodesAndRawPaths():
        if re.match(LOCAL_ROOT, wpath, re.I):
            cmds.setAttr(node+'.fileTextureName', renderPath(wpath), type='string')
            changed.append(renderPath(wpath))
    return changed


# 텍스쳐
def copyTextures(texs, dstd, linkToCopied):
    '''텍스쳐를 대상 디렉토리로 복사한다. linkToCopied가 참이면 텍스쳐의 링크도 함께 변경한다.'''
    if not texs:
        messageprint(u'복사해야 할 텍스쳐 파일이 없습니다.')
        return True
    for t, nodes in texs.iteritems():
        files = [f.replace('\\', '/') for f in glob.glob(t)]
        for f in files:
            try:
                shutil.copy(f, dstd)
                messageprint(u'{f} -> {dstd}로 복사 완료'.format(f=f, dstd=dstd))

            except:
                messageprint(u'{f} -> {dstd}로 복사 실패'.format(f=f, dstd=dstd))

        if linkToCopied:
            for n in nodes:
                oldpath = cmds.getAttr(n+'.fileTextureName')
                newpath = dstd+'/'+os.path.basename(oldpath)
                messageprint(u'{n}의 텍스쳐 경로가 {newpath}로 변경됩니다.'.format(n=n, newpath=newpath))
                cmds.setAttr(n+'.fileTextureName', newpath, type='string')
    messageprint(u'복사가 완료되었습니다.')
    return True

def convertToLowTexture(w, qualities=False):
    '''해당 디렉토리 밑에 있는 텍스쳐를 저해상도로 변경한다.'''
    texDir = w.dir+'/texture'
    smgpath_make(texDir+'/quality')

    # 변환할 텍스쳐 파일 검사.
    convertTextures = []
    for f in os.listdir(texDir):
        if not os.path.isfile(texDir+'/'+f):
            continue
        ext = os.path.splitext(f)[1].lower()
        if ext not in ['.jpeg', '.jpg', '.png', '.exr', '.tiff', '.tif', 'tga']:
            continue
        tex = texDir + '/' + f
        lowesttex = texDir + '/quality/lowest_' + f
        convertTextures.append((tex, lowesttex))
        if qualities:
            lowtex = texDir + '/quality/low_' + f
            convertTextures.append((tex, lowtex))
            mediumtex = texDir + '/quality/medium_' + f
            convertTextures.append((tex, mediumtex))
            hightex = texDir + '/quality/high_' + f
            convertTextures.append((tex, hightex))

    if not convertTextures:
        return

    pgwin = ProgressWindow(u"Converting Textures: {0}".format(w.name), len(convertTextures))

    n = 0
    for tex, lowtex in convertTextures:
        # 커맨드를 실행시킬때 창을 보이지 않는다.
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE

        if not os.path.isfile(lowtex):
            size = '25%'
            if lowtex.count('/quality/lowest_'):
                size = '10%'
            elif lowtex.count('/quality/medium_'):
                size = '50%'
            elif lowtex.count('/quality/high_'):
                size = '75%'

            cmd = [CONVERT, '-resize', size, tex, lowtex]
            p = subprocess.Popen(cmd, stderr=subprocess.PIPE, startupinfo=startupinfo)
            _, err = p.communicate()
            if err:
                warningprint(tex + u' Low 리사이즈 도중 문제가 발생했습니다.\n' + err)

        n += 1
        pgwin.advance(1)

    pgwin.close()


modelPanelState = {}
def toWireframeMode():
    global modelPanelState

    for pnl in cmds.lsUI(panels=True):
        if pnl.count('modelPanel'):
            modelPanelState[pnl] = cmds.modelEditor(pnl, q=True, displayAppearance=True)
            cmds.modelEditor(pnl, e=True, displayAppearance='wireframe')

def fromWireframeMode():
    global modelPanelState

    modelPanelList = modelPanelState.keys()
    if modelPanelList:
        for pnl in modelPanelList:
            try: cmds.modelEditor(pnl, e=True, displayAppearance=modelPanelState[pnl])
            except: pass

        modelPanelState = {}

# 1.0.0 -->
def linkLowTexture(d=LOCAL_ROOT, quality='lowest'):
    result = False
    '''저해상도 텍스쳐로 링크를 변경한다. 저해상도 텍스쳐가 없으면 원본 링크 그대로 놔둔다.'''
    for tex, nodes in mayascene_textures().iteritems():
        if not re.match(d, tex, re.I):
            continue
        if not os.path.dirname(tex).endswith('/texture'):
            continue
        lowtex = os.path.dirname(tex)+'/quality/'+quality+'_'+os.path.basename(tex)
        if not os.path.exists(lowtex):
            lowtex = os.path.dirname(tex)+'/quality/low_'+os.path.basename(tex)
        if not os.path.exists(lowtex):
            lowtex = os.path.dirname(tex)+'/.size/'+quality+'_'+os.path.basename(tex)
        if not os.path.exists(lowtex):
            lowtex = os.path.dirname(tex)+'/.size/low_'+os.path.basename(tex)
        if not os.path.exists(lowtex):
            continue
        for n in nodes:
            cmds.setAttr(n+'.fileTextureName', lowtex, type='string')
            result = True
            
    return result

def linkOriginalTexture(d=LOCAL_ROOT):
    #toWireframeMode()
    result = False
    '''원본 텍스쳐로 링크를 변경한다.'''
    for lowtex, nodes in mayascene_textures().iteritems():
        if not re.match(d, lowtex, re.I):
            continue
        if not ( os.path.dirname(lowtex).endswith('/texture/quality') or os.path.dirname(lowtex).endswith('/texture/.size') ):
            continue
        tex = lowtex.replace('/quality/lowest_', '/').replace('/quality/low_', '/').replace('/quality/medium_', '/').replace('/quality/high_', '/')
        tex = tex.replace('/.size/lowest_', '/').replace('/.size/low_', '/').replace('/.size/medium_', '/').replace('/.size/high_', '/')
        if not os.path.exists(tex):
            print(lowtex + u' 의 원본 파일이 없습니다. 저해상도 텍스쳐를 계속 사용합니다.')
            continue
        for n in nodes:
            cmds.setAttr(n+'.fileTextureName', tex, type='string')
            result = True
            
    return result
# 1.0.0 <--

# 프리뷰
def MS_CAM():
    '''현재 씬에서 첫번째로 검색된 MS_CAM 노드 경로를 반환한다.'''
    try:
        camtr = cmds.ls('MS_CAM', recursive=True)[0]
    except IndexError:
        cmds.error(u'MS_CAM not found.')
    return cmds.listRelatives(camtr, shapes=True)[0]

# previewDir은 임시 함수이다.
# 두돌즈와 티버스터가 끝나면 삭제하고 "/preview"로 대체할 것.
def previewDir(prj):
    if prj in ["doodolls", "t_burster"]:
        return "/attach/preview"
    return "/preview"

def previewWork(w):
    '''선택된 작업의 프리뷰를 건다.'''
    # 할일: 지금은 프로젝트 별로 프리뷰를 저장하는 디렉토리가 달라지기 때문에
    # w를 받는다. 두돌스와 티버스터가 완전히 끝나면 w를 안받게 변경.
    if w.mb != mayascene_path():
        raise RuntimeError("work not match with opened scene.")

    startf, endf = mayascene_animationRange()
    if mayascene_selectedRange():
        if askWindow(u'선택된 영역이 있습니다. 선택된 영역만 거시겠습니까?'):
            startf, endf = mayascene_selectedRange()
    err = makePreview(
        w.dir + previewDir(w.prj) + '/.temp/playblast.%04d.jpg',
        w.dir + previewDir(w.prj) + '/' + w.name + '.mp4',
        startf, endf,
        864, 486,
        MS_CAM(),
        ''
    )
    if err:
        noticeWindow(err)
        return

    # 완료된 클립 디렉토리로 복사
    clipdir = LOCAL_ROOT + '/clip/' + w.prj + '/complete/' + w.episode + '/'
    ok = smgpath_make(clipdir)
    if not ok:
        noticeWindow(u'클립 디렉토리를 만들지 못했습니다.')
        return
    shutil.copy(w.dir + previewDir(w.prj) + '/' + w.name + '.mp4', clipdir)
    messageprint(u'플레이블래스트 완료')

def makePreview(seqpath, mp4path, startf, endf, width, height, camera, soundfile):
    '''시퀀스를 mp4로 변환한다.'''
    ok = smgpath_make(os.path.dirname(seqpath))
    if not ok:
        noticeWindow(u'이미지를 저장할 디렉토리를 만들수 없습니다.')
        return
    mayaviewport_NewPreviewWindow('WMS_PBWindow', width, height, camera)
    cmds.select(cl=1)
    mayaplayblast_sequence(seqpath, startf, endf, width, height)

    # 시퀀스를 MP4로
    ff = smgffmpeg_New(FFMPEG)
    err = ff.SeqToMp4(
        seqpath,
        mp4path,
        width, height,
        startf, endf, mayascene_frameRate(),
        soundfile,
    )
    if err:
        cmds.error(err)

def screenshot(w):
    '''이미지와 썸네일을 만든다.'''
    # 할일: 지금은 프로젝트 별로 프리뷰를 저장하는 디렉토리가 달라지기 때문에
    # w를 받는다. 두돌스와 티버스터가 완전히 끝나면 w를 안받게 변경.
    if w.mb != mayascene_path():
        raise RuntimeError("work not match with opened scene.")
    
    ok = smgpath_make(w.dir+previewDir(w.prj))
    if not ok:
        noticeWindow(u'이미지를 저장할 디렉토리를 만들수 없습니다.')
        return
    with mayarender_OutAsJpeg():
        PrevWin =  mayaviewport_NewPreviewWindow(
            'WMS_PreviewWindow',
            864, 486,
            None
        )
        with PrevWin:
            cmds.select(cl=1)
            # 이미지 생성
            image = w.dir+previewDir(w.prj)+'/'+mayascene_root()+'.jpg'
            mayaplayblast_oneshot(image, mayascene_animationStart(), 864, 486)

            # 썸네일 생성
            # 너무 작은 사이즈로 플레이블래스트를 걸면 이미지가 깨져서
            # 조금 크게 걸어 작게 리사이즈 한다.
            thumbnail = w.dir+previewDir(w.prj)+'/'+'thumb.jpg'
            mayaplayblast_oneshot(thumbnail, mayascene_animationStart(), 400, 400)
    ff = smgffmpeg_New(FFMPEG)
    err = ff.ResizeImage(
        thumbnail,
        thumbnail,
        100, 100,
        overwrite=True
    )
    if err:
        cmds.error(err)

    messageprint(u'스크린샷 완료')

# 유틸리티
def messageprint(contents, prefix=u'[message]', end=''):
    '''프린트'''
    printstring = u'{prefix} {contents}{end}'.format(prefix=prefix, contents=contents, end=end)
    print printstring

def warningprint(contents, prefix=u'[warning]', end=''):
    '''프린트'''
    printstring = u'{prefix} {contents}{end}'.format(prefix=prefix, contents=contents, end=end)
    cmds.warning(printstring)

def debugprint(contents, prefix=u'[debug]', end=''):
    '''디버그 프린트'''
    if not DEV:
        return
    if not prefix:
        linenum = inspect.getouterframes(inspect.currentframe())[1][2] # 부른 함수의 줄번호
        prefix = '[wms:{linenum}]'.format(linenum=linenum)
    messageprint(contents, prefix, end)

def infoID(account):
    '''서버에 (노트, 요청 등) 정보를 전송할때 쓰는 아이디.'''
    return account+'__'+time.strftime('%Y%m%d%H%M%S')

def infoText(infotype, infos):
    '''
    인포메이션을 post로 전달할수 있는 문자열 타입으로 변경한다.
    infoText('information', [('work', 'E001S001C001'), ('progress', 'finished')]))
    # 'information|-CL-|work|-EQ-|E001S001C001|-CM-|progress|-EQ-|finished|-SC-|'
    '''
    ts = []
    for k, v in infos:
        ts.append(u'{0}|-EQ-|{1}'.format(k, v))
    return u'{0}|-CL-|{1}|-SC-|'.format(infotype, '|-CM-|'.join(ts))

def noticeWindow(message, title=u'알림'):
    '''알림 창'''
    cmds.confirmDialog(title=title, message=message, button=[u'확인'])

def askWindow(message, title=u'주의', ok=u'확인', cancel=u'취소'):
    '''질문 창'''
    if cmds.confirmDialog(title=title, message=message, button=[ok, cancel], defaultButton=cancel, cancelButton=cancel, dismissString=cancel) == ok:
        return True
    return False

def selectionWindow(message, items, title=u'선택', cancel=u'취소'):
    '''선택 창'''
    items.append(cancel)
    answer = cmds.confirmDialog(title=title, message=message, button=items, defaultButton=cancel, cancelButton=cancel, dismissString=cancel)
    if answer == cancel:
        return
    return answer

def promptWindow(message, title=u'기입'):
    '''기입 창'''
    result = cmds.promptDialog(
        title=title,
        message=message,
        button=[u'확인', u'취소'],
        defaultButton=u'확인',
        cancelButton=u'취소',
        dismissString=u'취소')
    if result == u'취소':
        return ''
    if result == u'확인':
        return cmds.promptDialog(query=True, text=True)


# 서버 쿼리
def queryOne(hostip, prjid, wid, account): # ==> Work
    '''서버에 하나의 작업을 묻는다. 쿼리에 문제가 있으면 런타임 에러를 낸다.'''
    _, prj, prjtype = prjid.split('__')
    resp =  smgweb_post(
        hostip,
        '/wms/app/pipeline/script/search_process_by_id.php',
        {
            'project_id':prjid,
            'wid':wid,
            'account':account,
        }
    )
    rootEl = ET.XML(resp)
    if rootEl.find('error') is not None:
        raise RuntimeError(rootEl.find('error').text)

    # 모델링 작업은 리깅,
    # 애니메이션 작업은 렌더링의 상태를 추가로 표시해줘야 한다.
    riggingProgress = progressDict(hostip, prjid, 'rigging', account)
    renderingProgress = progressDict(hostip, prjid, 'rendering', account)

    workEl = rootEl.find("work")
    # 찾는 작업이 없을때는 None 반환
    if workEl is None:
        return None
    return parseOne(workEl, hostip, prjid, riggingProgress, renderingProgress)


def queryWorks(hostip, prjid, target, keyword, progress, process, account): # ==> dict[key]Work
    '''서버에 작업 정보를 질의하여 반환한다.'''
    _, prj, prjtype = prjid.split('__')
    resp =  smgweb_post(
        hostip,
        '/wms/app/pipeline/script/search_process.php',
        {
            'project_id':prjid,
            'account':account,
            'target':target,
            'progress':progress,
            'keyword':keyword,
            'process':process
        }
    )
    rootEl = ET.XML(resp)
    if rootEl.find("error") is not None:
        err = rootEl.find("error").attrib['code']
        noticeWindow(err)
        return {}

    # 모델링 작업은 리깅,
    # 애니메이션 작업은 렌더링의 상태를 추가로 표시해줘야 한다.
    riggingProgress = progressDict(hostip, prjid, 'rigging', account)
    renderingProgress = progressDict(hostip, prjid, 'rendering', account)

    works = {}
    for workEl in rootEl.getiterator('work'):
        if workEl.find('base').attrib['class'] == 'episode':
            continue
        if workEl.find('process').attrib['process'] in ['', 'undefined']:
            # 임시: 서버에서 빈 작업이 넘어는 경우가 발견되었다.
            # 정리되기 전까지 빈 작업인지 테스트를 수행한다.
            continue
        if workEl.find('process').attrib['process'] in ['rendered', 'lighting', 'composite']:
            continue

        w = parseOne(workEl, hostip, prjid, riggingProgress, renderingProgress)
        key = '-'.join([prj, prjtype, w.name, w.process])
        works[key] = w

    return works

def parseOne(workEl, hostip, prjid, riggingProgress, renderingProgress):
    '''
    작업 엘리먼트는 베이스 엘리먼트와 프로세스 일레먼트로 이루어져 있다.
    여기서 더 중요한 것은 프로세스 엘리먼트인데, 베이스 엘리먼트는 추가적으로 따라 오는 것이라고 생각하면 된다.
    베이스 엘리먼트는 해당 작업의 모든 프로세스(예: 셋에 파이프라인이라면 모델링, 텍스쳐링, 리깅 등)가 같은 값을 가진다.
    '''
    _, prj, prjtype = prjid.split('__')

    baseEl = workEl.find('base')
    processEl = workEl.find('process')
    name = processEl.attrib['work']
    process = processEl.attrib['process']
    progress = processEl.attrib['progress']
    workerID = processEl.attrib['owner']
    worker = processEl.attrib['name']
    started = processEl.attrib['started']
    updated = processEl.attrib['updated']
    duedate = processEl.attrib['duedate']

    option = {} # TODO : 모든 필수가 아닌 정보를 option에 저장?

    infoEls = baseEl.findall('information')
    if infoEls is None:
        infoEls = baseEl.findall('infomation')
    assetType=''
    if prjtype == 'asset':
        for el in infoEls:
            if el.get('name') == 'type':
                try:
                    assetType = AssetType.label(el.text.upper())
                except:
                    pass
                break

    try:
        thumbnail = workEl.find('media').attrib['thumb']
    except AttributeError:
        thumbnail = ''

    requestProcess = ''
    reqEls = processEl.findall('request')
    if reqEls:
        requestProcess = reqEls[-1].get('request_process', default='')

    if process == 'animation':
        if name in renderingProgress:
            option['next_process_progress'] = renderingProgress[name]
    elif process == 'modeling':
        if name in riggingProgress:
            option['next_process_progress'] = riggingProgress[name]

    locked, lockerAccount, lockerName = False, '', ''
    wid = processEl.get('wid')
    states = processEl.attrib['state'].split(',')
    if 'lock' in states:
        if processEl.find('logs') is not None:
            for log in reversed(processEl.find('logs').findall('log')):
                if not (log.attrib['type'] == 'state' and log.attrib['state'] == 'lock'):
                    continue
                if log.attrib['operation'] != 'add':
                    raise ValueError(wid + " locked, but last operation is not 'add'")
                locked = True
                lockerAccount = log.attrib['account']
                lockerName = log.attrib['name']
                break
            else:
                raise KeyError(wid + ' locked, but cannot find lock information.')
        else:
            raise KeyError(wid + ' locked, but cannot find lock information.')

    classLevel = processEl.attrib['class']
    return Work(
        hostip, prjid, name, process, progress=progress,
        worker=worker, workerID=workerID, started=started, updated=updated, duedate=duedate,
        assetType=assetType, thumbnail=thumbnail, requestProcess=requestProcess,
        locked=locked, lockerAccount=lockerAccount, lockerName=lockerName,
        classLevel='   '+classLevel, option=option
    )

def progressDict(hostip, prjid, process, account):
    '''해당 공정의 작업들의 상태를 사전형태로 돌려준다.'''
    progress = {}
    resp = smgweb_post(
        hostip,
        '/wms/app/pipeline/script/search_process.php',
        {
            'project_id':prjid,
            'account':account,
            'target':'work',
            'process':process,
            'exclude_info':"True"
        }
    )
    rootEl = ET.XML(resp)
    for workEl in rootEl:
        if workEl.tag != 'work':
            continue
        procEl = workEl.find('process')
        w = procEl.attrib['work']
        pg = procEl.attrib['progress']
        progress[w] = pg
    return progress

def updateWork(w, progress, information, account, requested):
    '''
    작업을 업데이트 하고, 과정중 에러가 있었다면 에러를 반환한다.
    요청된 작업을 업데이트 하는 거라면 requested가 True로 넘어온다.
    '''
    # True, False는 post로 보낼 수가 없다.
    if requested:
        requested = '1'
    else:
        requested = ''

    resp = smgweb_post(
        w.hostip,
        '/wms/app/pipeline/script/update_progress.php',
        {
            'project_id' : w.prjid,
            'account' : account,
            'update_progress_list' : w.process+'__'+w.name+'|-CL-|'+progress+'|-CM-|',
            'information' : information,
            'requested': requested
        }
    )
    warn = ET.XML(resp).find('warning')
    if warn is not None:
        return warn.text
    if progress:
        w.progress = progress
    
def checkVersion(w):
    '''
    로컬과 서버의 작업 정보를 비교해,
    둘다 작업 정보가 없으면 2, 둘이 같으면 0, 로컬이 더 최신이면 -1, 서버가 더 최신이면 1을 반환한다.
    '''
    storageIP = projectStorageIP(w.hostip, w.prjid)# 0.20.30.30
    rxml = w.xml.replace(LOCAL_ROOT, 'http://'+storageIP+'/files/wms/app/pipeline')
    debugprint(u'xml 비교 : {l} <-> {r}'.format(l=w.xml, r=rxml))
    try:
        rootEl = ET.parse(w.xml)
        infoEl = rootEl.find('information')
        if infoEl is None:
            infoEl = rootEl.find('infomation')
        lc = infoEl.attrib['checknum']
    except:
        lc = ''
    try:
        rootEl = ET.parse(urllib2.urlopen(rxml))
        infoEl = rootEl.find('information')
        if infoEl is None:
            infoEl = rootEl.find('infomation')
        rc = infoEl.attrib['checknum']
    except:
        rc = ''
    if lc == '' and rc == '': # 로컬과 리모드 xml을 모두 찾지 못함
        return 2
    elif lc == rc:
        return 0
    elif lc < rc:
        return 1
    else:
        return -1

def projectStorageIP(hostip, prjid):
    '''
    projectStorageIP는 해당 프로젝트의 스토리지IP를 검색해 돌려준다.
    스토리지IP가 따로 지정되어있지 않다면 hostIP가 스토리지IP가 된다.
    '''
    if hostip == WMS_HOST:
        resp = smgweb_post(WMS_HOST, "/wms/script/storage_ip.php", {"project_id": prjid})
        rootEl = ET.XML(resp)
        err = rootEl.find('error')
        if err is not None:
            raise RuntimeError(err.text)
        ip = rootEl.find('ip').text
        if ip:
            return ip
    return hostip

# 업로드
def uploadWork(w, checknum): # ==> err string

    '''
    작업을 파일 저장소와 WMS서버에 올린다.
    파일 저장소와 WMS서버는 분리되어 있을수도, 합쳐져 있을수도 있다.

    1. 파일 저장소 - 모든 작업데이터를 올린다.
    작업디렉토리를 두개의 파일로 나누어 올리는데
    하나는 씬과 씬정보가 들어있는 파일이고, 다른 하나는 그 외의 모든 파일이다.
    두개의 파일로 나누는 이유는 상대적으로 가벼우면서 중요한 씬파일을 백업해놓기 위해서이다.

    2. WMS서버 - 웹에서 작업을 표시할때 필요한 프리뷰 파일만 올린다.
    '''

    # 파일을 업로드/다운로드 할때 쓰는 update 디렉토리 생성.
    updir = w.dir.replace('/work/', '/update/')
    print updir
    smgpath_make(updir)

    # 저장소에 작업 전송
    workZip = updir + '/' + w.name + '-' + checknum + '.zip'
    compress(workZip, w.dir, [w.dir], excludes=['attach', 'preview', 'texture', 'sourceimages', '.','.temp','.size', 'incrementalSave'])# 1.0.1

    attachZip = updir + '/' + w.name + '-attach.zip'
    compress(attachZip, w.dir, [w.dir+'/attach', w.dir+'/preview', w.dir+'/texture', w.dir+'/sourceimages'], excludes=['.','.temp','.size'])# 1.0.1

    if os.path.getsize(workZip) + os.path.getsize(attachZip) > 2 * (1024**3):
        ok = askWindow(u'서버로 전송할 데이터가 2기가 바이트가 넘습니다.\n\n계속하시겠습니까?')
        if not ok:
            return u"업로드를 취소하였습니다."

    storageIP = projectStorageIP(w.hostip, w.prjid) # 2017-01-12 스토리지 분리
    print w.prjid
    uploadWorkToStorage = [
        CURL, '-X', 'POST',
        '--fail', '--silent', '--show-error', # 진짜 에러만 stderr로 출력
        '-F', 'project_id={0}'.format(w.prjid),
        '-F', 'wid={0}__{1}'.format(w.process, w.name),
        '-F', 'version={0}'.format(checknum),
        '-F', 'work=@{0}'.format(workZip),
        '-F', 'attach=@{0}'.format(attachZip),
        'http://{0}/wms/app/pipeline/script/upload_work.php'.format(storageIP),
    ]
    print storageIP
    print uploadWorkToStorage

    stdout, stderr = runCmd(uploadWorkToStorage)
    if stderr:
        return u"작업 업로드에 실패했습니다 (curl): " + stderr
        
    if storageIP == WMS_HOST: # 2017-01-12 스토리지 분리
      return # 2017-01-12 스토리지 분리
      
    rootEl = ET.XML(stdout)
    err = rootEl.find('error')
    if err is not None:
        return u"작업 업로드에 실패했습니다 (서버): " + err.text

    # WMS에 프리뷰 전송
    if not os.path.exists(w.dir+previewDir(w.prj)):
        # 아직 프리뷰 디렉토리가 생성되지 않았음
        return

    previewZip = updir + '/' + w.name + '-preview.zip'
    compress(previewZip, w.dir, [w.dir+previewDir(w.prj), w.xml], excludes=['.']) # 2017-01-12 스토리지 분리

    uploadPreviewToWMS = [
        CURL, '-X', 'POST',
        '--fail', '--silent', '--show-error', # 진짜 에러만 stderr로 출력
        '-F', 'project_id={0}'.format(w.prjid),
        '-F', 'wid={0}__{1}'.format(w.process, w.name),
        '-F', 'preview=@{0}'.format(previewZip),
        'http://{0}/wms/app/pipeline/script/upload_preview.php'.format(WMS_HOST), # 2017-01-12 스토리지 분리
    ]
    stdout, stderr = runCmd(uploadPreviewToWMS)
    if stderr:
        return u"프리뷰 업로드에 실패했습니다 (curl): " + stderr

    rootEl = ET.XML(stdout)
    err = rootEl.find('error')
    if err is not None:
        return u"프리뷰 업로드에 실패했습니다 (서버): " + err.text

def uploadRenderview(w, MainUI):
    '''렌더뷰 이미지를 작업디렉토리/attach 에 저장한 다음 서버에 올린다.'''
    if w.dir != mayascene_directory():
        noticeWindow(u"현재 열린 씬이 아닙니다.")
        return
    # 마지막 버전의 렌더뷰 이미지를 만든다.
    srcd = smgstr_mustReplace(w.dir, "rendering", "lighting", 1) + '/upload'
    root = srcd+'/lighting_maya_'
    seqs = glob.glob(root+'[0-9][0-9][0-9].jpg')
    if not seqs:
        lastnum = 0
    else:
        lastf = sorted(seqs)[-1].replace('\\', '/')
        lastnum = int(lastf[len(root):-len('.jpg')])

    img = root+str(lastnum+1).zfill(3)+'.jpg'
    try: os.makedirs(os.path.dirname(img))
    except OSError as e:
        if e.errno == errno.EEXIST:
            pass

    with mayarender_OutAsJpeg():
        mel.eval('renderWindowEditor -e -writeImage "{img}" renderView;'.format(img=img))

    if os.path.dirname(img):
        # 이미지 업로드
        uploadFileToStorage = [
            CURL, '-X', 'POST',
            '--fail', '--silent', '--show-error', # 진짜 에러만 stderr로 출력
            '-F', 'upload_dir={0}'.format('app/pipeline/'+srcd.split('/pipeline/')[-1]),
            '-F', 'file=@{0}'.format(img),
            'http://{0}/wms/script/upload.php'.format(w.hostip),
        ]
        stdout, stderr = runCmd(uploadFileToStorage)

# 다운로드
def downloadRelatedWorks(w, references=True):
    '''해당 작업과 레퍼런스 작업들이 업데이트 되어, 로컬에 저장된 파일이 최신이 아닐경우 다운로드 받는다.'''
    dns = []
    chk = checkVersion(w)
    print chk
    if chk == 1: # 서버쪽 작업이 더 최근 파일이면
        dns.append(w)
        downloadWork(w)

    if references:
        dns.extend(downloadRefWorks(w))

    return dns

def downloadRefWorks(w, pipeline='rigging'):
    '''작업의 레퍼런스 작업들이 업데이트 되어, 로컬에 저장된 파일이 최신이 아닐경우 다운로드 받는다.'''
    if not os.path.isfile(w.xml):
        return []

    dns = []
    for refEl in ET.parse(w.xml).findall('reference'):
        if refEl.attrib['path'].count('/reference/'):
            continue
        rpath = LOCAL_ROOT + '/work/' + os.path.splitext(refEl.attrib['path'].replace('_LOW.', '.'))[0]
        if pipeline != 'rigging':
            rpath = rpath.replace('/rigging/', '/'+pipeline+'/')

        rw = workFromPath(rpath, w.hostip)
        chk = checkVersion(rw)
        if chk == 2:
            messageprint(rw.name+' ['+pipeline+u'] 정보가 존재하지 않습니다.')
            #noticeWindow(rw.name + u'레퍼런스 정보가 존재하지 않습니다.', title=u'오류')
            continue

        elif chk == -1:
            noticeWindow(rw.name+' ['+pipeline+u'] 버전이 서버보다 높습니다.\n해당 레퍼런스의 작업을 완료하여 서버에 업데이트를 해주십시오.', title=u'오류')
            continue

        elif chk > 0:
            messageprint(rw.name+' ['+pipeline+u'] 데이터를 다운로드 합니다.')
            downloadWork(rw)
            dns.append(rw)

    return dns

def checkRefWorks(w, pipeline='rigging'):
    '''작업의 레퍼런스 작업들이 업데이트 되어, 로컬에 저장된 파일이 최신이 아닐경우 다운로드 받는다.'''
    if not os.path.isfile(w.xml):
        return []

    cns = []
    for refEl in ET.parse(w.xml).findall('reference'):
        if refEl.attrib['path'].count('/reference/'):
            continue
        rpath = LOCAL_ROOT + '/work/' + os.path.splitext(refEl.attrib['path'].replace('_LOW.', '.'))[0]
        if pipeline != 'rigging':
            rpath = rpath.replace('/rigging/', '/'+pipeline+'/')

        rw = workFromPath(rpath, w.hostip)
        chk = checkVersion(rw)
        if chk != 2:
            cns.append(rw)

    return cns

def downloadWork(w):
    '''해당 작업 파일들을 다운로드 받는다.'''
    if not isWorkPath(w.path):
        raise ValueError(w.path + ' is not a valid work path')

    # 백업
    if os.path.isfile(w.mb):
        backupScene(w.mb, 'before_download', True)

    # 다운로드 받을 디렉토리 생성
    upd = w.dir.replace(LOCAL_ROOT+'/work/', LOCAL_ROOT+'/update/')
    smgpath_make(upd)

    def download(w, typ):
        '''해당 타입의 작업을 다운로드 받고 받은 파일의 경로를 반환한다.'''
        storageIP = projectStorageIP(w.hostip, w.prjid)# 0.20.30.30
        url = 'http://'+storageIP+'/wms/app/pipeline/script/download_work.php'
        data = urllib.urlencode({
            'project_id' : w.prjid,
            'wid' : w.process+'__'+w.name,
            'type' : typ
        })
        ####################
        print "download url"
        print url
        ####################
        resp = urllib2.urlopen(url, data)
        # 다운로드 파일 경로 설정
        contents = resp.info().getheader('Content-Disposition')
        if not contents:
            # 헤더 없음. 해당 작업이 없을 가능성이 크지만 다른 가능성도 생각하자.
            raise RuntimeError("work not found: " + w.name)
        fn = re.match('attachment; filename="(.+)"', contents).group(1)
        dstf = upd+'/'+fn
        # 다운로드
        try:
            os.remove(dstf)
        except OSError:
            pass
        fsize = int(resp.info().getheader('Content-Length'))
        # -attach.zip 파일의 경우 파일이 0 바이트일 가능성이 존재한다.
        # 이때 이 작업파일을 풀면 에러가 나게 된다.
        if fsize == 0:
            return None
        pgwin = ProgressWindow('download : ' + dstf, fsize)
        n = 8192
        with open(dstf, 'ab') as fd:
            buf = resp.read(n)
            while buf:
                fd.write(buf)
                pgwin.advance(n)
                buf = resp.read(n)
        pgwin.close()
        # 검사
        if os.stat(dstf).st_size != fsize:
            raise RuntimeError('File not downloaded correctly.')
        return dstf

    wf = download(w, 'work')
    if not wf:
        raise RuntimeError("didn't download '{0}' zip-file properly.".format(w.name))
    extract(wf, w.dir)

    af = download(w, 'attach')
    if not af:
        # 파일이 0바이트면 넘어감.
        return
    # 파일을 풀 디렉토리 결정.
    if w.prj in ['doodolls', 't_burster']:
        # 기존 프로젝트는 zip파일을 분석해서 파일 푸는 위치 결정.
        for nl in zipfile.ZipFile(af, 'r').namelist():
            if 'attach/' in nl:
                dstd = w.dir
                break
        else:
            dstd = w.dir+'/attach'
    else:
        # 앞으로 진행하는 프로젝트 (슈퍼보드 부터)는 파일을 푸는 디렉토리를 작업 디렉토리로 하기로 함.
        dstd = w.dir
    extract(af, dstd)

def downloadPreview(works):
    '''작업의 프리뷰를 다운로드 받는다. 프리뷰가 아직 없다면 건너뛴다.'''
    if not works:
        return

    total = len(works)
    # n은 다운로드가 성공 했을때만 올라간다.
    # 나중에 몇개의 작업을 다운로드 받았는지 보이는데 쓰인다.
    n = 0

    pgwin = ProgressWindow("Download Previews...", total)

    for w in works:
        srcf = "http://"+w.hostip+'/files/wms/app/pipeline/work/'+w.prj+'/shot/'+w.process+'/'+w.name+previewDir(w.prj)+'/'+w.name+'.mp4'
        dstf = LOCAL_ROOT+'/clip/'+w.prj+'/complete/'+w.episode+'/'+w.name+'.mp4'
        smgpath_make(os.path.dirname(dstf))

        try:
            resp = urllib2.urlopen(srcf)
        except urllib2.HTTPError as e:
            if str(e) == "HTTP Error 404: Not Found":
                messageprint(u"{0}의 프리뷰가 아직 만들어지지 않았습니다.".format(w.name))
                continue
            raise e
        else:
            with open(dstf, 'wb') as fd:
                buf = resp.read(8192)
                while buf:
                    fd.write(buf)
                    buf = resp.read(8192)
            n += 1
        finally:
            try:
                pgwin.advance(1)
            except:
                messageprint(u"다운로드가 취소되었습니다")
                return


    messageprint(u'다운로드가 완료되었습니다. {0}/{1}'.format(n, total))
    pgwin.close()

    # 폴더 열기
    if n == 0:
        return
    eps = set(w.episode for w in works)
    if len(eps) > 1:
        smgpath_openUp(LOCAL_ROOT+'/clip/'+w.prj+'/complete')
    else:
        smgpath_openUp(LOCAL_ROOT+'/clip/'+w.prj+'/complete/'+w.episode)

def updateEnvDir(remoteRoot, localRoot):
    if remoteRoot[-1] != '/':
        remoteRoot += '/'

    wgetCommand = 'wget'
    if sys.platform == "win32":
        wgetCommand = WGET
        if not os.path.isfile(WGET):
            if not os.path.isdir(UTIL_DIR):
                os.makedirs(UTIL_DIR)

            try:
                rWs = HTTP_FILE_ROOT+'wms/utilities/wget.exe'
                resp = urllib2.urlopen(rWs)
                with open(WGET, 'wb') as fd:
                    buf = resp.read(8192)
                    while buf:
                        fd.write(buf)
                        buf = resp.read(8192)
                fd.close()

            except:
                return False, u'다운로드를 유틸리티를 받을 수 없습니다.'

    cutdirsCmd = ''
    cutdirs = len(remoteRoot.split('/files/')[-1].split('/'))
    if cutdirs:
        cutdirsCmd = '--cut-dirs='+str(cutdirs)

    if not os.path.isdir(localRoot):
        os.makedirs(localRoot)

    p = subprocess.Popen(wgetCommand+' -r -c -N -nH '+cutdirsCmd+' --no-parent --reject "index.html*" '+remoteRoot+' -P '+localRoot, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    _, err = p.communicate()
    if err and not err.count('200 OK'):
        return False, localRoot+u' 업데이트 중 문제가 발생했습니다.'

    return True, None

# 압축
def compress(zipf, root, files, excludes=None):
    '''
    zipf에 files 항목을 담는다. 해당 항목이 파일이라면 그 파일을 담고, 디렉토리라면 그 안의 파일을 모두 담는다.
    zip파일이 root에 대한 상대 경로로 만들어지기 때문에 files의 항목은 모두 root안에 있어야 한다.
    excludes의 각 항목중 하나로 시작하는 파일들은 추가되지 않는다. excludes 항목은 전체경로 또는 이름의 시작부분이어야 한다.
    '''
    if excludes is None:
        excludes = []

    if not os.path.isdir(root):
        raise RuntimeError('root is not a vaild directory: ' + root)

    if not root.endswith('/'):
        root += '/'

    for f in files:
        if os.path.isdir(f) and not f.endswith('/'):
            f += '/'
        if not f.lower().startswith(root.lower()):
            raise RuntimeError("item '{0}' not in root '{1}'".format(f, root))

    def addToZip(z, f):
        fSplit = f.split("/")
        for i in range(len(fSplit)):
            partialPath = "/".join(fSplit[i:])
            for e in excludes:
                if partialPath.startswith(e):
                    return
        if not os.path.exists(f):
            return# 1.0.1
            raise RuntimeError('file not found: ' + f)
        if os.path.isfile(f):
            z.write(f, f[len(root):])
        elif os.path.isdir(f):
            for childf in os.listdir(f):
                addToZip(z, f+'/'+childf)
        else:
            return# 1.0.1
            raise RuntimeError('unknown type of object: ' + f)

    z = zipfile.ZipFile(zipf, 'w', allowZip64=True)
    for f in files:
        addToZip(z, f)
    z.close()

def extract(zipf, d):
    #try: shutil.rmtree(d+'/texture/quality')
    #except: pass
    '''zip파일의 압축을 푼다.'''
    z = zipfile.ZipFile(zipf, 'r')
    z.extractall(d)
    z.close()

def checkTime():
    tl = list(time.gmtime())
    day = tl[2]
    hour = tl[3] + 9
    if hour >= 24:
        day += 1
        hour -= 24
    tl[2] = day
    tl[3] = hour
    t = time.mktime(time.struct_time(tl))
    return str(t).replace('.', '_')

def runCmd(cmd):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    print(stdout)
    print(stderr)
    return stdout, stderr


# 실행
if __name__ == '__main__':
    ui = UI()
