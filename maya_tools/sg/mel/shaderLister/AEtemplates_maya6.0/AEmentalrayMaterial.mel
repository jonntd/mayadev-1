// Copyright (C) 1997-2004 Alias,
// a division of Silicon Graphics Limited.
// 
// The information in this file is provided for the exclusive use of the
// licensees of Alias.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias license agreement, without fee.
// 
// ALIAS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

//****************************************************************************
// Maintain the mental ray material attributes on shadingEngine nodes.
//****************************************************************************

global proc AEmentalrayMaterialFlagsCreate(string $messagePlug)
{
}

global proc AEmentalrayMaterialFlagsNew(string $messagePlug)
{	
	checkBoxGrp -ncb 1 -label1 "Export with Shading Engine"	shadingEngineCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Material Shader" materialShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Shadow Shader" shadowShaderCtrl;
	checkBoxGrp -ncb 1 -label1 "Export with Volume Sampler"	volumeSamplerCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Volume Shader"	volumeShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Photon Shader"	photonShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Phot Volume Shader" photonVolumeShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Displacement Shader" displacementShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Environment Shader" environmentShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Light Map Shader" lightMapShaderCtrl;
	attrNavigationControlGrp  -h 23 -dgc drag_ya -dpc drop_ya -label "Contour Shader" contourShaderCtrl;

	string $node;
	string $buf[];
	tokenize $messagePlug "." $buf;
	$node = (size($buf) > 0) ? $buf[0] : "";
	
	if ($node != ""){
	popupMenu -pmc ("popupItems " + $node + ".miMaterialShader" + " pop_mr_mat") -p materialShaderCtrl pop_mr_mat;
	popupMenu -pmc ("popupItems " + $node + ".miShadowShader" +  " pop_mr_sha") -p shadowShaderCtrl pop_mr_sha;
	popupMenu -pmc ("popupItems " + $node + ".miVolumeShader" +  " pop_mr_vol") -p volumeShaderCtrl pop_mr_vol;
	popupMenu -pmc ("popupItems " + $node + ".miPhotonShader" +  " pop_mr_phot") -p photonShaderCtrl pop_mr_phot;
	popupMenu -pmc ("popupItems " + $node + ".miPhotonVolumeShader" + " pop_mr_phot_vol") -p photonVolumeShaderCtrl pop_mr_phot_vol;
	popupMenu -pmc ("popupItems " + $node + ".miDisplacementShader" +  " pop_mr_dis") -p displacementShaderCtrl pop_mr_dis;
	popupMenu -pmc ("popupItems " + $node + ".miEnvironmentShader" + " pop_mr_env") -p environmentShaderCtrl pop_mr_env;
	popupMenu -pmc ("popupItems " + $node + ".miLightMapShader" + " pop_mr_lig") -p lightMapShaderCtrl pop_mr_lig;
	popupMenu -pmc ("popupItems " + $node + ".miContourShader" + " pop_mr_cont") -p contourShaderCtrl pop_mr_cont;
	}

	AEmentalrayMaterialFlagsReplace($messagePlug);
}

global proc AEmentalrayMaterialFlagsReplace(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	checkBoxGrp -edit -ofc ( "setAttr " + $node + ".miExportShadingEngine 0" ) -onc ( "setAttr " + $node + ".miExportShadingEngine 1" ) -value1 (`getAttr ($node + ".miExportShadingEngine")`) shadingEngineCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miMaterialShader" ) materialShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miShadowShader" ) shadowShaderCtrl;
	checkBoxGrp -edit -ofc ( "setAttr " + $node + ".miExportVolumeSampler 0" ) -onc ( "setAttr " + $node + ".miExportVolumeSampler 1" ) -value1 (`getAttr ($node + ".miExportVolumeSampler")`) volumeSamplerCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miVolumeShader" ) volumeShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miPhotonShader" )	photonShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miPhotonVolumeShader" ) photonVolumeShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miDisplacementShader" ) displacementShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miEnvironmentShader" ) environmentShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miLightMapShader" ) lightMapShaderCtrl;
	attrNavigationControlGrp -edit -dgc drag_ya -dpc drop_ya -attribute ( $node + ".miContourShader" ) contourShaderCtrl;
	
	//if ($node != ""){
	popupMenu -e -pmc ("popupItems " + $node + ".miMaterialShader" + " pop_mr_mat") -p materialShaderCtrl pop_mr_mat;
	popupMenu -e -pmc ("popupItems " + $node + ".miShadowShader" +  " pop_mr_sha") -p shadowShaderCtrl pop_mr_sha;
	popupMenu -e -pmc ("popupItems " + $node + ".miVolumeShader" +  " pop_mr_vol") -p volumeShaderCtrl pop_mr_vol;
	popupMenu -e -pmc ("popupItems " + $node + ".miPhotonShader" +  " pop_mr_phot") -p photonShaderCtrl pop_mr_phot;
	popupMenu -e -pmc ("popupItems " + $node + ".miPhotonVolumeShader" + " pop_mr_phot_vol") -p photonVolumeShaderCtrl pop_mr_phot_vol;
	popupMenu -e -pmc ("popupItems " + $node + ".miDisplacementShader" +  " pop_mr_dis") -p displacementShaderCtrl pop_mr_dis;
	popupMenu -e -pmc ("popupItems " + $node + ".miEnvironmentShader" + " pop_mr_env") -p environmentShaderCtrl pop_mr_env;
	popupMenu -e -pmc ("popupItems " + $node + ".miLightMapShader" + " pop_mr_lig") -p lightMapShaderCtrl pop_mr_lig;
	popupMenu -e -pmc ("popupItems " + $node + ".miContourShader" + " pop_mr_cont") -p contourShaderCtrl pop_mr_cont;
	//}
	
	
	scriptJob -parent contourShaderCtrl -attributeChange ( $node + ".miContourShader" )
		( "AEmentalrayMaterialContourUpdate(\"" +
					$node + ".message\")" );
}

global proc AEmentalrayMaterialContourUpdate(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	if ( `attributeQuery -exists -node $node "miContourShader"` ) {

		int $dim = `connectionInfo -id ($node + ".miContourShader")`;
		editorTemplate -dimControl $node "miContourEnable" $dim;
		$dim = $dim || (! `getAttr ($node + ".miContourEnable")` );
		editorTemplate -dimControl $node "miContourColor" $dim;
		editorTemplate -dimControl $node "miContourAlpha" $dim;
		editorTemplate -dimControl $node "miContourWidth" $dim;
		if( `radioButtonGrp -q -ex miContourRelativeWidthCtrl` )
			radioButtonGrp -edit -enable (1-$dim) "miContourRelativeWidthCtrl";
		}
}

// Description:  This procedure is called to create 
//      the miContourRelativeWidthCtrl.
//
global proc AEmiContourRelativeWidthNew(string $relativeWidth)
{
    radioButtonGrp
        -numberOfRadioButtons 2
        -label1 "Relative Width"
        -data1 1
        -label2 "Absolute Width"
        -data2 0
        miContourRelativeWidthCtrl;

     AEmiContourRelativeWidthReplace($relativeWidth);
}

// Description:  This procedure is called to replace the attribute
//      represented by the miContourRelativeWidthCtrl.
//
global proc AEmiContourRelativeWidthReplace(string $relativeWidth)
{
    radioButtonGrp
        -edit
        -onCommand1 ("setAttr "+$relativeWidth + " true")
        -onCommand2 ("setAttr "+$relativeWidth + " false")
        miContourRelativeWidthCtrl;
            
    connectControl miContourRelativeWidthCtrl $relativeWidth;
}

global proc AEmentalrayMaterial(string $node)
{
	editorTemplate -beginLayout "mental ray" -collapse true;
		editorTemplate -beginLayout "Flags" -collapse true;
		editorTemplate
			-label "Opaque"
			-addControl "miOpaque";
		editorTemplate -endLayout;
		editorTemplate
			-beginLayout "Contours"
			-collapse true;
			editorTemplate
				-label "Enable Contour Rendering"
				-addControl "miContourEnable"
				    "AEmentalrayMaterialContourUpdate";
			editorTemplate
				-label "Color"
				-addControl "miContourColor";
			editorTemplate
				-label "Alpha"
				-addControl "miContourAlpha";

            editorTemplate -callCustom AEmiContourRelativeWidthNew
                                       AEmiContourRelativeWidthReplace
                                       miContourRelativeWidth;
 
			editorTemplate
				-label "Width"
				-addControl "miContourWidth";
		editorTemplate -endLayout;
		editorTemplate -beginLayout "Custom Shaders" -cl false;
		editorTemplate
			-label "Suppress all Maya Shaders"
			-addControl "miExportMrMaterial";
		editorTemplate -callCustom
			"AEmentalrayMaterialFlagsNew"
			"AEmentalrayMaterialFlagsReplace"
				 "message";
		editorTemplate -endLayout;
	editorTemplate -endLayout;

	editorTemplate -suppress "miExportShadingEngine";
	editorTemplate -suppress "miMaterialShader";
	editorTemplate -suppress "miShadowShader";
	editorTemplate -suppress "miExportVolumeSampler";
	editorTemplate -suppress "miVolumeShader";
	editorTemplate -suppress "miPhotonShader";
	editorTemplate -suppress "miPhotonVolumeShader";
	editorTemplate -suppress "miDisplacementShader";
	editorTemplate -suppress "miEnvironmentShader";
	editorTemplate -suppress "miLightMapShader";
	editorTemplate -suppress "miContourShader";
	editorTemplate -suppress "miContourRelativeWidth";
}
