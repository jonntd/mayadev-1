// Copyright (C) 1997-2004 Alias Systems Corp.
// 
// The information in this file is provided for the exclusive use of the
// licensees of Alias.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias license agreement, without fee.
// 
// ALIAS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

//****************************************************************************
// Define additional light attributes for mental ray. They will show up in
// the attribute editor of maya lights.
//****************************************************************************

global proc miDirLightExportFlagsNew(string $messagePlug)
{
	attrNavigationControlGrp
		-label "Light Shader" dirLightShaderCtrl;
	attrNavigationControlGrp
		-label "Photon Emitter" photonEmitterCtrl;

	popupMenu -p dirLightShaderCtrl dirLightPop1_ya;
	popupMenu -p photonEmitterCtrl dirLightPop2_ya;

	miDirLightExportFlagsReplace($messagePlug);
}

global proc miDirLightExportFlagsReplace(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	attrNavigationControlGrp
		-edit -attribute ($node + ".miLightShader" )
		dirLightShaderCtrl;
	attrNavigationControlGrp
		-edit -attribute ($node + ".miPhotonEmitter" )
		photonEmitterCtrl;
		
  popupMenu -e -pmc ("popupItems " + $node + ".miLightShader dirLightPop1_ya") dirLightPop1_ya;
	popupMenu -e -pmc ("popupItems " + $node + ".miPhotonEmitter dirLightPop2_ya") dirLightPop2_ya;
}

global proc miDirLightCheckEmitPhotons(string $node)
{
	int	$noCaustic = `miIsCaustic` ? false : true;
	int	$noGlobIll = `miIsGlobalIllum` ? false : true;
	int	$phot = `getAttr ($node + ".emitPhotons")`;
	int	$dim  = $phot ? false : true;

	editorTemplate -dc $node "photonIntensity" $dim;
	editorTemplate -dc $node "exponent" $dim;
	editorTemplate -dc $node "causticPhotons" ($dim || $noCaustic);
	editorTemplate -dc $node "globIllPhotons" ($dim || $noGlobIll);
	
	if( `colorSliderGrp -query -exists DirectionalLightPhotonColorCtrl`)
	{
		colorSliderGrp
			-edit 
			-enable (`getAttr ($node + ".emitPhotons")`)
			DirectionalLightPhotonColorCtrl;
	}	

}

global proc miDirLightShadowMapFromMaya(string $node)
{
	int $resolution = `getAttr ( $node + ".dmapResolution")`;
	setAttr ( $node + ".smapResolution" ) $resolution;

	int $filterSize = `getAttr ( $node + ".dmapFilterSize")`;
	if ($filterSize > 0) {
		setAttr ( $node + ".smapSoftness" ) ($filterSize/40.0);
		if ($filterSize == 1)
			setAttr ( $node + ".smapSamples" ) 1;
		else
			setAttr ( $node + ".smapSamples" ) (10*$filterSize);
		}
	else {
		setAttr ( $node + ".smapSoftness" ) 0;
		setAttr ( $node + ".smapSamples" ) 0;
		}

	setAttr -type "string" ( $node + ".smapFilename" ) "";
}


global proc miDirLightShadowMapButtonCreate(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	separator
		-style "none" -width 490 -height 10;
	rowLayout
		-numberOfColumns 2
		-columnWidth 2 180;

		text	-label "";
		button	-label "Take Settings From Maya"
			-command ( "miDirLightShadowMapFromMaya " + $node )
			settingsButton;
	setParent ..;

	separator
		-style "none" -width 490 -height 10;
}

global proc miDirLightShadowMapButtonReplace(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	button	-edit
		-command ( "miDirLightShadowMapFromMaya " + $node )
		settingsButton;
}

global proc miDirLightCheckShadowMap(string $node)
{
	int	$smap = `getAttr ($node + ".shadowMap")`;
	int	$dim  = $smap ? false : true;

	editorTemplate -dc $node "smapResolution" $dim;
	editorTemplate -dc $node "smapSamples" $dim;
	editorTemplate -dc $node "smapSoftness" $dim;
	editorTemplate -dc $node "smapBias" $dim;
	if( `rowLayout -query -exists fileNameSLLayout` )
	{
		rowLayout -edit -enable (!$dim) fileNameDLLayout;
	}
	if( `button -query -exists settingsButton` )
	{
			button -edit -enable (!$dim) settingsButton;
	}
	
	editorTemplate -dc $node "smapSceneName" $dim;
	editorTemplate -dc $node "smapLightName" $dim;
	editorTemplate -dc $node "smapFrameExt" $dim;
	
	editorTemplate -dc $node "smapDetail" $dim;
	
	miDirectionalLightCheckDetailShadowMap($node);
}

global proc miDirectionalLightCheckDetailShadowMap(string $node)
{
	int	$smap = `getAttr ($node + ".smapDetail")`;
	int	$dim  = $smap ? false : true;
					
	editorTemplate -dc $node "smapDetailSamples" $dim;
	editorTemplate -dc $node "smapDetailAccuracy" $dim;
	editorTemplate -dc $node "smapDetailAlpha" $dim;
	
	if( `attrNavigationControlGrp -query -exists directionalLightCameraCtrl`)
		attrNavigationControlGrp -edit -enable $smap
			directionalLightCameraCtrl;

}


global proc AEmiDLShadowMapFilenameNew(string $attr)
{
	setUITemplate -pushTemplate attributeEditorTemplate;
	rowLayout -numberOfColumns 2 fileNameDLLayout;
		text -label "Shadow Map File Name";
		textField smapDLFilenameTextField;
	setParent ..;
	setUITemplate -popTemplate;

	AEmiDLShadowMapFilenameReplace $attr;

}

global proc AEmiDLShadowMapFilenameReplace(string $attr)
{
	connectControl smapDLFilenameTextField $attr;
}

global proc miDirectionalLightPhotonColorNew(string $attr)
{
	colorSliderGrp
		-label "Photon Color" 
		DirectionalLightPhotonColorCtrl;
	miDirectionalLightPhotonColorReplace($attr);
}

global proc miDirectionalLightPhotonColorReplace(string $attr)
{
	string $node;
	string $buffer[];
	tokenize($attr, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";
	
	// compute the photon color
	float $rgb[] = `getAttr ($node + ".energy")`;
	
	float $intensity = `getAttr ($node + ".photonIntensity")`;
	$rgb[0] /= $intensity;
	$rgb[1] /= $intensity;
	$rgb[2] /= $intensity;
	
	float $maxColor = max($rgb[0], $rgb[1]);
	$maxColor = max($maxColor, $rgb[2]);
	
	// normalize the color.
	if( $maxColor > 1 )
	{
		$rgb[0] /= $maxColor;
		$rgb[1] /= $maxColor;
		$rgb[2] /= $maxColor;
		$intensity *= $maxColor;
		setAttr ($node + ".photonIntensity") $intensity;
	} else if( $maxColor < 0.1 )
	{
		// is rgb to small? - scale up to 0.1
		$maxColor /= 0.1;
		$rgb[0] = $rgb[0]/$maxColor;
		$rgb[1] = $rgb[1]/$maxColor;
		$rgb[2] = $rgb[2]/$maxColor;
		
		$intensity *= $maxColor;
		setAttr ($node + ".photonIntensity") $intensity;
	}
	
	colorSliderGrp
		-edit 
		-enable (`getAttr ($node + ".emitPhotons")`)
		-rgbValue $rgb[0] $rgb[1] $rgb[2]
		-changeCommand ("miDirectionalLightUpdatePhotonEnergy (\"" + $node + "\")")
		DirectionalLightPhotonColorCtrl;
		
	miDirectionalLightUpdatePhotonEnergy($node);
}

global proc miDirectionalLightUpdatePhotonEnergy(string $node)
{
	if( !`colorSliderGrp -query -exists DirectionalLightPhotonColorCtrl` ||
 	    !`getAttr -se ($node + ".energy")`)
		return;
	float $rgbcolor[] = `colorSliderGrp -query -rgbValue DirectionalLightPhotonColorCtrl`;
	
	float $energy[] = $rgbcolor;
	float $intensity = `getAttr ($node + ".photonIntensity")`;
	$energy[0] *= $intensity;
	$energy[1] *= $intensity;
	$energy[2] *= $intensity;
	
	setAttr ($node + ".energy") -type float3 $energy[0] $energy[1] $energy[2];
}

global proc AEmentalrayDirectionalLight(string $node)
{
	// A|w: non-collapse display required to ensure proper update
	editorTemplate -bl "mental ray" -cl true;

		editorTemplate -bl "Caustic and Global Illumination" -cl false;
			editorTemplate -ac "emitPhotons"
					"miDirLightCheckEmitPhotons";
			editorTemplate -callCustom
						"miDirectionalLightPhotonColorNew"
						"miDirectionalLightPhotonColorReplace"
						"energy";
		editorTemplate -ac "photonIntensity" miDirectionalLightUpdatePhotonEnergy;
		editorTemplate -ac "exponent";
			editorTemplate -as;
		editorTemplate -ac "causticPhotons";
		editorTemplate -l "Global Illum Photons"
				-ac "globIllPhotons";
		editorTemplate -el;

		editorTemplate -beginLayout "Shadow Map Attributes" -cl false;
		
			editorTemplate -ac "shadowMap"
					"miDirLightCheckShadowMap";
			editorTemplate -callCustom
				"miDirLightShadowMapButtonCreate"
				"miDirLightShadowMapButtonReplace"
					"message";
					
			editorTemplate -label "Resolution" -ac "smapResolution";
			editorTemplate -label "Samples" -ac "smapSamples" ;
			editorTemplate -label "Softness" -ac "smapSoftness" ;
			editorTemplate -label "Bias" -ac "smapBias" ;
									
			// custom control to ensure proper label update
			editorTemplate -callCustom
					"AEmiDLShadowMapFilenameNew"
					"AEmiDLShadowMapFilenameReplace"
						"smapFilename";
			editorTemplate -l "Add Light Name" -ac smapLightName ;
			editorTemplate -l "Add Scene Name" -ac smapSceneName ;
			editorTemplate -l "Add Frame Ext"  -ac smapFrameExt ;
	
		
			editorTemplate -beginLayout "Detail Shadow Map Attributes" -cl false;
				editorTemplate -l "Detail Shadow Map" -ac "smapDetail"
						"miDirectionalLightCheckDetailShadowMap";
				editorTemplate -label "Samples" -ac "smapDetailSamples";
				editorTemplate -label "Accuracy"-ac "smapDetailAccuracy";
				editorTemplate -label "Alpha" -ac "smapDetailAlpha";
			
			editorTemplate -endLayout;
		editorTemplate -el;

	editorTemplate -bl "Custom Shaders" -cl false;
	editorTemplate -l "Suppress all Maya shaders"
		-ac "miExportMrLight";
	editorTemplate -callCustom
		"miDirLightExportFlagsNew"
		"miDirLightExportFlagsReplace" "message";
	editorTemplate -s "miLightShader";
	editorTemplate -s "miPhotonEmitter";
	editorTemplate -s "smapFilename";
	editorTemplate -s "energy";
	editorTemplate -el;

	// This attr does not exist any more, 
	// but pre-6.0 scenes creates it as a dynamic attr,
	// so it has to be suppressed explicitly.
	// Fortunatley, doing this in new 6.0 scene does not cause error
	// even though the attr does not exist on the node.
	editorTemplate -s "physical";
	
	editorTemplate -el;
}
