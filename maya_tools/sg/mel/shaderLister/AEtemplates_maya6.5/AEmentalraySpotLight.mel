// Copyright (C) 1997-2004 Alias,
// a division of Silicon Graphics Limited.
// 
// The information in this file is provided for the exclusive use of the
// licensees of Alias.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias license agreement, without fee.
// 
// ALIAS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

//****************************************************************************
// Define additional light attributes for mental ray. They will show up in
// the attribute editor of maya lights.
//****************************************************************************

global proc AEmiSpotAreaLightReplace(string $typ, string $org, string $cor)
{
	warning("Calling an obsolete mel procedure AEmiSpotAreaLightReplace.");
}
global proc AEmiSpotAreaLightNew(string $typ, string $org, string $cor)
{
	warning("Calling an obsolete mel procedure AEmiSpotAreaLightNew.");
}

global proc miSpotLightExportFlagsNew(string $messagePlug)
{
	attrNavigationControlGrp
		-label "Light Shader" spotLightShaderCtrl;
	attrNavigationControlGrp
		-label "Photon Emitter" photonEmitterCtrl;

	popupMenu -p spotLightShaderCtrl spotLightPop1_ya;
	popupMenu -p photonEmitterCtrl spotLightPop2_ya;
	
	miSpotLightExportFlagsReplace($messagePlug);
}

global proc miSpotLightExportFlagsReplace(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	attrNavigationControlGrp
		-edit -attribute ($node + ".miLightShader" )
		spotLightShaderCtrl;
	attrNavigationControlGrp
		-edit -attribute ($node + ".miPhotonEmitter" )
		photonEmitterCtrl;
	
	popupMenu -e -pmc ("popupItems " + $node + ".miLightShader spotLightPop1_ya") spotLightPop1_ya;
	popupMenu -e -pmc ("popupItems " + $node + ".miPhotonEmitter spotLightPop2_ya") spotLightPop2_ya;
}

global proc miSpotLightCheckEmitPhotons(string $node)
{
	int	$noCaustic = `miIsCaustic` ? false : true;
	int	$noGlobIll = `miIsGlobalIllum` ? false : true;
	int	$phot = `getAttr ($node + ".emitPhotons")`;
	int	$dim  = $phot ? false : true;

	editorTemplate -dc $node "photonIntensity" $dim;
	editorTemplate -dc $node "exponent" $dim;
	editorTemplate -dc $node "causticPhotons" ($dim || $noCaustic);
	editorTemplate -dc $node "globIllPhotons" ($dim || $noGlobIll);
	
	if( `colorSliderGrp -query -exists SpotLightPhotonColorCtrl`)
	{
		colorSliderGrp
			-edit 
			-enable (`getAttr ($node + ".emitPhotons")`)
			SpotLightPhotonColorCtrl;
	}	
}

global proc miSpotLightShadowMapFromMaya(string $node)
{
	int $resolution = `getAttr ( $node + ".dmapResolution")`;
	setAttr ( $node + ".smapResolution" ) $resolution;

	int $filterSize = `getAttr ( $node + ".dmapFilterSize")`;
	if ($filterSize > 0) {
		setAttr ( $node + ".smapSoftness" ) ($filterSize/40.0);
		if ($filterSize == 1)
			setAttr ( $node + ".smapSamples" ) 1;
		else
			setAttr ( $node + ".smapSamples" ) (10*$filterSize);
		}
	else {
		setAttr ( $node + ".smapSoftness" ) 0;
		setAttr ( $node + ".smapSamples" ) 0;
		}

	setAttr -type "string" ( $node + ".smapFilename" ) "";
}


global proc miSpotLightShadowMapButtonCreate(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	separator
		-style "none" -width 490 -height 10;
	rowLayout
		-numberOfColumns 2
		-columnWidth 2 180;

		text	-label "";
		button	-label "Take Settings From Maya"
			-command ( "miSpotLightShadowMapFromMaya " + $node )
			settingsButton;
	setParent ..;

	separator
		-style "none" -width 490 -height 10;
}

global proc miSpotLightShadowMapButtonReplace(string $messagePlug)
{
	string $node;
	string $buffer[];
	tokenize($messagePlug, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";

	button	-edit
		-command ( "miSpotLightShadowMapFromMaya " + $node )
		settingsButton;
}

global proc miSpotLightCheckShadowMap(string $node)
{
	int	$smap = `getAttr ($node + ".shadowMap")`;
	int	$dim  = $smap ? false : true;

	editorTemplate -dc $node "smapResolution" $dim;
	editorTemplate -dc $node "smapSamples" $dim;
	editorTemplate -dc $node "smapSoftness" $dim;
	if( `rowLayout -query -exists fileNameSLLayout` )
		{
		rowLayout -edit -enable (!$dim) fileNameSLLayout;
		}
	if( `button -query -exists settingsButton` )
		{
			button -edit -enable (!$dim) settingsButton;
		}
}

proc miSpotLightDisplayAreaLocator(string $node, int $type)
{
	if( !`pluginInfo -q -loaded Mayatomr` ) return;

	int $undoOn = `undoInfo -query -swf`;
	if ($undoOn)
		undoInfo -swf off;

	string $typeNames[4] = {
		"rectangularLightLocator",
		"discLightLocator",
		"sphericalLightLocator",
		"cylindricalLightLocator"
		};

	int $reSelect = false;
	string $selection[] = `ls -selection`;

	// Get all instance parents of the light shape node.
	string $parents[] = `listRelatives -fullPath -allParents $node`;

	// Loop over parents.
	for ($parent in $parents) {

		int $createLocator = ($type >= 0 && $type < 4);

		// Remove previously attached locators.
		for ($cnt=0; $cnt<size($typeNames); $cnt++) {
			string $typeName = $typeNames[$cnt];
			// Get all locators of a given type.
			string $locators[] =
				`listRelatives -c -type $typeName $parent`;
			// If there is exactly one locator of the type we  wish
			// to create then that locator is kept and a new one is
			// not created.
			if ($cnt == $type && size($locators) == 1) {
				$createLocator = false;
				continue;
				}
			// Remove old locators.
			if (size($locators) > 0)
				delete $locators;
			}

		// Create a locator if desired.
		if ($createLocator) {
			// bug 202143
			// $parent contains the full dag path with '|' in the name.
			// substitue '|' with '_' to prevent warning msg.
			string $tmpParent = `substitute "|" $parent "_"`;
			shadingNode
				-asUtility -name ($tmpParent + "_mrLoc")
				-parent $parent $typeNames[$type];
			$reSelect = true;
			}
		}

	if ($reSelect)
		// Undo selection.
		select $selection;

	if ($undoOn)
		undoInfo -swf on;
}

global proc miSpotLightChangeAreaLight(string $node)
{
	int $pluginLoaded = `pluginInfo -q -loaded Mayatomr`;

	editorTemplate -dc $node "areaLight" (! $pluginLoaded);

	int	$algt = `getAttr ($node + ".areaLight")`;

	miSpotLightDisplayAreaLocator(
		$node, ($algt) ? `getAttr ($node + ".areaType")` : -1);

	miSpotLightCheckAreaLight($node);
}

global proc miSpotLightCheckAreaLight(string $node)
{
	int $pluginLoaded = `pluginInfo -q -loaded Mayatomr`;

	int	$algt = `getAttr ($node + ".areaLight")`;
	int	$dim  = ($pluginLoaded && $algt) ? false : true;

	if (`control -q -exists areacl`)
		columnLayout -e -en $algt areacl;

	editorTemplate -dc $node "areaType" $dim;
	editorTemplate -dc $node "areaSampling" $dim;
	editorTemplate -dc $node "areaLowLevel" $dim;
	editorTemplate -dc $node "areaLowSampling" $dim;
	editorTemplate -dc $node "areaVisible" $dim;
}

global proc miSpotLightCheckAreaType(string $node)
{
	int	$atyp = `getAttr ($node + ".areaType")`;
	if( `getAttr ($node + ".areaLight")` == 0 )
		return;

	switch ($atyp) {
		case 0:	// rectangle
			setAttr ($node + ".areaNormalX") 0.0;
			setAttr ($node + ".areaNormalY") 2.0;
			setAttr ($node + ".areaNormalZ") 0.0;
			setAttr ($node + ".areaEdgeX") 2.0;
			setAttr ($node + ".areaEdgeY") 0.0;
			setAttr ($node + ".areaEdgeZ") 0.0;
			break;
		case 1:	// disc
			setAttr ($node + ".areaNormalX") 0.0;
			setAttr ($node + ".areaNormalY") 0.0;
			setAttr ($node + ".areaNormalZ") -1.0;
			setAttr ($node + ".areaRadius") 1.0;
			break;
		case 2:	// sphere
			setAttr ($node + ".areaRadius") 1.0;
			break;
		case 3:	// cylinder
			setAttr ($node + ".areaEdgeX") 1.0;
			setAttr ($node + ".areaEdgeY") 0.0;
			setAttr ($node + ".areaEdgeZ") 0.0;
			setAttr ($node + ".areaRadius") 1.0;
			break;
		default:
			setAttr ($node + ".areaNormalX") 0.0;
			setAttr ($node + ".areaNormalY") 0.0;
			setAttr ($node + ".areaNormalZ") 0.0;
			setAttr ($node + ".areaEdgeX") 0.0;
			setAttr ($node + ".areaEdgeY") 0.0;
			setAttr ($node + ".areaEdgeZ") 0.0;
			setAttr ($node + ".areaRadius") 0.0;
		}

	miSpotLightDisplayAreaLocator($node, $atyp);
}

global proc AEmiSpotLightReplace(string $attr)
{
	string	$node;
	string	$buffer[];

	tokenize($attr, ".", $buffer);

	$node = $buffer[0];

	miSpotLightCheckEmitPhotons $node;
	miSpotLightCheckShadowMap $node;
	miSpotLightCheckAreaLight $node;
}

global proc AEmiSpotLightNew(string $attr)
{
	AEmiSpotLightReplace $attr;
}

global proc AEmiSLShadowMapFilenameNew(string $attr)
{
	setUITemplate -pushTemplate attributeEditorTemplate;
	rowLayout -numberOfColumns 2 fileNameSLLayout;
		text -label "Shadow Map File Name";
		textField smapSLFilenameTextField;
	setParent ..;
	setUITemplate -popTemplate;

	AEmiSLShadowMapFilenameReplace $attr;

}

global proc AEmiSLShadowMapFilenameReplace(string $attr)
{
	connectControl smapSLFilenameTextField $attr;
}

global proc miSpotLightPhotonColorNew(string $attr)
{
	colorSliderGrp
		-label "Photon Color" 
		SpotLightPhotonColorCtrl;
	miSpotLightPhotonColorReplace($attr);
}

global proc miSpotLightPhotonColorReplace(string $attr)
{
	string $node;
	string $buffer[];
	tokenize($attr, ".", $buffer);
	$node = (size($buffer) > 0) ? $buffer[0] : "";
	
	// compute the photon color
	float $rgb[] = `getAttr ($node + ".energy")`;
	
	float $intensity = `getAttr ($node + ".photonIntensity")`;
	$rgb[0] /= $intensity;
	$rgb[1] /= $intensity;
	$rgb[2] /= $intensity;
	
	float $maxColor = max($rgb[0], $rgb[1]);
	$maxColor = max($maxColor, $rgb[2]);
	
	// normalize the color.
	if( $maxColor > 1 )
	{
		$rgb[0] /= $maxColor;
		$rgb[1] /= $maxColor;
		$rgb[2] /= $maxColor;
		$intensity *= $maxColor;
		setAttr ($node + ".photonIntensity") $intensity;
	} else if( $maxColor < 0.1 )
	{
		// is rgb to small? - scale up to 0.1
		$maxColor /= 0.1;
		$rgb[0] = $rgb[0]/$maxColor;
		$rgb[1] = $rgb[1]/$maxColor;
		$rgb[2] = $rgb[2]/$maxColor;
		
		$intensity *= $maxColor;
		setAttr ($node + ".photonIntensity") $intensity;
	}
	
	colorSliderGrp
		-edit 
		-enable (`getAttr ($node + ".emitPhotons")`)
		-rgbValue $rgb[0] $rgb[1] $rgb[2]
		-changeCommand ("miSpotLightUpdatePhotonEnergy (\"" + $node + "\")")
		SpotLightPhotonColorCtrl;
		
	miSpotLightUpdatePhotonEnergy($node);
}

global proc miSpotLightUpdatePhotonEnergy(string $node)
{
	if( !`colorSliderGrp -query -exists SpotLightPhotonColorCtrl` || !`getAttr -se ($node + ".energy")`)
		return;
	float $rgbcolor[] = `colorSliderGrp -query -rgbValue SpotLightPhotonColorCtrl`;
	
	float $energy[] = $rgbcolor;
	float $intensity = `getAttr ($node + ".photonIntensity")`;
	$energy[0] *= $intensity;
	$energy[1] *= $intensity;
	$energy[2] *= $intensity;
	
	setAttr ($node + ".energy") -type float3 $energy[0] $energy[1] $energy[2];
}

global proc AEmentalraySpotLight(string $node)
{
	// A|w: non-collapse display required to ensure proper update
	editorTemplate -bl "mental ray" -cl true;

	editorTemplate -bl "Caustic and Global Illumination" -cl false;
		editorTemplate -ac "emitPhotons"
					"miSpotLightCheckEmitPhotons";
		editorTemplate -callCustom
					"miSpotLightPhotonColorNew"
					"miSpotLightPhotonColorReplace"
					"energy";
		editorTemplate -ac "photonIntensity" miSpotLightUpdatePhotonEnergy;
		editorTemplate -ac "exponent";
		editorTemplate -as;
		editorTemplate -ac "causticPhotons";
		editorTemplate -l "Global Illum Photons"
				-ac "globIllPhotons";
	editorTemplate -el;

	editorTemplate -beginLayout "Shadow Maps" -cl false;
		editorTemplate -ac "shadowMap"
				"miSpotLightCheckShadowMap";
		editorTemplate -callCustom
				"miSpotLightShadowMapButtonCreate"
				"miSpotLightShadowMapButtonReplace"
					"message";
		editorTemplate -l "Resolution" -ac "smapResolution";
		editorTemplate -l "Samples"    -ac "smapSamples";
		editorTemplate -l "Softness"   -ac "smapSoftness";
		// custom control to ensure proper label update
		editorTemplate -callCustom
				"AEmiSLShadowMapFilenameNew"
				"AEmiSLShadowMapFilenameReplace"
					"smapFilename";
	editorTemplate -el;

	editorTemplate -bl "Area Light" -cl false;
		editorTemplate -ac "areaLight"
				"miSpotLightChangeAreaLight";

		editorTemplate -l "Type" -ac "areaType" "miSpotLightCheckAreaType";

		editorTemplate -l "Sampling"     -ac "areaSampling";
		editorTemplate -l "Low Level"    -ac "areaLowLevel";
		editorTemplate -l "Low Sampling" -ac "areaLowSampling";
		editorTemplate -l "Visible"      -ac "areaVisible";
	editorTemplate -el;

	editorTemplate -s "areaNormal";
	editorTemplate -s "areaEdge";
	editorTemplate -s "areaRadius";

	editorTemplate -bl "Custom Shaders" -cl false;
	editorTemplate -l "Suppress all Maya shaders"
		-ac "miExportMrLight";
	editorTemplate -callCustom
		"miSpotLightExportFlagsNew"
		"miSpotLightExportFlagsReplace" "message";
	editorTemplate -s  "miLightShader";
	editorTemplate -s  "miPhotonEmitter";
	editorTemplate -s "smapFilename";
	editorTemplate -s "energy";
	editorTemplate -el;

	// This attr does not exist any more, 
	// but pre-6.0 scenes creates it as a dynamic attr,
	// so it has to be suppressed explicitly.
	// Fortunatley, doing this in new 6.0 scene does not cause error
	// even though the attr does not exist on the node.
	editorTemplate -s "physical";
	
	editorTemplate -el;
}
