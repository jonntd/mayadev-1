//ya_shaderList v0.4, 25 feb 2006
//
//Author
//======
//calin panait [ yashu ] 2004-2006, alayashu@yahoo.com

//Description
//===========
//Builds the popupMenu with Scene Shaders, Copy/Paste Clipboard and Break Connection.
//For a detailed help see help inside shaderList window (RMB over the list or click the help bar)
//
//
//Notes
//=====
//This script's UI may not work wery well on other OS than Windows or on other versions of
//Maya (I use 7.0, but it should work on 6.x, 5.x).
//The problem is that the script uses colors, so parts of the UI may not be visible on these OS's (?).
//
//If you have other maya version than 7 / 6.x, some AE*.mel files may cause errors (incompatibility issues).
//I think the AEnew*.mel and AEreplace*.mel shouldn't cause errors (since they were not changed for ages :p),
//so you could try copying only these files, to show SL and dragNDrop on most controls of AtributeEditor.
//
//New to ShaderList 0.4
//-rewrote the copy/paste feature
//-removed the bookmarking feature (become obsolete because of the new copy/pase feature)
//-code optimisations and rewrote some procs
//
//
//Limitations
//===========
//* Drag and drop doesn't work if an AE control was dimmed and then undimmed.
//* If you delete the destination shader in SL (the UI will modify)
//and then undo, you can't do any connections and you either need to reopen SL or you can
//simpy drag one attribute to the SL window. This can be simply fixed with a scriptJob, but
//I don't think it worth consuming memory for this...
//
//
//MODIFY THIS SCRIPT TO FEED YOUR NEEDS, BUT DON'T DELETE ABOVE STATEMENT
//
                                    



// some vars to keep in touch

if (!`optionVar -ex ya_selTabVarSL`) optionVar -iv ya_selTabVarSL 1;
if (!`optionVar -ex ya_placementVarSL`) optionVar -iv ya_placementVarSL 0;
if (!`optionVar -ex ya_editorVarSL`) optionVar -iv ya_editorVarSL 0;
if (!`optionVar -ex ya_mrVarSL`) optionVar -iv ya_mrVarSL 0;
if (!`optionVar -ex ya_applyVarSL`) optionVar -iv ya_applyVarSL 0;
if (!`optionVar -ex ya_sortVarSL`) optionVar -iv ya_sortVarSL 0;
if (!`optionVar -ex ya_selIndexSL`) optionVar -iv ya_selIndexSL 1;
if (!`optionVar -ex ya_bufferSizeVarSL`) optionVar -iv ya_bufferSizeVarSL 4;
if (!`optionVar -ex ya_bufferCopyPlugedVarSL`) optionVar -iv ya_bufferCopyPlugedVarSL 0;


// the clipboard container
//
global string $ya_clipboardSL[];




//ya_shaderList ($attr) will popup the SL window with $attr as destination
//

global proc ya_shaderList(string $attr){


if (!`window -ex ya_shaderListWindow`){

	window -tlb 1 -s 0 -t ("     " + $attr) -mxb 0 -w 305 ya_shaderListWindow;
	
	$form = `formLayout -dpc dropSL_ya`;
	
	tabLayout -imh 0 -imw 0 -sc "ya_selectTabSL" -p $form ya_mainTabSL;
		$tab1 = `formLayout -p ya_mainTabSL`;
		$tab2 = `formLayout -p ya_mainTabSL`;
		$tab3 = `formLayout -p ya_mainTabSL`;
		$tab4 = `formLayout -p ya_mainTabSL`;
		formLayout -p ya_mainTabSL sgTabSL_ya;
		$tab6 = `formLayout -p ya_mainTabSL`;
	//	$tab7 = `formLayout -p ya_mainTabSL`;
	
	tabLayout -edit
	 	  -tabLabel $tab1 "Materials" 
	 	  -tabLabel $tab2 "Textures"
	 	  -tabLabel $tab3 "Utilities"
	 	  -tabLabel $tab4 "Lights"
	 	  -tabLabel sgTabSL_ya "Other"
	 	  -tabLabel $tab6 "All"
	 //	  -tabLabel $tab7 "Camera" -- find this in the All tab
	ya_mainTabSL;
	
	
	$sFrame = `frameLayout -bs "etchedIn" -lv 0 -w 73 -h 89 -p $form`;
	$sForm = `formLayout -p $sFrame`;
	swatchDisplayPort -bgc 0.5 0.5 0.5 -wh 64 64 -p $sForm ya_swatchSL;
	$sText = `text -w 64 -bgc .5 .5 .5 -fn "smallPlainLabelFont" -l "    Preview" -ann "Shading Node Preview Site" -p $sForm`;
	formLayout -e
		-af ya_swatchSL top 3
		-af ya_swatchSL left 3
		-ac $sText top 0 ya_swatchSL
		-af $sText left 3
	$sForm;
	
	
	textScrollList -aas 1 -h 220 -w 201 -dcc "ya_sActionSL select" -dkc "ya_sActionSL delete" -p $form ya_shaderListSL;
	
	text -en 0 -l "" -p $form ya_nrShadersTextSL;
	
	
	button -w 100 -h 20 -c ("ya_connectShaderSL " + $attr) -l "Connect" -p $form ya_conectButSL;
	button -w 100 -h 20 -c "deleteUI ya_shaderListWindow" -l "Close" -p $form ya_cancelButSL;
	
	checkBox -l "Editor"
		 -ann "Check this to open the Connection Editor instead of auto-connection"
		 -onc "optionVar -iv ya_editorVarSL 1"
		 -ofc "optionVar -iv ya_editorVarSL 0"
		 -p $form
		 ya_editCheckSL;
	
	checkBox -l "Apply"
		 -ann "Check this to do not close the Shader List window when you click 'Connect' button"
		 -onc "optionVar -iv ya_applyVarSL 1;button -e -w 98 -l \"Apply\" ya_conectButSL"
		 -ofc "optionVar -iv ya_applyVarSL 0;button -e -w 98 -l \"Connect\" ya_conectButSL"
		 -p $form
		 ya_applyCheckSL;
	
	
	checkBox -l "Sort"
		 -ann "Check this to sort content alphabetically instead of hierarchy listing (not fully supported for lights and SG)" 
		 -onc "optionVar -iv ya_sortVarSL 1;ya_buildListSL 1;"
		 -ofc "optionVar -iv ya_sortVarSL 0;ya_buildListSL 0;"
		 -p $form
		 ya_sortCheckSL;
	
	checkBox -l "Mental Ray" -w 75
		 -ann "Check this to display Mental Ray nodes instead of Maya's"
		 -onc "optionVar -iv ya_mrVarSL 1;int $tmp_ya = `checkBox -q -v ya_sortCheckSL`;tabLayout -e -tabLabel sgTabSL_ya \"Other\" ya_mainTabSL;ya_buildListSL $tmp_ya;"
		 -ofc "optionVar -iv ya_mrVarSL 0;int $tmp_ya = `checkBox -q -v ya_sortCheckSL`;tabLayout -e -tabLabel sgTabSL_ya \"Other\" ya_mainTabSL;ya_buildListSL $tmp_ya;"
		 -p $form
		 ya_mrCheckSL;
	
	checkBox -l "Placement" -w 75
		 -ann "Check to show Texture Placement Utilities (only for Utilities and All filters)"
		 -onc "optionVar -iv ya_placementVarSL 1;int $tmp_ya = `checkBox -q -v ya_sortCheckSL`;ya_buildListSL $tmp_ya;"
		 -ofc "optionVar -iv ya_placementVarSL 0;int $tmp_ya = `checkBox -q -v ya_sortCheckSL`;ya_buildListSL $tmp_ya;"
		 -p $form
		 ya_placementCheckSL;

	iconTextButton -ann "Show Help Pane" -bgc .5 .5 .5 -c "ya_showHideBarSL" -h 10 -p $form ya_showHelpPaneSL;
	
	text -l "<<|" -w 20 -p $form ya_renameTextSL;
	nameField -ann "Rename Field : Type a new name for selected item" -p $form ya_renameFieldSL;
	
	// field to handle baseAtt rename or delete
	nameField -manage 0 -w 1 -h 1 -o $attr -p $form ya_baseAttrFieldSL;
	
	
	//$sep = `separator -style "double" -p $form`;
	$sep1 = `separator -style "double" -p $form`;
	//$sep2 = `separator -style "single" -hr 0 -h 67 -p $form`;
	
	
	scrollLayout -hst 0 -vst 14 -m 0 -en 1 -p $form ya_scrolSL;
	formLayout -bgc 0.690 0.753 0.816 ya_scrolFormSL;
	
			$txs = (
			" ======================================================================\n" +
			" Help on Shader List v0.4 - 25.02.2006\n"+
			" ==============================\n\n"+
			" Notes\n"+
			" =====\n\n"+
			" [1] Shader List Window notes\n"+
			" =======================\n"+
			"     *  Double click an item to select it, press DEL\n"+
			" to delete it from the current scene or click RMB\n"+ 
			" for more commands.\n"+
			"     *  If you drag one AE attribute to the SL window\n"+
			" then the destinaton attribute of SL will be changed\n"+
			" to that attribute. That's why I've added the Apply\n"+
			" checkBox, so can make connections to different\n"+
			" destinations without closing the main SL window\n"+
			"     *  The destination attribute is written in title bar\n"+
		  "     *  |>>  symbol marks the current shader\n"+
		  "     *  <<|  symbol marks a pluged in the dest attr\n\n"+
		  " [2] dragNDrop\n"+
		  " ===========\n"+
		  "     *  If drag control has no connection then the data\n"+
		  " (color, float, int, etc.) is dragged, plus if drop\n"+
		  " control has a connection then this is disconnected.\n\n"+
			" Version History\n"+
			" ============\n"+
			" SL v0.4\n"+
			"      <+> cleaned up the code & rewrote some procs\n"+
			"      <+> removed the bookmarks feature (useless :p)\n"+
			"      <+> fixed bugs with the Copy/Paste feature\n"+
			"      <+> minor UI changes\n"+
			" SL v0.2.5\n"+
			"      <+> modified the UI\n"+
			"      <+> modified dragNDrop and SL\n"+
			"      <+> added data clipboard feature\n"+
			"      <+> rewritten several procs\n"+
			"      <+> added support for 3 more AE files\n"+
			" SL v0.1.8\n"+
			"      <+> fixed some 'hard' bugs :)\n"+
			"      <+> rewritten a lot of procs\n"+
			"      <+> modified bookmarks\n"+
			"      <+> modified dragNDrop\n"+
			" SL v0.1.6.5\n"+
			"      <+> fixed several bugs\n"+
			"      <+> added bookmark feature\n"+
			"      <+> rewritten several procs\n"+
			" SL v0.1.5\n"+
			"      <+> fixed a lot of bugs\n"+
			"      <+> added dragNDrop feature\n"+
			"      <+> faster algorithms\n"+
			"      <+> changed the interface\n"+
			" SL v0.1.0\n"+
			"      <+> first version of Shader List\n\n"+
			" Author\n"+
			" =====\n"+
			"    Visit http:\/\/yashu.go.ro for updates\n"+
			" and contact me at alayashu@yahoo.com\n"
			);
			
			
			text -bgc 0.690 0.753 0.816 -l $txs ya_helpTextSL;
		
		formLayout -e
			-af ya_helpTextSL top 0
			-af ya_helpTextSL bottom 10
			-af ya_helpTextSL top 0
		ya_scrolFormSL;

	
	formLayout -e
		-af  ya_mainTabSL   top    0
		-af  ya_mainTabSL   left   0
		-af  ya_mainTabSL   right  0
			
		-ac  $sFrame        top    3  ya_mainTabSL
		-af  $sFrame        left   10
	//	-af  $sep1          left   10
	//	-ac  $sep1          right  1  ya_shaderListSL
	//	-ac  $sep1          top    5 $sFrame
	//	-ac  $sep2          left   1  ya_swatchSL
	//	-aoc $sep2          bottom -3  ya_swatchSL
		-af  ya_shaderListSL     left   86
		-aoc ya_shaderListSL     top    0  $sFrame
		
		-ac  ya_renameFieldSL    top    5  ya_shaderListSL
		-aoc ya_renameFieldSL    left   -1 ya_shaderListSL
		-af  ya_renameFieldSL    right  10
		-ac  ya_renameTextSL     right  0  ya_renameFieldSL
		-aoc ya_renameTextSL     top    3  ya_renameFieldSL 
		-ac  ya_baseAttrFieldSL  right  2  ya_renameTextSL
		-aoc ya_baseAttrFieldSL  top    0  ya_renameTextSL
			
		
		-ac  ya_mrCheckSL        top    3  $sFrame//$sep1
		-af  ya_mrCheckSL        left   10
		-ac  ya_sortCheckSL      top    5  ya_mrCheckSL
		-aoc ya_sortCheckSL      left   0  ya_mrCheckSL
		-ac  ya_placementCheckSL top    5  ya_sortCheckSL
		-aoc ya_placementCheckSL left   0  ya_mrCheckSL
		-ac  ya_editCheckSL      top    5  ya_placementCheckSL
		-aoc ya_editCheckSL      left   0  ya_mrCheckSL
		-ac  ya_applyCheckSL     top    5  ya_editCheckSL
		-aoc ya_applyCheckSL     left   0  ya_mrCheckSL
		
		-aoc $sep1          left   0  ya_mrCheckSL
		-ac  $sep1          right  1  ya_shaderListSL 
		-aoc $sep1 	 	   		bottom 20  ya_shaderListSL
		-ac  ya_nrShadersTextSL  top    2  $sep1
		-aoc ya_nrShadersTextSL  left   0  ya_mrCheckSL
		/*-aoc $sep           left   0  ya_mrCheckSL
		-ac  $sep           right  1  ya_shaderListSL 
		-ac  $sep  	    		top    -3  ya_shaderListSL*/
				
		-ac  ya_conectButSL      top    5  ya_renameFieldSL
		-ac  ya_conectButSL      right  3  ya_cancelButSL
		-ac  ya_cancelButSL      top    5  ya_renameFieldSL
		-af  ya_cancelButSL      right  10

		-ac  ya_showHelpPaneSL top    5  ya_cancelButSL
		-aoc ya_showHelpPaneSL left   0  ya_mrCheckSL
		-af  ya_showHelpPaneSL right  10
		-aoc ya_scrolSL        left   0  ya_mrCheckSL
		-af  ya_scrolSL        right  10 
		-ac  ya_scrolSL        top    4  ya_showHelpPaneSL
		-af  ya_scrolSL        bottom 2


	$form;
	
	popupMenu -p ya_shaderListSL ya_pop3SL;
		menuItem -c "ya_sActionSL delete" -l "Delete Item" -ann "Delete selected item (if it isn't read-only; also DEL key)";
		menuItem -c "ya_sActionSL select" -l "Select Item" -ann "Select selected item (also double click)";
		menuItem -d 1;
		menuItem -c "setFocus ya_renameFieldSL" -l "Rename Item" -ann "Rename selected item (if it isn't read-only)";
		menuItem -d 1;
		menuItem -c "ya_showHideBarSL" -l "Show help" -ann "Show Help Pane" showHelpItem;
	

	//jobs to manage rename and delete of shaders
	int $ssRenameJob = `scriptJob -p ya_shaderListWindow -e NameChanged "ya_refreshSL"`;
	int $ssDeleteJob = `scriptJob -p ya_shaderListWindow -cc delete "ya_refreshSL"`;
}	



window -e -t ("     " + $attr) ya_shaderListWindow;
button -e -c ("ya_connectShaderSL " + $attr) ya_conectButSL;
nameField -e -o $attr ya_baseAttrFieldSL;


//load materials & update UI

int $tabIndex = `optionVar -q ya_selTabVarSL`;
int $placementVar = `optionVar -q ya_placementVarSL`;
int $editorVar = `optionVar -q ya_editorVarSL`;
int $mrVar = `optionVar -q ya_mrVarSL`;
int $applyVar = `optionVar -q ya_applyVarSL`;
int $sortVar = `optionVar -q ya_sortVarSL`;

tabLayout -e -sti $tabIndex ya_mainTabSL;
checkBox -e -v $placementVar ya_placementCheckSL;
checkBox -e -v $editorVar ya_editCheckSL;
checkBox -e -v $mrVar ya_mrCheckSL;
checkBox -e -v $applyVar ya_applyCheckSL;
if ($applyVar == 1) button -e -w 100 -l "Apply" ya_conectButSL;

ya_buildListSL $sortVar;


int $nrItems = `textScrollList -q -ni ya_shaderListSL`;
if ($nrItems > 0) textScrollList -e -sii 1 ya_shaderListSL;


showWindow ya_shaderListWindow;
window -e -h 346 ya_shaderListWindow;
}




//
// called when tabs get switched, to refresh the list
//

global proc ya_selectTabSL(){
int $selected = `tabLayout -q -sti ya_mainTabSL`;
int $sortVar = `optionVar -q ya_sortVarSL`;

switch($selected){
	case 1:{ //materials
		optionVar -iv ya_selTabVarSL 1;
		ya_buildListSL $sortVar;
		break;	
	}	
	case 2:{ //textures
		optionVar -iv ya_selTabVarSL 2;
		ya_buildListSL $sortVar;
		break;
	}
	case 3:{ //utilities
		optionVar -iv ya_selTabVarSL 3;
		ya_buildListSL $sortVar;
		break;	
	}
	case 4:{ //lights
		optionVar -iv ya_selTabVarSL 4;
		ya_buildListSL $sortVar;
		break;	
	}
	case 5:{//SG/Other
		optionVar -iv ya_selTabVarSL 5;
		ya_buildListSL $sortVar;
		break;
	}
	case 6:{//All
		optionVar -iv ya_selTabVarSL 6;
		ya_buildListSL $sortVar;
		break;
	}
} 	
	
}




//
//ya_selectShadeSL
//called when selection changes in shaderList's list
//


global proc ya_selectShadeSL(){

int    $index[] = `textScrollList -q -sii ya_shaderListSL`;
string $name[]  = `textScrollList -q -si ya_shaderListSL`;
string $attr_1  = `window -q -t ya_shaderListWindow`;
string $attr    = strip($attr_1);
string $pluged[];


if (`objExists $attr`){
	string $plug[] = `defaultNavigation -qt 1 -dtv -d $attr`;
	tokenize $plug[0] "." $pluged;
}



if ($name[0] != "" && `objExists $name[0]`){

	swatchDisplayPort -e -sn $name ya_swatchSL;

	if (    $name[0] != "lambert1" &&
	        $name[0] != "particleCloud1" &&
	        $name[0] != "initialParticleSE" &&
	        $name[0] != "initialShadingGroup" &&
	        $name[0] != "perspShape" &&
	        $name[0] != "frontShape" &&
	        $name[0] != "sideShape" &&
	        $name[0] != "topShape"
	    )  	
	    	nameField -e -en 1 -o $name[0] ya_renameFieldSL;
	
	else	nameField -e -en 0 -o $name[0] ya_renameFieldSL;

	
	if ($name[0] == `nameField -q -o ya_baseAttrFieldSL`)
		text -e -l "|>>" -w 20 ya_renameTextSL;
	else
	if ($name[0] == $pluged[0])
		text -e -l "<<|" -w 20 ya_renameTextSL;
	else	text -e -l "" -w 20 ya_renameTextSL;
		
	optionVar -iv ya_selIndexSL $index[0];
	}
else
	text -e -l "" -w 20 ya_renameTextSL;
}





//
// called to refresh the list
//


global proc ya_buildListSL(int $sort){

int $selected  = `tabLayout -q -sti ya_mainTabSL`;
int $mr 			 = `checkBox -q -v ya_mrCheckSL`;
int $placement = `checkBox -q -v ya_placementCheckSL`;

string $list[];

switch ($selected)
{
	case 1:
	if (!$mr)  $list = `ya_allListSL "maya_materials"`;
	else			 $list = `ya_allListSL "mr_materials"`;
	if ($sort) $list = `sort $list`;
	checkBox -e -en 0 ya_placementCheckSL;	
	break;
	

	case 2:
	if (!$mr) $list = `ya_allListSL "maya_textures"`;
	else			$list = `ya_allListSL "mr_textures"`;
	if ($sort) $list = `sort $list`;
	checkBox -e -en 0 ya_placementCheckSL;	
	break;
	
	
	case 3:
	if (!$mr)
	{
		if ($placement)
		{
			$list = `ya_allListSL "maya_utilities"`;
		}
		else
		{
			$list = `ya_allListSL "maya_utilities_noplacement"`;
		}
	}
	else $list = `ya_allListSL "mr_utilities"`;
	if ($sort) $list = `sort $list`;
	checkBox -e -en 1 ya_placementCheckSL;	
	break;
	

	case 4:
	if (!$mr) $list = `ya_allListSL "maya_lights"`;
	else 			$list = `ya_allListSL "mr_lights"`;
	if ($sort) $list = `sort $list`;
	checkBox -e -en 0 ya_placementCheckSL;	
	break;

	
	case 5:
	//if (!$mr) $list = `ya_allListSL "maya_cameras"`;
	//else			$list = `ya_allListSL "maya_cameras"`;
	$list  = `ya_allListSL "maya_cameras"`;
	$item1 = `ya_allListSL "maya_SG"`;
	appendStringArray($list, $item1, size($item1));	
	
	if ($sort) $list = `sort $list`;
	checkBox -e -en 0 ya_placementCheckSL;	
	break;
	

	case 6:
	if (!$mr)
	{
		if ($placement)
		{
			$list = `ya_allListSL "maya_all_noplacement"`;
		}
		else
		{
			$list = `ya_allListSL "maya_all"`;
		}
	}
	else $list = `ya_allListSL "mr_all"`;
	
	if ($sort) $list = `sort $list`;
	checkBox -e -en 1 ya_placementCheckSL;	
	break;
}


textScrollList -e -ra ya_shaderListSL;

for ($cShader in $list)
{
	textScrollList -e -a $cShader -sc "ya_selectShadeSL" ya_shaderListSL;
}
if (size($list) == 0 ) nameField -e -en 0 -o "" ya_renameFieldSL;


//update UI when tabs get changed
//

$val = `optionVar -q ya_sortVarSL`;
checkBox -e -en 1 -v $val ya_sortCheckSL;

int $selIndex = `optionVar -q ya_selIndexSL`;

int $nrItems = `textScrollList -q -ni ya_shaderListSL`;
if ($nrItems > 0 && $selIndex <= $nrItems) {
	textScrollList -e -sii $selIndex ya_shaderListSL;
	}
else if ($nrItems > 0)
{
	textScrollList -e -sii 1 ya_shaderListSL;
}


string $sNrItems = $nrItems;
if ($sNrItems == "0") $sNrItems = "no";
text -e -l ($sNrItems + " items") ya_nrShadersTextSL;

ya_selectShadeSL();
}






//lists all shaders in scene by filters, in hierarchy order, so you can sort after with `sort`
//
//to get all filters supported just type `ya_allListSL "help"`
//
//example :  string $mayaTextures[] = `ya_allListSL "maya_textures" // returns all maya textures in scene
//			     string $mrLights[]     = `ya_allListSL "mr_lights"     // returns all mr lights in scene
//


global proc string[] ya_allListSL(string $type)
{
	string $returnVal[];
	int $index = 0;
	
	switch($type){
		case "maya_materials" : 
		{
			string $shaders[] = `ls -materials`;
			for ($shade in $shaders){
				string $nodeType = `nodeType $shade`;
				string $class[] = `getClassification $nodeType`;
				if (!gmatch($class[0], "rendernode/mentalray*")) {
					$returnVal[$index] = $shade;
					$index++;
					}
				}
			break;
		}
		case "maya_textures" : 
		{
			string $shaders[] = `ls -tex`;
			for ($shade in $shaders){
				string $nodeType = `nodeType $shade`;
				string $class[] = `getClassification $nodeType`;
				if (!gmatch($class[0], "rendernode/mentalray*")) {
					$returnVal[$index] = $shade;
					$index++;
					}
				}
			break;
		}
		case "maya_utilities" : case "maya_utilities_noplacement" :
		{
			string $shaders[] = `listConnections defaultRenderUtilityList1`;
			for ($shade in $shaders){
				string $nodeType = `nodeType $shade`;
				string $class[] = `getClassification $nodeType`;
				if ($type == "maya_utilities_noplacement")
				{
					if (!gmatch($class[0], "rendernode/mentalray*") && $nodeType != "place3dTexture" && $nodeType != "place2dTexture")
						$returnVal[$index] = $shade;$index++;
				}
				else
				{
					if (!gmatch($class[0], "rendernode/mentalray*"))
						$returnVal[$index] = $shade;$index++;
				}
			}
			break;
		}
		
		case "maya_lights" : 
		{
			$returnVal = `ls -lights`;
			break;
		}
		case "maya_cameras" : 
		{
			$returnVal = `ls -cameras`;
			break;
		}
		case "maya_SG" :
		{
			$returnVal = `ls -type shadingEngine`;
			break;
		}
		case "maya_all" : case "maya_all_noplacement" :
		{
			$returnVal = `ya_allListSL "maya_materials"`;
			
			$item1 = `ya_allListSL "maya_textures"`;
			appendStringArray($returnVal, $item1, size($item1));	
			
			if ($type == "maya_all_noplacement")
				$item1 = `ya_allListSL "maya_utilities_noplacement"`;
			else
				$item1 = `ya_allListSL "maya_utilities"`;
			appendStringArray($returnVal, $item1, size($item1));	
			
			$item1 = `ya_allListSL "maya_lights"`;
			appendStringArray($returnVal, $item1, size($item1));	
			$item1 = `ya_allListSL "maya_SG"`;
			appendStringArray($returnVal, $item1, size($item1));	
			$item1 = `ya_allListSL "maya_cameras"`;
			appendStringArray($returnVal, $item1, size($item1));	
			
			break;	
		}
		
	/*	case "mr_materials":
		{
			string $shaderTypes[] = `listNodeTypes -ex "rendernode/mentalray/texture" "rendernode/mentalray"`;
	
			for ($type in $shaderTypes)
			{
				$shaders = `ls -et $type`;
				string $class[] = `getClassification $type`;
			
				if (gmatch ($class[0], "*material*") || gmatch ($class[0], "*volume*") || gmatch ($class[0], "*photon*") || gmatch ($class[0], "*photonvol*")  || gmatch ($class[0], "*displace*") || gmatch ($class[0], "*shadow*"))
				{
					for ($shade in $shaders)
					{
						$returnVal[$index] = $shade;
						$index++;
					}
				}			
			}
			break;	
		}
		*/
		
		case "mr_materials" : // Volumetric and Materials & Environments
		{
		
			string $all[] = `lsThroughFilter -sort "byTime" DefaultMaterialsFilter`;
			string $shade;
			for ($shade in $all){
				string $typ = `nodeType $shade`;
				string $class[] = `getClassification $typ`;
				if ( gmatch($class[0], "rendernode/mentalray/material*") || gmatch($class[0], "rendernode/mentalray/volume*") || gmatch($class[0], "rendernode/mentalray/environment*")) {
					$returnVal[$index] = $shade;
					$index++;
					}
				}
			break;
		}
		/*
		
		case "mr_textures":
		{
			string $shaderTypes[] = `listNodeTypes -ex "rendernode/mentalray/contour" "rendernode/mentalray"`;
	
			for ($type in $shaderTypes)
			{
				$shaders = `ls -et $type`;
				string $class[] = `getClassification $type`;
			
				if (gmatch ($class[0], "*texture*"))
				{
					for ($shade in $shaders)
					{
						$returnVal[$index] = $shade;
						$index++;
					}
				}			
			}
			break;	
		}
		*/
		case "mr_textures" : //textures are returned
		{
			string $all[] = `lsThroughFilter -sort "byTime" DefaultTexturesFilter`;
			string $texture;
	
			for ($texture in $all){
				string $nodeType = `nodeType $texture`;
				string $class[] = `getClassification $nodeType`;
				if (gmatch($class[0], "rendernode/mentalray/texture*")) {
					$returnVal[$index] = $texture;
					$index++;
					}
				}
			
			break;
		}
		
		/*
		case "mr_utilities":
		{
			string $shaderTypes[] = `listNodeTypes "rendernode/mentalray"`;
	
			for ($type in $shaderTypes)
			{
				$shaders = `ls -et $type`;
				string $class[] = `getClassification $type`;
			
				if (gmatch ($class[0], "*misc*") || gmatch ($class[0], "*lens*")  || gmatch ($class[0], "*output*")  || gmatch ($class[0], "*lightmap*") || gmatch ($class[0], "*composite*")  || gmatch ($class[0], "*conversion*")  || gmatch ($class[0], "*state*")  || gmatch ($class[0], "*emitter*") ||  gmatch ($class[0], "*environment*") || gmatch ($class[0], "*contour*") || gmatch ($class[0], "*geometry*") )
				{
					for ($shade in $shaders)
					{
						$returnVal[$index] = $shade;
						$index++;
					}
				}			
			}
			break;	
		}
		*/
		case "mr_utilities" : 
		{
			string $all[] = `lsThroughFilter -sort "byTime" DefaultRenderUtilitiesFilter`;
			string $utility;
	
			for ($utility in $all){
				string $nodeType = `nodeType $utility`;
				string $class[] = `getClassification $nodeType`;
				if ( gmatch($class[0], "rendernode/mentalray*") )
				  if (gmatch($class[0], "rendernode/mentalray/lightmap*") || !gmatch($class[0], "rendernode/mentalray/light*"))
				  {
					$returnVal[$index] = $utility;
					$index++;
					}
			}
			break;
		}
		
		case "mr_lights" : 
		{
			string $shaderTypes[] = `listNodeTypes "rendernode/mentalray/light"`;
			
			for ($type in $shaderTypes){
				$shaders = `ls -et $type`;
				for ($shade in $shaders){
					$returnVal[$index] = $shade;
					$index++;
				}
			}
			break;
		}
		
		case "mr_other" : //geometry and contour classes
		{
			/*
			string $all[] = `listConnections defaultRenderUtilityList1`;
			string $other;
	
			for ($other in $all){
				string $nodeType = `nodeType $other`;
				string $class[] = `getClassification $nodeType`;
				if ( gmatch($class[0], "rendernode/mentalray/contour*") || gmatch($class[0], "rendernode/mentalray/geometry*")){
					$returnVal[$index] = $other;
					$index++;
					}
			}
			break;*/
			
			$returnVal = `ls -type shadingEngine`;
			break;
			
		}
		case "mr_all" :
		{
			$returnVal = `ya_allListSL "mr_materials"`;
			
			$item1 = `ya_allListSL "mr_textures"`;
			appendStringArray($returnVal, $item1, size($item1));	
			
			$item1 = `ya_allListSL "mr_utilities"`;
			appendStringArray($returnVal, $item1, size($item1));	
			
			$item1 = `ya_allListSL "mr_lights"`;
			appendStringArray($returnVal, $item1, size($item1));	
			
			$item1 = `ya_allListSL "mr_other"`;
			appendStringArray($returnVal, $item1, size($item1));	
	
			break;	
		}
		default : 
		{
			error (
			$type + " isn't a valid type. See script editor for details...\n\n" +
			"Use one of : maya_materials, maya_textures, maya_utilities\n"+
			"maya_utilities_noplacement, maya_lights, maya_cameras, maya_SG\n"+
			"maya_all, maya_all_noplacement, mr_materials, mr_textures, mr_utilities\n"+
			"mr_lights, mr_other or mr_all\n"
			);
			break;
		}
	}
	return $returnVal;
}



//
// ya_sActionSL (string $mod)
// delete/select commands in SL window
//

global proc ya_sActionSL(string $mod)
{
	string $attrName[] = `textScrollList -q -si ya_shaderListSL`;
	int    $index[]    = `textScrollList -q -sii ya_shaderListSL`;
	int    $nr         = `textScrollList -q -ni ya_shaderListSL`;
	
	if ($index[0] != 0)
	{
	
		string $shaderName[];
		tokenize $attrName[0] "." $shaderName;
		
		if ($mod == "delete")
		{
			if ($shaderName[0] == "lambert1" ||
			    $shaderName[0] == "particleCloud1" ||
			    $shaderName[0] == "initialParticleSE" ||
			    $shaderName[0] == "initialShadingGroup" ||
			    $shaderName[0] == "perspShape" ||
			    $shaderName[0] == "frontShape" ||
			    $shaderName[0] == "sideShape" ||
			    $shaderName[0] == "topShape"
			    )
			warning ("Cannot delete a read-only node!");
			else
			{
				$shapes = `ls -s $shaderName[0]`;
				if (size($shapes))
				{
					$shaderName = `listRelatives -parent $shaderName[0]`;
				}
						
				delete $shaderName[0];
				
				textScrollList -e -rii $index[0] ya_shaderListSL;
				if ($index[0] > 1)
				{
					textScrollList -e -sii ($index[0]-1) ya_shaderListSL;
				}
				if ($index[0] == 1 && $nr > 1) textScrollList -e -sii 1 ya_shaderListSL;
			}
		}
		if ($mod == "select")
		{
			select -ne $shaderName[0];
		}
	}
}



//
//called when destination shader changes it's name or when it gets deleted
//

global proc ya_refreshSL()
{
	if (`window -ex ya_shaderListWindow`)
	{
		$sort = `checkBox -q -v ya_sortCheckSL`;
		$newSel = `nameField -q -o ya_renameFieldSL`;
		$baseAttr = `nameField -q -o ya_baseAttrFieldSL`;
		
		if(`nameField -q -en ya_baseAttrFieldSL` == 0)
		{
			if ($baseAttr != "lambert1" && 
			    $baseAttr != "particleCloud1" &&
			    $baseAttr != "initialParticleSE" &&
			    $baseAttr != "initialShadingGroup" &&
			    $baseAttr != "perspShape" &&
			    $baseAttr != "frontShape" &&
			    $baseAttr != "sideShape" &&
			    $baseAttr != "topShape"
			    )
			$baseAttr = "";
		}
				
		button -e -en 1 -c ("ya_connectShaderSL " + $baseAttr) ya_conectButSL;
	

		string $chan = `window -q -t ya_shaderListWindow`;
		string $channel[];
		tokenize $chan "." $channel;
		
		if ($baseAttr != "")
		{
			window -e -t ("     " + $baseAttr + "." +$channel[1]) ya_shaderListWindow;
			button -e -en 1 ya_conectButSL;
		}
		else
		{
			window -e -t ("     Destination was deleted") ya_shaderListWindow;
			button -e -en 0 ya_conectButSL;
		}
		
		ya_buildListSL $sort;
		
		if (`objExists($newSel)`)
			textScrollList -e -si $newSel ya_shaderListSL;
		
		ya_selectShadeSL;
	}
}



//
// connects the selected item in the SL window to the destination attr
//

global proc ya_connectShaderSL(string $attr)
{
	string $plug[];
	$plug = `textScrollList -q -si ya_shaderListSL`;
	
	if ($plug[0] == "") return;

	int $editor = `checkBox -q -v ya_editCheckSL`;

	if ($editor == 1)
	{
		string $plugEd[];
		tokenize $attr "." $plugEd;
		connectWindowWith $plug[0] $plugEd[0];
	}
	else
	{
		defaultNavigation  -qt 1 -f true -ce -s $plug[0] -d $attr;
	}
	if (`button -q -l ya_conectButSL` == "Connect") deleteUI ya_shaderListWindow;
}





//
// returns an array containing all pluged attribute channels
//

global proc string[] ya_plugedInAttrSL(string $attr)
{
	string $returnVal[];
	
	if (!`objExists $attr`) return {""};
	
	string $name[];
	tokenize $attr "." $name;
	int $k=0;
	
	string $canale[] = `listAttr $attr`;
	
	for ($i=0; $i<size($canale); $i++)
	{
		string $plug[] =  `listConnections -d 0 -p 1 ($name[0] + "." + $canale[$i])`;
		if ($plug[0] != "")
		{
			$returnVal[$k] = $plug[0];
			$k++;
		}
	}
	return $returnVal;
}






//
//build the popup-menus over controls in AE
//


global proc popupItems(string $attr, string $popName)
{
popupMenu -e -dai $popName;


global string $ya_clipboardSL[];
global string $books_ya[];
string $pluged[] = ya_plugedInAttrSL($attr);


menuItem -l "Scene Shaders" -ann "Lists all shaders in scene, by category, for connections" -c ("ya_shaderList " + $attr) -p $popName ($popName + "_doi");


string $connection;
for ($i=0;$i<size($pluged);$i++)
{
	if ( $i != (size($pluged)-1) )
	{
		$connection += ($pluged[$i] + " and " );
	}
	else
	{
		$connection += ($pluged[$i] + ".");
	}
}


if (size($pluged))
{
	menuItem -l "Break Connection" -ann ("Disconnect from " + $connection) -c ("defaultNavigation -qt 1 -dis -d " + $attr) -p $popName;
}


menuItem -d true -p $popName;



int $bufferSize = `optionVar -q ya_bufferSizeVarSL`;


// copy submenu
//

$copyMenu = `menuItem -l "Copy" -sm true -p $popName`;

for ($i=0; $i<$bufferSize; $i++)
{
	// annotation
	//
	
	string $ann = ("Copy #" + ($i+1) + ": Copy data to buffer" + ($i+1));
	if (`objExists $ya_clipboardSL[$i*2+1]` && $ya_clipboardSL[$i*2+1] != "") 
	{
		$ann += (". ( " + $ya_clipboardSL[$i*2+1] + " )");
	}
	else
	if ($ya_clipboardSL[$i*2+1] != "")
	{
		$ann += (". ( " + $ya_clipboardSL[$i*2+1] + " - Deleted/Renamed )");
	}
	else
	{
		$ann += (". ( Empty )");
	}

	//menu item
	//
	
	menuItem -l ("Copy #" + ($i+1)) 
		 -ann $ann 
		 -c ("ya_clipboardSL copy " + ($i*2) + " " + $attr ) 
		 -p $copyMenu;
}
	
menuItem -d 1 -p $copyMenu;
menuItem -l "Settings" -ann "Open Clipboard Settings Window" -c "ya_clipboardSettingsSL" -p $copyMenu;
menuItem -d 1 -p $copyMenu;


// paste submenu

$pasteMenu = `menuItem -l "Paste" -sm true -p $popName`;

for ($i=0; $i<$bufferSize; $i++)
{		
	// annotation
	
	string $ann = ("Paste #" + ($i+1) + ":");
	
	if ($ya_clipboardSL[$i*2+1] == "")
	{
		$ann += (" Paste data from buffer" + ($i+1) + ". ( Empty )");
	}
	else 
	{
		if (`objExists $ya_clipboardSL[$i*2+1]`)
		{
			string $tmp = "";
			string $plugs[] = `ya_plugedInAttrSL($ya_clipboardSL[$i*2+1])`;	
			if (`optionVar -q ya_bufferCopyPlugedVarSL` == 1 && size($plugs) != 0 ) $tmp = " - Paste-Pluged Enabled";
			
			$ann += (" Paste data from buffer" + ($i+1) + ". ( " + $ya_clipboardSL[$i*2+1] + $tmp + " )");
		}
		else
		{
			string $tmp = "";
			if (`optionVar -q ya_bufferCopyPlugedVarSL` == 1) $tmp = " - Paste-Pluged Disabled";
			$ann += (" Paste data from buffer" + ($i+1) + ". ( " + $ya_clipboardSL[$i*2+1] + " - Deleted/Renamed" + $tmp + ")");
		}
	}
	
	// menu item
	//
	
	menuItem -l ("Paste #" + ($i+1)) 
		 -ann $ann 
		 -c ("ya_clipboardSL paste " + ($i*2) + " " + $attr ) 
		 -p $pasteMenu;
}

menuItem -d 1 -p $pasteMenu;
menuItem -l "Settings" -ann "Open Clipboard Settings Window" -c "ya_clipboardSettingsSL" -p $pasteMenu; 
menuItem -d 1 -p $pasteMenu;

setParent -m ..;
menuItem -d 1;

}





//
// Clipboard Settings Window
//


global proc ya_clipboardSettingsSL(){
$win = `window -s 0 -t "SL Clipboard Settings"`;

$val1 = `optionVar -q ya_bufferSizeVarSL`;
$val2 = `optionVar -q ya_bufferCopyPlugedVarSL`;

$form   = `formLayout`;
$slider = `intSliderGrp -cw 1 100 -f 1 -l "Number of Buffers" -min 2 -max 15 -v $val1`;

$cpPlug = `checkBox -l "Enable Paste-Pluged Mode" 
			    -ann "Check this to paste the pluged of your Copy# (if there are)" 
			    -onc "optionVar -iv ya_bufferCopyPlugedVarSL 1;" 
			    -ofc "optionVar -iv ya_bufferCopyPlugedVarSL 0;"
		  	  -v $val2
	  	    `;

$sep = `separator`;
//$sep1 = `separator -style "out"`;
$sep2 = `separator`;

$ok     = `button -h 20 -w 110 -l "Save" -c ("int $value = `intSliderGrp -q -v " + $slider + "`;optionVar -iv ya_bufferSizeVarSL $value; deleteUI " + $win)`;
$cancel = `button -h 20 -w 110 -l "Close" -c ("deleteUI " + $win)`;
$clear  = `button -h 20 -w 110 -l "Clear Buffers" -c ("clear $ya_clipboardSL")`;

formLayout -e
	-af $sep    			top  5
	-af $sep    			left 0
	-af $sep    			right 0
	
	-ac $slider				top  5  $sep
	-af $slider 			left 10

/*	-ac $sep1    			top  5 $slider
	-af $sep1    			left 0
	-af $sep1    			right 0
*/
	-ac $cpPlug    		top  5 $slider
	-af $cpPlug    		left 110
	
	-ac $sep2    			top  5 $cpPlug
	-af $sep2    			left 0
	-af $sep2    			right 0
	
	-af $ok     			left 10
	-ac $ok     			top  5 $sep2
	
	-ac $clear     		left 5 $ok
	-ac $clear     		top  5 $sep2
	
	-ac $cancel 			top  5 $sep2
	-ac $cancel 			left 5 $clear
$form;

showWindow $win;
window -e -wh 365 120 $win;
}




//
// Clipboard operations (copy/paste)
// $mod    = "copy" or "paste"
// $buffer = buffer level
// $attr   = atribute to copy to buffer/paste
//


global proc ya_clipboardSL(string $mod, int $buffer, string $attr)
{
	global string $ya_clipboardSL[];
	
	if ($mod == "copy")
	{
		float $dAttr[];
		if (catchQuiet(eval("float $checkSL_tmp[] = `getAttr " + $attr + "`")) == 1)
		{
			$dAttr[0] = `getAttr $attr`;
		}
		else
		{
			$dAttr = `getAttr $attr`;
		}
		
		string $temp;
		for ($da in $dAttr) $temp += ($da + "@");
		
		// $data = 0.72 0.23 1.3 -> $temp = "0.72@0.23@1.3@"
		// 
		
		$ya_clipboardSL[$buffer+0] = $temp;
		$ya_clipboardSL[$buffer+1] = $attr;
	}
	
	if ($mod == "paste")
	{
		if (`getAttr -se $attr` == 1)
		{
			string $plugs[] = `ya_plugedInAttrSL($ya_clipboardSL[$buffer+1])`;
			
			// paste pluged
			if (`optionVar -q ya_bufferCopyPlugedVarSL` == 1 && `objExists $ya_clipboardSL[$buffer+1]` == 1 && size($plugs) != 0)
			{
				string $tokens[];
				tokenize $plugs[0] "." $tokens;
				$plugs[0] = $tokens[0];

				if ($plugs[0] != $attr)
					defaultNavigation -qt 1 -f true -ce -s $plugs[0] -d $attr;
				else warning ("Cannot connect " + $plugs[0] + " with " + $attr);
			}
			// paste data
			else
			{
				string $atts[];
				tokenize $ya_clipboardSL[$buffer] "@" $atts;
				
				float $pAttr[];	
				if (catchQuiet(eval("float $checkSL_tmp[] = `getAttr " + $attr + "`")) == 1)
					$pAttr[0] = `getAttr $attr`;
				else    $pAttr = `getAttr $attr`;
				
				if (size($pAttr) == size($atts))
				{
					string $paste;
					for ($k=0; $k<size($atts); $k++)
						$paste += ($atts[$k] + " ");
					eval ("setAttr " + $attr + " " + $paste);
				}
				else warning ("Cannot Copy/Paste between incompatible attributes!");
			}
		}
		else warning ("Cannot Paste!");
	}
}




//
// Toggle Help Bar
//

global proc ya_showHideBarSL(){

int $state = `scrollLayout -q -m ya_scrolSL`;
int $h     = `window -q -h ya_shaderListWindow`;

scrollLayout -e -m (!$state) ya_scrolSL;	

// show the help pane
if ($state == 0) {
	iconTextButton -e -ann "Hide Help" ya_showHelpPaneSL;
	menuItem -e -l "Hide Help" -ann "Hide Help Pane" showHelpItem;
	window -e -h ($h+180) ya_shaderListWindow;
	
	//move SL window if it's too low	

	int $mainHeight = `window -q -h MayaWindow`;
	int $topEdge    = `window -q -te ya_shaderListWindow`;
	int $limit = ($mainHeight - ($h+180) - 10);
	
	if ($topEdge > $limit)
		window -e -te $limit ya_shaderListWindow;
	}
// hide the help pane	
if ($state == 1) {
	iconTextButton -e -ann "Show Help" ya_showHelpPaneSL;
	menuItem -e -l "Show Help" -ann "Show Help Pane"  showHelpItem;
	window -e -h ($h-180) ya_shaderListWindow;
	}
}
